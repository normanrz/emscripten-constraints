function $A(iterable) {
    if (!iterable) return [];
    if ("toArray" in Object(iterable)) return iterable.toArray();
    for (var length = iterable.length || 0, results = new Array(length); length--;) results[length] = iterable[length];
    return results
}

function $w(string) {
    return Object.isString(string) ? (string = string.strip(), string ? string.split(/\s+/) : []) : []
}

function $H(object) {
    return new Hash(object)
}

function $R(start, end, exclusive) {
    return new ObjectRange(start, end, exclusive)
}

function __oldNamespace(spec, context) {
    var i, N;
    if (context = context || window, spec = spec.valueOf(), "object" != typeof spec) {
        if ("string" == typeof spec) return function() {
            var parts;
            for (parts = spec.split("."), i = 0, N = parts.length; N > i; i++) spec = parts[i], context[spec] = context[spec] || {}, context = context[spec]
        }(), context;
        throw new TypeError
    }
    if ("number" == typeof spec.length)
        for (i = 0, N = spec.length; N > i; i++) return namespace(spec[i], context);
    else
        for (i in spec)
            if (spec.hasOwnProperty(i)) return context[i] = context[i], namespace(spec[i], context[i])
}

function namespace(spec, context) {
    var codeDB;
    "$" == spec[0] && (codeDB = spec.substring(1, spec.indexOf(".")), spec = spec.substring(spec.indexOf(".") + 1));
    var ret = __oldNamespace(spec, context);
    return codeDB && (ret.fromDB = codeDB), ret
}

function contentLoaded(win, fn) {
    var done = !1,
        top = !0,
        doc = win.document,
        root = doc.documentElement,
        add = doc.addEventListener ? "addEventListener" : "attachEvent",
        rem = doc.addEventListener ? "removeEventListener" : "detachEvent",
        pre = doc.addEventListener ? "" : "on",
        init = function(e) {
            ("readystatechange" != e.type || "complete" == doc.readyState) && (("load" == e.type ? win : doc)[rem](pre + e.type, init, !1), !done && (done = !0) && fn.call(win, e.type || e))
        },
        poll = function() {
            try {
                root.doScroll("left")
            } catch (e) {
                return setTimeout(poll, 50), void 0
            }
            init("poll")
        };
    if ("complete" == doc.readyState) fn.call(win, "lazy");
    else {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement
            } catch (e) {}
            top && poll()
        }
        doc[add](pre + "DOMContentLoaded", init, !1), doc[add](pre + "readystatechange", init, !1), win[add](pre + "load", init, !1)
    }
}

function StringBuffer() {
    this.strings = [];
    for (var idx = 0; idx < arguments.length; idx++) this.nextPutAll(arguments[idx])
}

function ReadStream(anArrayOrString) {
    this.src = anArrayOrString, this.pos = 0
}

function ometaUnescape(s) {
    if ("\\" != s.charAt(0)) return s;
    switch (s.charAt(1)) {
        case "'":
            return "'";
        case '"':
            return '"';
        case "\\":
            return "\\";
        case "b":
            return "\b";
        case "f":
            return "\f";
        case "n":
            return "\n";
        case "r":
            return "\r";
        case "t":
            return "  ";
        case "v":
            return "";
        case "x":
            return String.fromCharCode(parseInt(s.substring(2, 4), 16));
        case "u":
            return String.fromCharCode(parseInt(s.substring(2, 6), 16));
        default:
            return s.charAt(1)
    }
}

function tempnam(s) {
    return (s ? s : "_tmpnam_") + tempnam.n++
}

function OMInputStream(hd, tl) {
    this.memo = {}, this.lst = tl.lst, this.idx = tl.idx, this.hd = hd, this.tl = tl
}

function OMInputStreamEnd(lst, idx) {
    this.memo = {}, this.lst = lst, this.idx = idx
}

function ListOMInputStream(lst, idx) {
    this.memo = {}, this.lst = lst, this.idx = idx, this.hd = lst.at(idx)
}

function makeListOMInputStream(lst, idx) {
    return new(idx < lst.length ? ListOMInputStream : OMInputStreamEnd)(lst, idx)
}

function makeOMInputStreamProxy(target) {
    return objectThatDelegatesTo(target, {
        memo: {},
        target: target,
        tl: void 0,
        tail: function() {
            return this.tl || (this.tl = makeOMInputStreamProxy(target.tail()))
        }
    })
}

function Failer() {}
var Prototype = {
    Version: "1.7.2",
    Browser: function() {
        var ua = navigator.userAgent,
            isOpera = "[object Opera]" == Object.prototype.toString.call(window.opera);
        return {
            IE: !!window.attachEvent && !isOpera,
            Opera: isOpera,
            WebKit: ua.indexOf("AppleWebKit/") > -1,
            Gecko: ua.indexOf("Gecko") > -1 && -1 === ua.indexOf("KHTML"),
            MobileSafari: /Apple.*Mobile/.test(ua)
        }
    }(),
    BrowserFeatures: {
        XPath: !!document.evaluate,
        SelectorsAPI: !!document.querySelector,
        ElementExtensions: function() {
            var constructor = window.Element || window.HTMLElement;
            return !(!constructor || !constructor.prototype)
        }(),
        SpecificElementExtensions: function() {
            if ("undefined" != typeof window.HTMLDivElement) return !0;
            var div = document.createElement("div"),
                form = document.createElement("form"),
                isSupported = !1;
            return div.__proto__ && div.__proto__ !== form.__proto__ && (isSupported = !0), div = form = null, isSupported
        }()
    },
    ScriptFragment: "<script[^>]*>([\\S\\s]*?)</script\\s*>",
    JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
    emptyFunction: function() {},
    K: function(x) {
        return x
    }
};
Prototype.Browser.MobileSafari && (Prototype.BrowserFeatures.SpecificElementExtensions = !1);
var Class = function() {
    function subclass() {}

    function create() {
        function klass() {
            this.initialize.apply(this, arguments)
        }
        var parent = null,
            properties = $A(arguments);
        Object.isFunction(properties[0]) && (parent = properties.shift()), Object.extend(klass, Class.Methods), klass.superclass = parent, klass.subclasses = [], parent && (subclass.prototype = parent.prototype, klass.prototype = new subclass, parent.subclasses.push(klass));
        for (var i = 0, length = properties.length; length > i; i++) klass.addMethods(properties[i]);
        return klass.prototype.initialize || (klass.prototype.initialize = Prototype.emptyFunction), klass.prototype.constructor = klass, klass
    }

    function addMethods(source) {
        var ancestor = this.superclass && this.superclass.prototype,
            properties = Object.keys(source);
        IS_DONTENUM_BUGGY && (source.toString != Object.prototype.toString && properties.push("toString"), source.valueOf != Object.prototype.valueOf && properties.push("valueOf"));
        for (var i = 0, length = properties.length; length > i; i++) {
            var property = properties[i],
                value = source[property];
            if (ancestor && Object.isFunction(value) && "$super" == value.argumentNames()[0]) {
                var method = value;
                value = function(m) {
                    return function() {
                        return ancestor[m].apply(this, arguments)
                    }
                }(property).wrap(method), value.valueOf = function(method) {
                    return function() {
                        return method.valueOf.call(method)
                    }
                }(method), value.toString = function(method) {
                    return function() {
                        return method.toString.call(method)
                    }
                }(method)
            }
            this.prototype[property] = value
        }
        return this
    }
    var IS_DONTENUM_BUGGY = function() {
        for (var p in {
                toString: 1
            })
            if ("toString" === p) return !1;
        return !0
    }();
    return {
        create: create,
        Methods: {
            addMethods: addMethods
        }
    }
}();
! function() {
    function Type(o) {
        switch (o) {
            case null:
                return NULL_TYPE;
            case void 0:
                return UNDEFINED_TYPE
        }
        var type = typeof o;
        switch (type) {
            case "boolean":
                return BOOLEAN_TYPE;
            case "number":
                return NUMBER_TYPE;
            case "string":
                return STRING_TYPE
        }
        return OBJECT_TYPE
    }

    function extend(destination, source) {
        for (var property in source) destination[property] = source[property];
        return destination
    }

    function inspect(object) {
        try {
            return isUndefined(object) ? "undefined" : null === object ? "null" : object.inspect ? object.inspect() : String(object)
        } catch (e) {
            if (e instanceof RangeError) return "...";
            throw e
        }
    }

    function toJSON(value) {
        return Str("", {
            "": value
        }, [])
    }

    function Str(key, holder, stack) {
        var value = holder[key];
        Type(value) === OBJECT_TYPE && "function" == typeof value.toJSON && (value = value.toJSON(key));
        var _class = _toString.call(value);
        switch (_class) {
            case NUMBER_CLASS:
            case BOOLEAN_CLASS:
            case STRING_CLASS:
                value = value.valueOf()
        }
        switch (value) {
            case null:
                return "null";
            case !0:
                return "true";
            case !1:
                return "false"
        }
        var type = typeof value;
        switch (type) {
            case "string":
                return value.inspect(!0);
            case "number":
                return isFinite(value) ? String(value) : "null";
            case "object":
                for (var i = 0, length = stack.length; length > i; i++)
                    if (stack[i] === value) throw new TypeError("Cyclic reference to '" + value + "' in object");
                stack.push(value);
                var partial = [];
                if (_class === ARRAY_CLASS) {
                    for (var i = 0, length = value.length; length > i; i++) {
                        var str = Str(i, value, stack);
                        partial.push("undefined" == typeof str ? "null" : str)
                    }
                    partial = "[" + partial.join(",") + "]"
                } else {
                    for (var keys = Object.keys(value), i = 0, length = keys.length; length > i; i++) {
                        var key = keys[i],
                            str = Str(key, value, stack);
                        "undefined" != typeof str && partial.push(key.inspect(!0) + ":" + str)
                    }
                    partial = "{" + partial.join(",") + "}"
                }
                return stack.pop(), partial
        }
    }

    function stringify(object) {
        return JSON.stringify(object)
    }

    function toQueryString(object) {
        return $H(object).toQueryString()
    }

    function toHTML(object) {
        return object && object.toHTML ? object.toHTML() : String.interpret(object)
    }

    function keys(object) {
        if (Type(object) !== OBJECT_TYPE) throw new TypeError;
        var results = [];
        for (var property in object) _hasOwnProperty.call(object, property) && results.push(property);
        if (IS_DONTENUM_BUGGY)
            for (var i = 0; property = DONT_ENUMS[i]; i++) _hasOwnProperty.call(object, property) && results.push(property);
        return results
    }

    function values(object) {
        var results = [];
        for (var property in object) results.push(object[property]);
        return results
    }

    function clone(object) {
        return extend({}, object)
    }

    function isElement(object) {
        return !(!object || 1 != object.nodeType)
    }

    function isArray(object) {
        return _toString.call(object) === ARRAY_CLASS
    }

    function isHash(object) {
        return object instanceof Hash
    }

    function isFunction(object) {
        return _toString.call(object) === FUNCTION_CLASS
    }

    function isString(object) {
        return _toString.call(object) === STRING_CLASS
    }

    function isNumber(object) {
        return _toString.call(object) === NUMBER_CLASS
    }

    function isDate(object) {
        return _toString.call(object) === DATE_CLASS
    }

    function isUndefined(object) {
        return "undefined" == typeof object
    }
    var _toString = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty,
        NULL_TYPE = "Null",
        UNDEFINED_TYPE = "Undefined",
        BOOLEAN_TYPE = "Boolean",
        NUMBER_TYPE = "Number",
        STRING_TYPE = "String",
        OBJECT_TYPE = "Object",
        FUNCTION_CLASS = "[object Function]",
        BOOLEAN_CLASS = "[object Boolean]",
        NUMBER_CLASS = "[object Number]",
        STRING_CLASS = "[object String]",
        ARRAY_CLASS = "[object Array]",
        DATE_CLASS = "[object Date]",
        NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON && "function" == typeof JSON.stringify && "0" === JSON.stringify(0) && "undefined" == typeof JSON.stringify(Prototype.K),
        DONT_ENUMS = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
        IS_DONTENUM_BUGGY = function() {
            for (var p in {
                    toString: 1
                })
                if ("toString" === p) return !1;
            return !0
        }(),
        hasNativeIsArray = "function" == typeof Array.isArray && Array.isArray([]) && !Array.isArray({});
    hasNativeIsArray && (isArray = Array.isArray), extend(Object, {
        extend: extend,
        inspect: inspect,
        toJSON: NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
        toQueryString: toQueryString,
        toHTML: toHTML,
        keys: Object.keys || keys,
        values: values,
        clone: clone,
        isElement: isElement,
        isArray: isArray,
        isHash: isHash,
        isFunction: isFunction,
        isString: isString,
        isNumber: isNumber,
        isDate: isDate,
        isUndefined: isUndefined
    })
}(), Object.extend(Function.prototype, function() {
        function update(array, args) {
            for (var arrayLength = array.length, length = args.length; length--;) array[arrayLength + length] = args[length];
            return array
        }

        function merge(array, args) {
            return array = slice.call(array, 0), update(array, args)
        }

        function argumentNames() {
            var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, "").replace(/\s+/g, "").split(",");
            return 1 != names.length || names[0] ? names : []
        }

        function bind(context) {
            if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
            if (!Object.isFunction(this)) throw new TypeError("The object is not callable.");
            var nop = function() {},
                __method = this,
                args = slice.call(arguments, 1),
                bound = function() {
                    var a = merge(args, arguments),
                        c = this instanceof bound ? this : context;
                    return __method.apply(c, a)
                };
            return nop.prototype = this.prototype, bound.prototype = new nop, bound
        }

        function bindAsEventListener(context) {
            var __method = this,
                args = slice.call(arguments, 1);
            return function(event) {
                var a = update([event || window.event], args);
                return __method.apply(context, a)
            }
        }

        function curry() {
            if (!arguments.length) return this;
            var __method = this,
                args = slice.call(arguments, 0);
            return function() {
                var a = merge(args, arguments);
                return __method.apply(this, a)
            }
        }

        function delay(timeout) {
            var __method = this,
                args = slice.call(arguments, 1);
            return timeout = 1e3 * timeout, window.setTimeout(function() {
                return __method.apply(__method, args)
            }, timeout)
        }

        function defer() {
            var args = update([.01], arguments);
            return this.delay.apply(this, args)
        }

        function wrap(wrapper) {
            var __method = this;
            return function() {
                var a = update([__method.bind(this)], arguments);
                return wrapper.apply(this, a)
            }
        }

        function methodize() {
            if (this._methodized) return this._methodized;
            var __method = this;
            return this._methodized = function() {
                var a = update([this], arguments);
                return __method.apply(null, a)
            }
        }
        var slice = Array.prototype.slice,
            extensions = {
                argumentNames: argumentNames,
                bindAsEventListener: bindAsEventListener,
                curry: curry,
                delay: delay,
                defer: defer,
                wrap: wrap,
                methodize: methodize
            };
        return Function.prototype.bind || (extensions.bind = bind), extensions
    }()),
    function(proto) {
        function toISOString() {
            return this.getUTCFullYear() + "-" + (this.getUTCMonth() + 1).toPaddedString(2) + "-" + this.getUTCDate().toPaddedString(2) + "T" + this.getUTCHours().toPaddedString(2) + ":" + this.getUTCMinutes().toPaddedString(2) + ":" + this.getUTCSeconds().toPaddedString(2) + "Z"
        }

        function toJSON() {
            return this.toISOString()
        }
        proto.toISOString || (proto.toISOString = toISOString), proto.toJSON || (proto.toJSON = toJSON)
    }(Date.prototype), RegExp.prototype.match = RegExp.prototype.test, RegExp.escape = function(str) {
        return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
    };
var PeriodicalExecuter = Class.create({
    initialize: function(callback, frequency) {
        this.callback = callback, this.frequency = frequency, this.currentlyExecuting = !1, this.registerCallback()
    },
    registerCallback: function() {
        this.timer = setInterval(this.onTimerEvent.bind(this), 1e3 * this.frequency)
    },
    execute: function() {
        this.callback(this)
    },
    stop: function() {
        this.timer && (clearInterval(this.timer), this.timer = null)
    },
    onTimerEvent: function() {
        if (!this.currentlyExecuting) try {
            this.currentlyExecuting = !0, this.execute(), this.currentlyExecuting = !1
        } catch (e) {
            throw this.currentlyExecuting = !1, e
        }
    }
});
Object.extend(String, {
    interpret: function(value) {
        return null == value ? "" : String(value)
    },
    specialChar: {
        "\b": "\\b",
        " ": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        "\\": "\\\\"
    }
}), Object.extend(String.prototype, function() {
    function prepareReplacement(replacement) {
        if (Object.isFunction(replacement)) return replacement;
        var template = new Template(replacement);
        return function(match) {
            return template.evaluate(match)
        }
    }

    function isNonEmptyRegExp(regexp) {
        return regexp.source && "(?:)" !== regexp.source
    }

    function gsub(pattern, replacement) {
        var match, result = "",
            source = this;
        if (replacement = prepareReplacement(replacement), Object.isString(pattern) && (pattern = RegExp.escape(pattern)), !pattern.length && !isNonEmptyRegExp(pattern)) return replacement = replacement(""), replacement + source.split("").join(replacement) + replacement;
        for (; source.length > 0;) match = source.match(pattern), match && match[0].length > 0 ? (result += source.slice(0, match.index), result += String.interpret(replacement(match)), source = source.slice(match.index + match[0].length)) : (result += source, source = "");
        return result
    }

    function sub(pattern, replacement, count) {
        return replacement = prepareReplacement(replacement), count = Object.isUndefined(count) ? 1 : count, this.gsub(pattern, function(match) {
            return --count < 0 ? match[0] : replacement(match)
        })
    }

    function scan(pattern, iterator) {
        return this.gsub(pattern, iterator), String(this)
    }

    function truncate(length, truncation) {
        return length = length || 30, truncation = Object.isUndefined(truncation) ? "..." : truncation, this.length > length ? this.slice(0, length - truncation.length) + truncation : String(this)
    }

    function strip() {
        return this.replace(/^\s+/, "").replace(/\s+$/, "")
    }

    function stripTags() {
        return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, "")
    }

    function stripScripts() {
        return this.replace(new RegExp(Prototype.ScriptFragment, "img"), "")
    }

    function extractScripts() {
        var matchAll = new RegExp(Prototype.ScriptFragment, "img"),
            matchOne = new RegExp(Prototype.ScriptFragment, "im");
        return (this.match(matchAll) || []).map(function(scriptTag) {
            return (scriptTag.match(matchOne) || ["", ""])[1]
        })
    }

    function evalScripts() {
        return this.extractScripts().map(function(script) {
            return eval(script)
        })
    }

    function escapeHTML() {
        return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    }

    function unescapeHTML() {
        return this.stripTags().replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")
    }

    function toQueryParams(separator) {
        var match = this.strip().match(/([^?#]*)(#.*)?$/);
        return match ? match[1].split(separator || "&").inject({}, function(hash, pair) {
            if ((pair = pair.split("="))[0]) {
                var key = decodeURIComponent(pair.shift()),
                    value = pair.length > 1 ? pair.join("=") : pair[0];
                void 0 != value && (value = value.gsub("+", " "), value = decodeURIComponent(value)), key in hash ? (Object.isArray(hash[key]) || (hash[key] = [hash[key]]), hash[key].push(value)) : hash[key] = value
            }
            return hash
        }) : {}
    }

    function toArray() {
        return this.split("")
    }

    function succ() {
        return this.slice(0, this.length - 1) + String.fromCharCode(this.charCodeAt(this.length - 1) + 1)
    }

    function times(count) {
        return 1 > count ? "" : new Array(count + 1).join(this)
    }

    function camelize() {
        return this.replace(/-+(.)?/g, function(match, chr) {
            return chr ? chr.toUpperCase() : ""
        })
    }

    function capitalize() {
        return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase()
    }

    function underscore() {
        return this.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/-/g, "_").toLowerCase()
    }

    function dasherize() {
        return this.replace(/_/g, "-")
    }

    function inspect(useDoubleQuotes) {
        var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
            return character in String.specialChar ? String.specialChar[character] : "\\u00" + character.charCodeAt().toPaddedString(2, 16)
        });
        return useDoubleQuotes ? '"' + escapedString.replace(/"/g, '\\"') + '"' : "'" + escapedString.replace(/'/g, "\\'") + "'"
    }

    function unfilterJSON(filter) {
        return this.replace(filter || Prototype.JSONFilter, "$1")
    }

    function isJSON() {
        var str = this;
        return str.blank() ? !1 : (str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@"), str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]"), str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, ""), /^[\],:{}\s]*$/.test(str))
    }

    function evalJSON(sanitize) {
        var json = this.unfilterJSON(),
            cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        cx.test(json) && (json = json.replace(cx, function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
        }));
        try {
            if (!sanitize || json.isJSON()) return eval("(" + json + ")")
        } catch (e) {}
        throw new SyntaxError("Badly formed JSON string: " + this.inspect())
    }

    function parseJSON() {
        var json = this.unfilterJSON();
        return JSON.parse(json)
    }

    function include(pattern) {
        return this.indexOf(pattern) > -1
    }

    function startsWith(pattern, position) {
        return position = Object.isNumber(position) ? position : 0, this.lastIndexOf(pattern, position) === position
    }

    function endsWith(pattern, position) {
        pattern = String(pattern), position = Object.isNumber(position) ? position : this.length, 0 > position && (position = 0), position > this.length && (position = this.length);
        var d = position - pattern.length;
        return d >= 0 && this.indexOf(pattern, d) === d
    }

    function empty() {
        return "" == this
    }

    function blank() {
        return /^\s*$/.test(this)
    }

    function interpolate(object, pattern) {
        return new Template(this, pattern).evaluate(object)
    }
    var NATIVE_JSON_PARSE_SUPPORT = window.JSON && "function" == typeof JSON.parse && JSON.parse('{"test": true}').test;
    return {
        gsub: gsub,
        sub: sub,
        scan: scan,
        truncate: truncate,
        strip: String.prototype.trim || strip,
        stripTags: stripTags,
        stripScripts: stripScripts,
        extractScripts: extractScripts,
        evalScripts: evalScripts,
        escapeHTML: escapeHTML,
        unescapeHTML: unescapeHTML,
        toQueryParams: toQueryParams,
        parseQuery: toQueryParams,
        toArray: toArray,
        succ: succ,
        times: times,
        camelize: camelize,
        capitalize: capitalize,
        underscore: underscore,
        dasherize: dasherize,
        inspect: inspect,
        unfilterJSON: unfilterJSON,
        isJSON: isJSON,
        evalJSON: NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
        include: include,
        startsWith: String.prototype.startsWith || startsWith,
        endsWith: String.prototype.endsWith || endsWith,
        empty: empty,
        blank: blank,
        interpolate: interpolate
    }
}());
var Template = Class.create({
    initialize: function(template, pattern) {
        this.template = template.toString(), this.pattern = pattern || Template.Pattern
    },
    evaluate: function(object) {
        return object && Object.isFunction(object.toTemplateReplacements) && (object = object.toTemplateReplacements()), this.template.gsub(this.pattern, function(match) {
            if (null == object) return match[1] + "";
            var before = match[1] || "";
            if ("\\" == before) return match[2];
            var ctx = object,
                expr = match[3],
                pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
            if (match = pattern.exec(expr), null == match) return before;
            for (; null != match;) {
                var comp = match[1].startsWith("[") ? match[2].replace(/\\\\]/g, "]") : match[1];
                if (ctx = ctx[comp], null == ctx || "" == match[3]) break;
                expr = expr.substring("[" == match[3] ? match[1].length : match[0].length), match = pattern.exec(expr)
            }
            return before + String.interpret(ctx)
        })
    }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
var $break = {},
    Enumerable = function() {
        function each(iterator, context) {
            try {
                this._each(iterator, context)
            } catch (e) {
                if (e != $break) throw e
            }
            return this
        }

        function eachSlice(number, iterator, context) {
            var index = -number,
                slices = [],
                array = this.toArray();
            if (1 > number) return array;
            for (;
                (index += number) < array.length;) slices.push(array.slice(index, index + number));
            return slices.collect(iterator, context)
        }

        function all(iterator, context) {
            iterator = iterator || Prototype.K;
            var result = !0;
            return this.each(function(value, index) {
                if (result = result && !!iterator.call(context, value, index, this), !result) throw $break
            }, this), result
        }

        function any(iterator, context) {
            iterator = iterator || Prototype.K;
            var result = !1;
            return this.each(function(value, index) {
                if (result = !!iterator.call(context, value, index, this)) throw $break
            }, this), result
        }

        function collect(iterator, context) {
            iterator = iterator || Prototype.K;
            var results = [];
            return this.each(function(value, index) {
                results.push(iterator.call(context, value, index, this))
            }, this), results
        }

        function detect(iterator, context) {
            var result;
            return this.each(function(value, index) {
                if (iterator.call(context, value, index, this)) throw result = value, $break
            }, this), result
        }

        function findAll(iterator, context) {
            var results = [];
            return this.each(function(value, index) {
                iterator.call(context, value, index, this) && results.push(value)
            }, this), results
        }

        function grep(filter, iterator, context) {
            iterator = iterator || Prototype.K;
            var results = [];
            return Object.isString(filter) && (filter = new RegExp(RegExp.escape(filter))), this.each(function(value, index) {
                filter.match(value) && results.push(iterator.call(context, value, index, this))
            }, this), results
        }

        function include(object) {
            if (Object.isFunction(this.indexOf) && -1 != this.indexOf(object)) return !0;
            var found = !1;
            return this.each(function(value) {
                if (value == object) throw found = !0, $break
            }), found
        }

        function inGroupsOf(number, fillWith) {
            return fillWith = Object.isUndefined(fillWith) ? null : fillWith, this.eachSlice(number, function(slice) {
                for (; slice.length < number;) slice.push(fillWith);
                return slice
            })
        }

        function inject(memo, iterator, context) {
            return this.each(function(value, index) {
                memo = iterator.call(context, memo, value, index, this)
            }, this), memo
        }

        function invoke(method) {
            var args = $A(arguments).slice(1);
            return this.map(function(value) {
                return value[method].apply(value, args)
            })
        }

        function max(iterator, context) {
            iterator = iterator || Prototype.K;
            var result;
            return this.each(function(value, index) {
                value = iterator.call(context, value, index, this), (null == result || value >= result) && (result = value)
            }, this), result
        }

        function min(iterator, context) {
            iterator = iterator || Prototype.K;
            var result;
            return this.each(function(value, index) {
                value = iterator.call(context, value, index, this), (null == result || result > value) && (result = value)
            }, this), result
        }

        function partition(iterator, context) {
            iterator = iterator || Prototype.K;
            var trues = [],
                falses = [];
            return this.each(function(value, index) {
                (iterator.call(context, value, index, this) ? trues : falses).push(value)
            }, this), [trues, falses]
        }

        function pluck(property) {
            var results = [];
            return this.each(function(value) {
                results.push(value[property])
            }), results
        }

        function reject(iterator, context) {
            var results = [];
            return this.each(function(value, index) {
                iterator.call(context, value, index, this) || results.push(value)
            }, this), results
        }

        function sortBy(iterator, context) {
            return this.map(function(value, index) {
                return {
                    value: value,
                    criteria: iterator.call(context, value, index, this)
                }
            }, this).sort(function(left, right) {
                var a = left.criteria,
                    b = right.criteria;
                return b > a ? -1 : a > b ? 1 : 0
            }).pluck("value")
        }

        function toArray() {
            return this.map()
        }

        function zip() {
            var iterator = Prototype.K,
                args = $A(arguments);
            Object.isFunction(args.last()) && (iterator = args.pop());
            var collections = [this].concat(args).map($A);
            return this.map(function(value, index) {
                return iterator(collections.pluck(index))
            })
        }

        function size() {
            return this.toArray().length
        }

        function inspect() {
            return "#<Enumerable:" + this.toArray().inspect() + ">"
        }
        return {
            each: each,
            eachSlice: eachSlice,
            all: all,
            every: all,
            any: any,
            some: any,
            collect: collect,
            map: collect,
            detect: detect,
            findAll: findAll,
            select: findAll,
            filter: findAll,
            grep: grep,
            include: include,
            member: include,
            inGroupsOf: inGroupsOf,
            inject: inject,
            invoke: invoke,
            max: max,
            min: min,
            partition: partition,
            pluck: pluck,
            reject: reject,
            sortBy: sortBy,
            toArray: toArray,
            entries: toArray,
            zip: zip,
            size: size,
            inspect: inspect,
            find: detect
        }
    }();
Array.from = $A,
    function() {
        function each(iterator, context) {
            for (var i = 0, length = this.length >>> 0; length > i; i++) i in this && iterator.call(context, this[i], i, this)
        }

        function clear() {
            return this.length = 0, this
        }

        function first() {
            return this[0]
        }

        function last() {
            return this[this.length - 1]
        }

        function compact() {
            return this.select(function(value) {
                return null != value
            })
        }

        function flatten() {
            return this.inject([], function(array, value) {
                return Object.isArray(value) ? array.concat(value.flatten()) : (array.push(value), array)
            })
        }

        function without() {
            var values = slice.call(arguments, 0);
            return this.select(function(value) {
                return !values.include(value)
            })
        }

        function reverse(inline) {
            return (inline === !1 ? this.toArray() : this)._reverse()
        }

        function uniq(sorted) {
            return this.inject([], function(array, value, index) {
                return 0 != index && (sorted ? array.last() == value : array.include(value)) || array.push(value), array
            })
        }

        function intersect(array) {
            return this.uniq().findAll(function(item) {
                return -1 !== array.indexOf(item)
            })
        }

        function clone() {
            return slice.call(this, 0)
        }

        function size() {
            return this.length
        }

        function inspect() {
            return "[" + this.map(Object.inspect).join(", ") + "]"
        }

        function indexOf(item, i) {
            if (null == this) throw new TypeError;
            var array = Object(this),
                length = array.length >>> 0;
            if (0 === length) return -1;
            if (i = Number(i), isNaN(i) ? i = 0 : 0 !== i && isFinite(i) && (i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i))), i > length) return -1;
            for (var k = i >= 0 ? i : Math.max(length - Math.abs(i), 0); length > k; k++)
                if (k in array && array[k] === item) return k;
            return -1
        }

        function lastIndexOf(item, i) {
            if (null == this) throw new TypeError;
            var array = Object(this),
                length = array.length >>> 0;
            if (0 === length) return -1;
            Object.isUndefined(i) ? i = length : (i = Number(i), isNaN(i) ? i = 0 : 0 !== i && isFinite(i) && (i = (i > 0 ? 1 : -1) * Math.floor(Math.abs(i))));
            for (var k = i >= 0 ? Math.min(i, length - 1) : length - Math.abs(i); k >= 0; k--)
                if (k in array && array[k] === item) return k;
            return -1
        }

        function concat() {
            var item, array = [],
                items = slice.call(arguments, 0),
                n = 0;
            items.unshift(this);
            for (var i = 0, length = items.length; length > i; i++)
                if (item = items[i], !Object.isArray(item) || "callee" in item) array[n++] = item;
                else
                    for (var j = 0, arrayLength = item.length; arrayLength > j; j++) j in item && (array[n] = item[j]), n++;
            return array.length = n, array
        }

        function wrapNative(method) {
            return function() {
                if (0 === arguments.length) return method.call(this, Prototype.K);
                if (void 0 === arguments[0]) {
                    var args = slice.call(arguments, 1);
                    return args.unshift(Prototype.K), method.apply(this, args)
                }
                return method.apply(this, arguments)
            }
        }

        function map(iterator) {
            if (null == this) throw new TypeError;
            iterator = iterator || Prototype.K;
            for (var object = Object(this), results = [], context = arguments[1], n = 0, i = 0, length = object.length >>> 0; length > i; i++) i in object && (results[n] = iterator.call(context, object[i], i, object)), n++;
            return results.length = n, results
        }

        function filter(iterator) {
            if (null == this || !Object.isFunction(iterator)) throw new TypeError;
            for (var value, object = Object(this), results = [], context = arguments[1], i = 0, length = object.length >>> 0; length > i; i++) i in object && (value = object[i], iterator.call(context, value, i, object) && results.push(value));
            return results
        }

        function some(iterator) {
            if (null == this) throw new TypeError;
            iterator = iterator || Prototype.K;
            for (var context = arguments[1], object = Object(this), i = 0, length = object.length >>> 0; length > i; i++)
                if (i in object && iterator.call(context, object[i], i, object)) return !0;
            return !1
        }

        function every(iterator) {
            if (null == this) throw new TypeError;
            iterator = iterator || Prototype.K;
            for (var context = arguments[1], object = Object(this), i = 0, length = object.length >>> 0; length > i; i++)
                if (i in object && !iterator.call(context, object[i], i, object)) return !1;
            return !0
        }

        function inject(memo, iterator) {
            iterator = iterator || Prototype.K;
            var context = arguments[2];
            return _reduce.call(this, iterator.bind(context), memo)
        }
        var arrayProto = Array.prototype,
            slice = arrayProto.slice,
            _each = arrayProto.forEach;
        if (_each || (_each = each), arrayProto.map && (map = wrapNative(Array.prototype.map)), arrayProto.filter && (filter = Array.prototype.filter), arrayProto.some) var some = wrapNative(Array.prototype.some);
        if (arrayProto.every) var every = wrapNative(Array.prototype.every);
        var _reduce = arrayProto.reduce;
        if (!arrayProto.reduce) var inject = Enumerable.inject;
        Object.extend(arrayProto, Enumerable), arrayProto._reverse || (arrayProto._reverse = arrayProto.reverse), Object.extend(arrayProto, {
            _each: _each,
            map: map,
            collect: map,
            select: filter,
            filter: filter,
            findAll: filter,
            some: some,
            any: some,
            every: every,
            all: every,
            inject: inject,
            clear: clear,
            first: first,
            last: last,
            compact: compact,
            flatten: flatten,
            without: without,
            reverse: reverse,
            uniq: uniq,
            intersect: intersect,
            clone: clone,
            toArray: clone,
            size: size,
            inspect: inspect
        });
        var CONCAT_ARGUMENTS_BUGGY = function() {
            return 1 !== [].concat(arguments)[0][0]
        }(1, 2);
        CONCAT_ARGUMENTS_BUGGY && (arrayProto.concat = concat), arrayProto.indexOf || (arrayProto.indexOf = indexOf), arrayProto.lastIndexOf || (arrayProto.lastIndexOf = lastIndexOf)
    }();
var Hash = Class.create(Enumerable, function() {
    function initialize(object) {
        this._object = Object.isHash(object) ? object.toObject() : Object.clone(object)
    }

    function _each(iterator, context) {
        var i = 0;
        for (var key in this._object) {
            var value = this._object[key],
                pair = [key, value];
            pair.key = key, pair.value = value, iterator.call(context, pair, i), i++
        }
    }

    function set(key, value) {
        return this._object[key] = value
    }

    function get(key) {
        return this._object[key] !== Object.prototype[key] ? this._object[key] : void 0
    }

    function unset(key) {
        var value = this._object[key];
        return delete this._object[key], value
    }

    function toObject() {
        return Object.clone(this._object)
    }

    function keys() {
        return this.pluck("key")
    }

    function values() {
        return this.pluck("value")
    }

    function index(value) {
        var match = this.detect(function(pair) {
            return pair.value === value
        });
        return match && match.key
    }

    function merge(object) {
        return this.clone().update(object)
    }

    function update(object) {
        return new Hash(object).inject(this, function(result, pair) {
            return result.set(pair.key, pair.value), result
        })
    }

    function toQueryPair(key, value) {
        return Object.isUndefined(value) ? key : (value = String.interpret(value), value = value.gsub(/(\r)?\n/, "\r\n"), value = encodeURIComponent(value), value = value.gsub(/%20/, "+"), key + "=" + value)
    }

    function toQueryString() {
        return this.inject([], function(results, pair) {
            var key = encodeURIComponent(pair.key),
                values = pair.value;
            if (values && "object" == typeof values) {
                if (Object.isArray(values)) {
                    for (var value, queryValues = [], i = 0, len = values.length; len > i; i++) value = values[i], queryValues.push(toQueryPair(key, value));
                    return results.concat(queryValues)
                }
            } else results.push(toQueryPair(key, values));
            return results
        }).join("&")
    }

    function inspect() {
        return "#<Hash:{" + this.map(function(pair) {
            return pair.map(Object.inspect).join(": ")
        }).join(", ") + "}>"
    }

    function clone() {
        return new Hash(this)
    }
    return {
        initialize: initialize,
        _each: _each,
        set: set,
        get: get,
        unset: unset,
        toObject: toObject,
        toTemplateReplacements: toObject,
        keys: keys,
        values: values,
        index: index,
        merge: merge,
        update: update,
        toQueryString: toQueryString,
        inspect: inspect,
        toJSON: toObject,
        clone: clone
    }
}());
Hash.from = $H, Object.extend(Number.prototype, function() {
    function toColorPart() {
        return this.toPaddedString(2, 16)
    }

    function succ() {
        return this + 1
    }

    function times(iterator, context) {
        return $R(0, this, !0).each(iterator, context), this
    }

    function toPaddedString(length, radix) {
        var string = this.toString(radix || 10);
        return "0".times(length - string.length) + string
    }

    function abs() {
        return Math.abs(this)
    }

    function round() {
        return Math.round(this)
    }

    function ceil() {
        return Math.ceil(this)
    }

    function floor() {
        return Math.floor(this)
    }
    return {
        toColorPart: toColorPart,
        succ: succ,
        times: times,
        toPaddedString: toPaddedString,
        abs: abs,
        round: round,
        ceil: ceil,
        floor: floor
    }
}());
var ObjectRange = Class.create(Enumerable, function() {
        function initialize(start, end, exclusive) {
            this.start = start, this.end = end, this.exclusive = exclusive
        }

        function _each(iterator, context) {
            var i, value = this.start;
            for (i = 0; this.include(value); i++) iterator.call(context, value, i), value = value.succ()
        }

        function include(value) {
            return value < this.start ? !1 : this.exclusive ? value < this.end : value <= this.end
        }
        return {
            initialize: initialize,
            _each: _each,
            include: include
        }
    }()),
    Abstract = {},
    Try = {
        these: function() {
            for (var returnValue, i = 0, length = arguments.length; length > i; i++) {
                var lambda = arguments[i];
                try {
                    returnValue = lambda();
                    break
                } catch (e) {}
            }
            return returnValue
        }
    },
    Ajax = {
        getTransport: function() {
            return Try.these(function() {
                return new XMLHttpRequest
            }, function() {
                return new ActiveXObject("Msxml2.XMLHTTP")
            }, function() {
                return new ActiveXObject("Microsoft.XMLHTTP")
            }) || !1
        },
        activeRequestCount: 0
    };
Ajax.Responders = {
        responders: [],
        _each: function(iterator, context) {
            this.responders._each(iterator, context)
        },
        register: function(responder) {
            this.include(responder) || this.responders.push(responder)
        },
        unregister: function(responder) {
            this.responders = this.responders.without(responder)
        },
        dispatch: function(callback, request, transport, json) {
            this.each(function(responder) {
                if (Object.isFunction(responder[callback])) try {
                    responder[callback].apply(responder, [request, transport, json])
                } catch (e) {}
            })
        }
    }, Object.extend(Ajax.Responders, Enumerable), Ajax.Responders.register({
        onCreate: function() {
            Ajax.activeRequestCount++
        },
        onComplete: function() {
            Ajax.activeRequestCount--
        }
    }), Ajax.Base = Class.create({
        initialize: function(options) {
            this.options = {
                method: "post",
                asynchronous: !0,
                contentType: "application/x-www-form-urlencoded",
                encoding: "UTF-8",
                parameters: "",
                evalJSON: !0,
                evalJS: !0
            }, Object.extend(this.options, options || {}), this.options.method = this.options.method.toLowerCase(), Object.isHash(this.options.parameters) && (this.options.parameters = this.options.parameters.toObject())
        }
    }), Ajax.Request = Class.create(Ajax.Base, {
        _complete: !1,
        initialize: function($super, url, options) {
            $super(options), this.transport = Ajax.getTransport(), this.request(url)
        },
        request: function(url) {
            this.url = url, this.method = this.options.method;
            var params = Object.isString(this.options.parameters) ? this.options.parameters : Object.toQueryString(this.options.parameters);
            ["get", "post"].include(this.method) || (params += (params ? "&" : "") + "_method=" + this.method, this.method = "post"), params && "get" === this.method && (this.url += (this.url.include("?") ? "&" : "?") + params), this.parameters = params.toQueryParams();
            try {
                var response = new Ajax.Response(this);
                this.options.onCreate && this.options.onCreate(response), Ajax.Responders.dispatch("onCreate", this, response), this.transport.open(this.method.toUpperCase(), this.url, this.options.asynchronous), this.options.asynchronous && this.respondToReadyState.bind(this).defer(1), this.transport.onreadystatechange = this.onStateChange.bind(this), this.setRequestHeaders(), this.body = "post" == this.method ? this.options.postBody || params : null, this.transport.send(this.body), !this.options.asynchronous && this.transport.overrideMimeType && this.onStateChange()
            } catch (e) {
                this.dispatchException(e)
            }
        },
        onStateChange: function() {
            var readyState = this.transport.readyState;
            readyState > 1 && (4 != readyState || !this._complete) && this.respondToReadyState(this.transport.readyState)
        },
        setRequestHeaders: function() {
            var headers = {
                "X-Requested-With": "XMLHttpRequest",
                "X-Prototype-Version": Prototype.Version,
                Accept: "text/javascript, text/html, application/xml, text/xml, */*"
            };
            if ("post" == this.method && (headers["Content-type"] = this.options.contentType + (this.options.encoding ? "; charset=" + this.options.encoding : ""), this.transport.overrideMimeType && (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0, 2005])[1] < 2005 && (headers.Connection = "close")), "object" == typeof this.options.requestHeaders) {
                var extras = this.options.requestHeaders;
                if (Object.isFunction(extras.push))
                    for (var i = 0, length = extras.length; length > i; i += 2) headers[extras[i]] = extras[i + 1];
                else $H(extras).each(function(pair) {
                    headers[pair.key] = pair.value
                })
            }
            for (var name in headers) null != headers[name] && this.transport.setRequestHeader(name, headers[name])
        },
        success: function() {
            var status = this.getStatus();
            return !status || status >= 200 && 300 > status || 304 == status
        },
        getStatus: function() {
            try {
                return 1223 === this.transport.status ? 204 : this.transport.status || 0
            } catch (e) {
                return 0
            }
        },
        respondToReadyState: function(readyState) {
            var state = Ajax.Request.Events[readyState],
                response = new Ajax.Response(this);
            if ("Complete" == state) {
                try {
                    this._complete = !0, (this.options["on" + response.status] || this.options["on" + (this.success() ? "Success" : "Failure")] || Prototype.emptyFunction)(response, response.headerJSON)
                } catch (e) {
                    this.dispatchException(e)
                }
                var contentType = response.getHeader("Content-type");
                ("force" == this.options.evalJS || this.options.evalJS && this.isSameOrigin() && contentType && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)) && this.evalResponse()
            }
            try {
                (this.options["on" + state] || Prototype.emptyFunction)(response, response.headerJSON), Ajax.Responders.dispatch("on" + state, this, response, response.headerJSON)
            } catch (e) {
                this.dispatchException(e)
            }
            "Complete" == state && (this.transport.onreadystatechange = Prototype.emptyFunction)
        },
        isSameOrigin: function() {
            var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
            return !m || m[0] == "#{protocol}//#{domain}#{port}".interpolate({
                protocol: location.protocol,
                domain: document.domain,
                port: location.port ? ":" + location.port : ""
            })
        },
        getHeader: function(name) {
            try {
                return this.transport.getResponseHeader(name) || null
            } catch (e) {
                return null
            }
        },
        evalResponse: function() {
            try {
                return eval((this.transport.responseText || "").unfilterJSON())
            } catch (e) {
                this.dispatchException(e)
            }
        },
        dispatchException: function(exception) {
            (this.options.onException || Prototype.emptyFunction)(this, exception), Ajax.Responders.dispatch("onException", this, exception)
        }
    }), Ajax.Request.Events = ["Uninitialized", "Loading", "Loaded", "Interactive", "Complete"], Ajax.Response = Class.create({
        initialize: function(request) {
            this.request = request;
            var transport = this.transport = request.transport,
                readyState = this.readyState = transport.readyState;
            if ((readyState > 2 && !Prototype.Browser.IE || 4 == readyState) && (this.status = this.getStatus(), this.statusText = this.getStatusText(), this.responseText = String.interpret(transport.responseText), this.headerJSON = this._getHeaderJSON()), 4 == readyState) {
                var xml = transport.responseXML;
                this.responseXML = Object.isUndefined(xml) ? null : xml, this.responseJSON = this._getResponseJSON()
            }
        },
        status: 0,
        statusText: "",
        getStatus: Ajax.Request.prototype.getStatus,
        getStatusText: function() {
            try {
                return this.transport.statusText || ""
            } catch (e) {
                return ""
            }
        },
        getHeader: Ajax.Request.prototype.getHeader,
        getAllHeaders: function() {
            try {
                return this.getAllResponseHeaders()
            } catch (e) {
                return null
            }
        },
        getResponseHeader: function(name) {
            return this.transport.getResponseHeader(name)
        },
        getAllResponseHeaders: function() {
            return this.transport.getAllResponseHeaders()
        },
        _getHeaderJSON: function() {
            var json = this.getHeader("X-JSON");
            if (!json) return null;
            try {
                json = decodeURIComponent(escape(json))
            } catch (e) {}
            try {
                return json.evalJSON(this.request.options.sanitizeJSON || !this.request.isSameOrigin())
            } catch (e) {
                this.request.dispatchException(e)
            }
        },
        _getResponseJSON: function() {
            var options = this.request.options;
            if (!options.evalJSON || "force" != options.evalJSON && !(this.getHeader("Content-type") || "").include("application/json") || this.responseText.blank()) return null;
            try {
                return this.responseText.evalJSON(options.sanitizeJSON || !this.request.isSameOrigin())
            } catch (e) {
                this.request.dispatchException(e)
            }
        }
    }), Ajax.Updater = Class.create(Ajax.Request, {
        initialize: function($super, container, url, options) {
            this.container = {
                success: container.success || container,
                failure: container.failure || (container.success ? null : container)
            }, options = Object.clone(options);
            var onComplete = options.onComplete;
            options.onComplete = function(response, json) {
                this.updateContent(response.responseText), Object.isFunction(onComplete) && onComplete(response, json)
            }.bind(this), $super(url, options)
        },
        updateContent: function(responseText) {
            var receiver = this.container[this.success() ? "success" : "failure"],
                options = this.options;
            if (options.evalScripts || (responseText = responseText.stripScripts()), receiver = $(receiver))
                if (options.insertion)
                    if (Object.isString(options.insertion)) {
                        var insertion = {};
                        insertion[options.insertion] = responseText, receiver.insert(insertion)
                    } else options.insertion(receiver, responseText);
            else receiver.update(responseText)
        }
    }), Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
        initialize: function($super, container, url, options) {
            $super(options), this.onComplete = this.options.onComplete, this.frequency = this.options.frequency || 2, this.decay = this.options.decay || 1, this.updater = {}, this.container = container, this.url = url, this.start()
        },
        start: function() {
            this.options.onComplete = this.updateComplete.bind(this), this.onTimerEvent()
        },
        stop: function() {
            this.updater.options.onComplete = void 0, clearTimeout(this.timer), (this.onComplete || Prototype.emptyFunction).apply(this, arguments)
        },
        updateComplete: function(response) {
            this.options.decay && (this.decay = response.responseText == this.lastText ? this.decay * this.options.decay : 1, this.lastText = response.responseText), this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency)
        },
        onTimerEvent: function() {
            this.updater = new Ajax.Updater(this.container, this.url, this.options)
        }
    }),
    function(GLOBAL) {
        function $(element) {
            if (arguments.length > 1) {
                for (var i = 0, elements = [], length = arguments.length; length > i; i++) elements.push($(arguments[i]));
                return elements
            }
            return Object.isString(element) && (element = document.getElementById(element)), Element.extend(element)
        }

        function shouldUseCreationCache(tagName, attributes) {
            return "select" === tagName ? !1 : "type" in attributes ? !1 : !0
        }

        function Element(tagName, attributes) {
            if (attributes = attributes || {}, tagName = tagName.toLowerCase(), HAS_EXTENDED_CREATE_ELEMENT_SYNTAX && attributes.name) return tagName = "<" + tagName + ' name="' + attributes.name + '">', delete attributes.name, Element.writeAttribute(document.createElement(tagName), attributes);
            ELEMENT_CACHE[tagName] || (ELEMENT_CACHE[tagName] = Element.extend(document.createElement(tagName)));
            var node = shouldUseCreationCache(tagName, attributes) ? ELEMENT_CACHE[tagName].cloneNode(!1) : document.createElement(tagName);
            return Element.writeAttribute(node, attributes)
        }

        function inspect(element) {
            element = $(element);
            var attribute, value, result = "<" + element.tagName.toLowerCase();
            for (var property in INSPECT_ATTRIBUTES) attribute = INSPECT_ATTRIBUTES[property], value = (element[property] || "").toString(), value && (result += " " + attribute + "=" + value.inspect(!0));
            return result + ">"
        }

        function visible(element) {
            return "none" !== $(element).style.display
        }

        function toggle(element, bool) {
            return element = $(element), Object.isUndefined(bool) && (bool = !Element.visible(element)), Element[bool ? "show" : "hide"](element), element
        }

        function hide(element) {
            return element = $(element), element.style.display = "none", element
        }

        function show(element) {
            return element = $(element), element.style.display = "", element
        }

        function remove(element) {
            return element = $(element), element.parentNode.removeChild(element), element
        }

        function update(element, content) {
            element = $(element);
            for (var descendants = element.getElementsByTagName("*"), i = descendants.length; i--;) purgeElement(descendants[i]);
            if (content && content.toElement && (content = content.toElement()), Object.isElement(content)) return element.update().insert(content);
            content = Object.toHTML(content);
            var tagName = element.tagName.toUpperCase();
            if ("SCRIPT" === tagName && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) return element.text = content, element;
            if (ANY_INNERHTML_BUGGY)
                if (tagName in INSERTION_TRANSLATIONS.tags) {
                    for (; element.firstChild;) element.removeChild(element.firstChild);
                    for (var node, nodes = getContentFromAnonymousElement(tagName, content.stripScripts()), i = 0; node = nodes[i]; i++) element.appendChild(node)
                } else if (LINK_ELEMENT_INNERHTML_BUGGY && Object.isString(content) && content.indexOf("<link") > -1) {
                for (; element.firstChild;) element.removeChild(element.firstChild);
                for (var node, nodes = getContentFromAnonymousElement(tagName, content.stripScripts(), !0), i = 0; node = nodes[i]; i++) element.appendChild(node)
            } else element.innerHTML = content.stripScripts();
            else element.innerHTML = content.stripScripts();
            return content.evalScripts.bind(content).defer(), element
        }

        function replace(element, content) {
            if (element = $(element), content && content.toElement) content = content.toElement();
            else if (!Object.isElement(content)) {
                content = Object.toHTML(content);
                var range = element.ownerDocument.createRange();
                range.selectNode(element), content.evalScripts.bind(content).defer(), content = range.createContextualFragment(content.stripScripts())
            }
            return element.parentNode.replaceChild(content, element), element
        }

        function replace_IE(element, content) {
            if (element = $(element), content && content.toElement && (content = content.toElement()), Object.isElement(content)) return element.parentNode.replaceChild(content, element), element;
            content = Object.toHTML(content);
            var parent = element.parentNode,
                tagName = parent.tagName.toUpperCase();
            if (tagName in INSERTION_TRANSLATIONS.tags) {
                var nextSibling = Element.next(element),
                    fragments = getContentFromAnonymousElement(tagName, content.stripScripts());
                parent.removeChild(element);
                var iterator;
                iterator = nextSibling ? function(node) {
                    parent.insertBefore(node, nextSibling)
                } : function(node) {
                    parent.appendChild(node)
                }, fragments.each(iterator)
            } else element.outerHTML = content.stripScripts();
            return content.evalScripts.bind(content).defer(), element
        }

        function isContent(content) {
            return Object.isUndefined(content) || null === content ? !1 : Object.isString(content) || Object.isNumber(content) ? !0 : Object.isElement(content) ? !0 : content.toElement || content.toHTML ? !0 : !1
        }

        function insertContentAt(element, content, position) {
            position = position.toLowerCase();
            var method = INSERTION_TRANSLATIONS[position];
            if (content && content.toElement && (content = content.toElement()), Object.isElement(content)) return method(element, content), element;
            content = Object.toHTML(content);
            var tagName = ("before" === position || "after" === position ? element.parentNode : element).tagName.toUpperCase(),
                childNodes = getContentFromAnonymousElement(tagName, content.stripScripts());
            ("top" === position || "after" === position) && childNodes.reverse();
            for (var node, i = 0; node = childNodes[i]; i++) method(element, node);
            content.evalScripts.bind(content).defer()
        }

        function insert(element, insertions) {
            element = $(element), isContent(insertions) && (insertions = {
                bottom: insertions
            });
            for (var position in insertions) insertContentAt(element, insertions[position], position);
            return element
        }

        function wrap(element, wrapper, attributes) {
            return element = $(element), Object.isElement(wrapper) ? $(wrapper).writeAttribute(attributes || {}) : wrapper = Object.isString(wrapper) ? new Element(wrapper, attributes) : new Element("div", wrapper), element.parentNode && element.parentNode.replaceChild(wrapper, element), wrapper.appendChild(element), wrapper
        }

        function cleanWhitespace(element) {
            element = $(element);
            for (var node = element.firstChild; node;) {
                var nextNode = node.nextSibling;
                node.nodeType !== Node.TEXT_NODE || /\S/.test(node.nodeValue) || element.removeChild(node), node = nextNode
            }
            return element
        }

        function empty(element) {
            return $(element).innerHTML.blank()
        }

        function getContentFromAnonymousElement(tagName, html, force) {
            var t = INSERTION_TRANSLATIONS.tags[tagName],
                div = DIV,
                workaround = !!t;
            if (!workaround && force && (workaround = !0, t = ["", "", 0]), workaround) {
                div.innerHTML = "&#160;" + t[0] + html + t[1], div.removeChild(div.firstChild);
                for (var i = t[2]; i--;) div = div.firstChild
            } else div.innerHTML = html;
            return $A(div.childNodes)
        }

        function clone(element, deep) {
            if (element = $(element)) {
                var clone = element.cloneNode(deep);
                if (!HAS_UNIQUE_ID_PROPERTY && (clone._prototypeUID = UNDEFINED, deep))
                    for (var descendants = Element.select(clone, "*"), i = descendants.length; i--;) descendants[i]._prototypeUID = UNDEFINED;
                return Element.extend(clone)
            }
        }

        function purgeElement(element) {
            var uid = getUniqueElementID(element);
            uid && (Element.stopObserving(element), HAS_UNIQUE_ID_PROPERTY || (element._prototypeUID = UNDEFINED), delete Element.Storage[uid])
        }

        function purgeCollection(elements) {
            for (var i = elements.length; i--;) purgeElement(elements[i])
        }

        function purgeCollection_IE(elements) {
            for (var element, uid, i = elements.length; i--;) element = elements[i], uid = getUniqueElementID(element), delete Element.Storage[uid], delete Event.cache[uid]
        }

        function purge(element) {
            if (element = $(element)) {
                purgeElement(element);
                for (var descendants = element.getElementsByTagName("*"), i = descendants.length; i--;) purgeElement(descendants[i]);
                return null
            }
        }

        function recursivelyCollect(element, property, maximumLength) {
            element = $(element), maximumLength = maximumLength || -1;
            for (var elements = [];
                (element = element[property]) && (element.nodeType === Node.ELEMENT_NODE && elements.push(Element.extend(element)), elements.length !== maximumLength););
            return elements
        }

        function ancestors(element) {
            return recursivelyCollect(element, "parentNode")
        }

        function descendants(element) {
            return Element.select(element, "*")
        }

        function firstDescendant(element) {
            for (element = $(element).firstChild; element && element.nodeType !== Node.ELEMENT_NODE;) element = element.nextSibling;
            return $(element)
        }

        function immediateDescendants(element) {
            for (var results = [], child = $(element).firstChild; child;) child.nodeType === Node.ELEMENT_NODE && results.push(Element.extend(child)), child = child.nextSibling;
            return results
        }

        function previousSiblings(element) {
            return recursivelyCollect(element, "previousSibling")
        }

        function nextSiblings(element) {
            return recursivelyCollect(element, "nextSibling")
        }

        function siblings(element) {
            element = $(element);
            var previous = previousSiblings(element),
                next = nextSiblings(element);
            return previous.reverse().concat(next)
        }

        function match(element, selector) {
            return element = $(element), Object.isString(selector) ? Prototype.Selector.match(element, selector) : selector.match(element)
        }

        function _recursivelyFind(element, property, expression, index) {
            for (element = $(element), expression = expression || 0, index = index || 0, Object.isNumber(expression) && (index = expression, expression = null); element = element[property];)
                if (1 === element.nodeType && !(expression && !Prototype.Selector.match(element, expression) || --index >= 0)) return Element.extend(element)
        }

        function up(element, expression, index) {
            return element = $(element), 1 === arguments.length ? $(element.parentNode) : _recursivelyFind(element, "parentNode", expression, index)
        }

        function down(element, expression, index) {
            if (1 === arguments.length) return firstDescendant(element);
            element = $(element), expression = expression || 0, index = index || 0, Object.isNumber(expression) && (index = expression, expression = "*");
            var node = Prototype.Selector.select(expression, element)[index];
            return Element.extend(node)
        }

        function previous(element, expression, index) {
            return _recursivelyFind(element, "previousSibling", expression, index)
        }

        function next(element, expression, index) {
            return _recursivelyFind(element, "nextSibling", expression, index)
        }

        function select(element) {
            element = $(element);
            var expressions = SLICE.call(arguments, 1).join(", ");
            return Prototype.Selector.select(expressions, element)
        }

        function adjacent(element) {
            element = $(element);
            for (var sibling, expressions = SLICE.call(arguments, 1).join(", "), siblings = Element.siblings(element), results = [], i = 0; sibling = siblings[i]; i++) Prototype.Selector.match(sibling, expressions) && results.push(sibling);
            return results
        }

        function descendantOf_DOM(element, ancestor) {
            for (element = $(element), ancestor = $(ancestor); element = element.parentNode;)
                if (element === ancestor) return !0;
            return !1
        }

        function descendantOf_contains(element, ancestor) {
            return element = $(element), ancestor = $(ancestor), ancestor.contains ? ancestor.contains(element) && ancestor !== element : descendantOf_DOM(element, ancestor)
        }

        function descendantOf_compareDocumentPosition(element, ancestor) {
            return element = $(element), ancestor = $(ancestor), 8 === (8 & element.compareDocumentPosition(ancestor))
        }

        function identify(element) {
            element = $(element);
            var id = Element.readAttribute(element, "id");
            if (id) return id;
            do id = "anonymous_element_" + idCounter++; while ($(id));
            return Element.writeAttribute(element, "id", id), id
        }

        function readAttribute(element, name) {
            return $(element).getAttribute(name)
        }

        function readAttribute_IE(element, name) {
            element = $(element);
            var table = ATTRIBUTE_TRANSLATIONS.read;
            return table.values[name] ? table.values[name](element, name) : (table.names[name] && (name = table.names[name]), name.include(":") ? element.attributes && element.attributes[name] ? element.attributes[name].value : null : element.getAttribute(name))
        }

        function readAttribute_Opera(element, name) {
            return "title" === name ? element.title : element.getAttribute(name)
        }

        function writeAttribute(element, name, value) {
            element = $(element);
            var attributes = {},
                table = ATTRIBUTE_TRANSLATIONS.write;
            "object" == typeof name ? attributes = name : attributes[name] = Object.isUndefined(value) ? !0 : value;
            for (var attr in attributes) name = table.names[attr] || attr, value = attributes[attr], table.values[attr] && (name = table.values[attr](element, value) || name), value === !1 || null === value ? element.removeAttribute(name) : value === !0 ? element.setAttribute(name, name) : element.setAttribute(name, value);
            return element
        }

        function hasAttribute(element, attribute) {
            attribute = ATTRIBUTE_TRANSLATIONS.has[attribute] || attribute;
            var node = $(element).getAttributeNode(attribute);
            return !(!node || !node.specified)
        }

        function hasAttribute_IE(element, attribute) {
            return "checked" === attribute ? element.checked : hasAttribute(element, attribute)
        }

        function classNames(element) {
            return new Element.ClassNames(element)
        }

        function getRegExpForClassName(className) {
            if (regExpCache[className]) return regExpCache[className];
            var re = new RegExp("(^|\\s+)" + className + "(\\s+|$)");
            return regExpCache[className] = re, re
        }

        function hasClassName(element, className) {
            if (element = $(element)) {
                var elementClassName = element.className;
                return 0 === elementClassName.length ? !1 : elementClassName === className ? !0 : getRegExpForClassName(className).test(elementClassName)
            }
        }

        function addClassName(element, className) {
            return (element = $(element)) ? (hasClassName(element, className) || (element.className += (element.className ? " " : "") + className), element) : void 0
        }

        function removeClassName(element, className) {
            return (element = $(element)) ? (element.className = element.className.replace(getRegExpForClassName(className), " ").strip(), element) : void 0
        }

        function toggleClassName(element, className, bool) {
            if (element = $(element)) {
                Object.isUndefined(bool) && (bool = !hasClassName(element, className));
                var method = Element[bool ? "addClassName" : "removeClassName"];
                return method(element, className)
            }
        }

        function _getAttr(element, attribute) {
            return element.getAttribute(attribute)
        }

        function _getAttr2(element, attribute) {
            return element.getAttribute(attribute, 2)
        }

        function _getAttrNode(element, attribute) {
            var node = element.getAttributeNode(attribute);
            return node ? node.value : ""
        }

        function _getFlag(element, attribute) {
            return $(element).hasAttribute(attribute) ? attribute : null
        }

        function normalizeStyleName(style) {
            return "float" === style || "styleFloat" === style ? "cssFloat" : style.camelize()
        }

        function normalizeStyleName_IE(style) {
            return "float" === style || "cssFloat" === style ? "styleFloat" : style.camelize()
        }

        function setStyle(element, styles) {
            element = $(element);
            var elementStyle = element.style;
            if (Object.isString(styles)) {
                if (elementStyle.cssText += ";" + styles, styles.include("opacity")) {
                    var opacity = styles.match(/opacity:\s*(\d?\.?\d*)/)[1];
                    Element.setOpacity(element, opacity)
                }
                return element
            }
            for (var property in styles)
                if ("opacity" === property) Element.setOpacity(element, styles[property]);
                else {
                    var value = styles[property];
                    ("float" === property || "cssFloat" === property) && (property = Object.isUndefined(elementStyle.styleFloat) ? "cssFloat" : "styleFloat"), elementStyle[property] = value
                }
            return element
        }

        function getStyle(element, style) {
            element = $(element), style = normalizeStyleName(style);
            var value = element.style[style];
            if (!value || "auto" === value) {
                var css = document.defaultView.getComputedStyle(element, null);
                value = css ? css[style] : null
            }
            return "opacity" === style ? value ? parseFloat(value) : 1 : "auto" === value ? null : value
        }

        function getStyle_IE(element, style) {
            element = $(element), style = normalizeStyleName_IE(style);
            var value = element.style[style];
            return !value && element.currentStyle && (value = element.currentStyle[style]), "opacity" !== style || STANDARD_CSS_OPACITY_SUPPORTED ? "auto" === value ? "width" !== style && "height" !== style || !Element.visible(element) ? null : Element.measure(element, style) + "px" : value : getOpacity_IE(element)
        }

        function stripAlphaFromFilter_IE(filter) {
            return (filter || "").replace(/alpha\([^\)]*\)/gi, "")
        }

        function hasLayout_IE(element) {
            return element.currentStyle && element.currentStyle.hasLayout || (element.style.zoom = 1), element
        }

        function setOpacity(element, value) {
            return element = $(element), 1 == value || "" === value ? value = "" : 1e-5 > value && (value = 0), element.style.opacity = value, element
        }

        function setOpacity_IE(element, value) {
            if (STANDARD_CSS_OPACITY_SUPPORTED) return setOpacity(element, value);
            element = hasLayout_IE($(element));
            var filter = Element.getStyle(element, "filter"),
                style = element.style;
            return 1 == value || "" === value ? (filter = stripAlphaFromFilter_IE(filter), filter ? style.filter = filter : style.removeAttribute("filter"), element) : (1e-5 > value && (value = 0), style.filter = stripAlphaFromFilter_IE(filter) + "alpha(opacity=" + 100 * value + ")", element)
        }

        function getOpacity(element) {
            return Element.getStyle(element, "opacity")
        }

        function getOpacity_IE(element) {
            if (STANDARD_CSS_OPACITY_SUPPORTED) return getOpacity(element);
            var filter = Element.getStyle(element, "filter");
            if (0 === filter.length) return 1;
            var match = (filter || "").match(/alpha\(opacity=(.*)\)/);
            return match && match[1] ? parseFloat(match[1]) / 100 : 1
        }

        function getUniqueElementID(element) {
            return element === window ? 0 : ("undefined" == typeof element._prototypeUID && (element._prototypeUID = Element.Storage.UID++), element._prototypeUID)
        }

        function getUniqueElementID_IE(element) {
            return element === window ? 0 : element == document ? 1 : element.uniqueID
        }

        function getStorage(element) {
            if (element = $(element)) {
                var uid = getUniqueElementID(element);
                return Element.Storage[uid] || (Element.Storage[uid] = $H()), Element.Storage[uid]
            }
        }

        function store(element, key, value) {
            if (element = $(element)) {
                var storage = getStorage(element);
                return 2 === arguments.length ? storage.update(key) : storage.set(key, value), element
            }
        }

        function retrieve(element, key, defaultValue) {
            if (element = $(element)) {
                var storage = getStorage(element),
                    value = storage.get(key);
                return Object.isUndefined(value) && (storage.set(key, defaultValue), value = defaultValue), value
            }
        }

        function checkElementPrototypeDeficiency(tagName) {
            if ("undefined" == typeof window.Element) return !1;
            if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) return !1;
            var proto = window.Element.prototype;
            if (proto) {
                var id = "_" + (Math.random() + "").slice(2),
                    el = document.createElement(tagName);
                proto[id] = "x";
                var isBuggy = "x" !== el[id];
                return delete proto[id], el = null, isBuggy
            }
            return !1
        }

        function extendElementWith(element, methods) {
            for (var property in methods) {
                var value = methods[property];
                !Object.isFunction(value) || property in element || (element[property] = value.methodize())
            }
        }

        function elementIsExtended(element) {
            var uid = getUniqueElementID(element);
            return uid in EXTENDED
        }

        function extend(element) {
            if (!element || elementIsExtended(element)) return element;
            if (element.nodeType !== Node.ELEMENT_NODE || element == window) return element;
            var methods = Object.clone(Methods),
                tagName = element.tagName.toUpperCase();
            return ByTag[tagName] && Object.extend(methods, ByTag[tagName]), extendElementWith(element, methods), EXTENDED[getUniqueElementID(element)] = !0, element
        }

        function extend_IE8(element) {
            if (!element || elementIsExtended(element)) return element;
            var t = element.tagName;
            return t && /^(?:object|applet|embed)$/i.test(t) && (extendElementWith(element, Element.Methods), extendElementWith(element, Element.Methods.Simulated), extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()])), element
        }

        function addMethodsToTagName(tagName, methods) {
            tagName = tagName.toUpperCase(), ByTag[tagName] || (ByTag[tagName] = {}), Object.extend(ByTag[tagName], methods)
        }

        function mergeMethods(destination, methods, onlyIfAbsent) {
            Object.isUndefined(onlyIfAbsent) && (onlyIfAbsent = !1);
            for (var property in methods) {
                var value = methods[property];
                Object.isFunction(value) && (onlyIfAbsent && property in destination || (destination[property] = value.methodize()))
            }
        }

        function findDOMClass(tagName) {
            var klass, trans = {
                OPTGROUP: "OptGroup",
                TEXTAREA: "TextArea",
                P: "Paragraph",
                FIELDSET: "FieldSet",
                UL: "UList",
                OL: "OList",
                DL: "DList",
                DIR: "Directory",
                H1: "Heading",
                H2: "Heading",
                H3: "Heading",
                H4: "Heading",
                H5: "Heading",
                H6: "Heading",
                Q: "Quote",
                INS: "Mod",
                DEL: "Mod",
                A: "Anchor",
                IMG: "Image",
                CAPTION: "TableCaption",
                COL: "TableCol",
                COLGROUP: "TableCol",
                THEAD: "TableSection",
                TFOOT: "TableSection",
                TBODY: "TableSection",
                TR: "TableRow",
                TH: "TableCell",
                TD: "TableCell",
                FRAMESET: "FrameSet",
                IFRAME: "IFrame"
            };
            if (trans[tagName] && (klass = "HTML" + trans[tagName] + "Element"), window[klass]) return window[klass];
            if (klass = "HTML" + tagName + "Element", window[klass]) return window[klass];
            if (klass = "HTML" + tagName.capitalize() + "Element", window[klass]) return window[klass];
            var element = document.createElement(tagName),
                proto = element.__proto__ || element.constructor.prototype;
            return element = null, proto
        }

        function addMethods(methods) {
            if (0 === arguments.length && addFormMethods(), 2 === arguments.length) {
                var tagName = methods;
                methods = arguments[1]
            }
            if (tagName)
                if (Object.isArray(tagName))
                    for (var tag, i = 0; tag = tagName[i]; i++) addMethodsToTagName(tag, methods);
                else addMethodsToTagName(tagName, methods);
            else Object.extend(Element.Methods, methods || {});
            var ELEMENT_PROTOTYPE = window.HTMLElement ? HTMLElement.prototype : Element.prototype;
            if (F.ElementExtensions && (mergeMethods(ELEMENT_PROTOTYPE, Element.Methods), mergeMethods(ELEMENT_PROTOTYPE, Element.Methods.Simulated, !0)), F.SpecificElementExtensions)
                for (var tag in Element.Methods.ByTag) {
                    var klass = findDOMClass(tag);
                    Object.isUndefined(klass) || mergeMethods(klass.prototype, ByTag[tag])
                }
            Object.extend(Element, Element.Methods), Object.extend(Element, Element.Methods.Simulated), delete Element.ByTag, delete Element.Simulated, Element.extend.refresh(), ELEMENT_CACHE = {}
        }

        function addFormMethods() {
            Object.extend(Form, Form.Methods), Object.extend(Form.Element, Form.Element.Methods), Object.extend(Element.Methods.ByTag, {
                FORM: Object.clone(Form.Methods),
                INPUT: Object.clone(Form.Element.Methods),
                SELECT: Object.clone(Form.Element.Methods),
                TEXTAREA: Object.clone(Form.Element.Methods),
                BUTTON: Object.clone(Form.Element.Methods)
            })
        }

        function destroyCache_IE() {
            DIV = null, ELEMENT_CACHE = null
        }
        var UNDEFINED, SLICE = Array.prototype.slice,
            DIV = document.createElement("div");
        GLOBAL.$ = $, GLOBAL.Node || (GLOBAL.Node = {}), GLOBAL.Node.ELEMENT_NODE || Object.extend(GLOBAL.Node, {
            ELEMENT_NODE: 1,
            ATTRIBUTE_NODE: 2,
            TEXT_NODE: 3,
            CDATA_SECTION_NODE: 4,
            ENTITY_REFERENCE_NODE: 5,
            ENTITY_NODE: 6,
            PROCESSING_INSTRUCTION_NODE: 7,
            COMMENT_NODE: 8,
            DOCUMENT_NODE: 9,
            DOCUMENT_TYPE_NODE: 10,
            DOCUMENT_FRAGMENT_NODE: 11,
            NOTATION_NODE: 12
        });
        var ELEMENT_CACHE = {},
            HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = function() {
                try {
                    var el = document.createElement('<input name="x">');
                    return "input" === el.tagName.toLowerCase() && "x" === el.name
                } catch (err) {
                    return !1
                }
            }(),
            oldElement = GLOBAL.Element;
        GLOBAL.Element = Element, Object.extend(GLOBAL.Element, oldElement || {}), oldElement && (GLOBAL.Element.prototype = oldElement.prototype), Element.Methods = {
            ByTag: {},
            Simulated: {}
        };
        var methods = {},
            INSPECT_ATTRIBUTES = {
                id: "id",
                className: "class"
            };
        methods.inspect = inspect, Object.extend(methods, {
            visible: visible,
            toggle: toggle,
            hide: hide,
            show: show
        });
        var SELECT_ELEMENT_INNERHTML_BUGGY = function() {
                var el = document.createElement("select"),
                    isBuggy = !0;
                return el.innerHTML = '<option value="test">test</option>', el.options && el.options[0] && (isBuggy = "OPTION" !== el.options[0].nodeName.toUpperCase()), el = null, isBuggy
            }(),
            TABLE_ELEMENT_INNERHTML_BUGGY = function() {
                try {
                    var el = document.createElement("table");
                    if (el && el.tBodies) {
                        el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
                        var isBuggy = "undefined" == typeof el.tBodies[0];
                        return el = null, isBuggy
                    }
                } catch (e) {
                    return !0
                }
            }(),
            LINK_ELEMENT_INNERHTML_BUGGY = function() {
                try {
                    var el = document.createElement("div");
                    el.innerHTML = "<link />";
                    var isBuggy = 0 === el.childNodes.length;
                    return el = null, isBuggy
                } catch (e) {
                    return !0
                }
            }(),
            ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY || TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY,
            SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = function() {
                var s = document.createElement("script"),
                    isBuggy = !1;
                try {
                    s.appendChild(document.createTextNode("")), isBuggy = !s.firstChild || s.firstChild && 3 !== s.firstChild.nodeType
                } catch (e) {
                    isBuggy = !0
                }
                return s = null, isBuggy
            }(),
            INSERTION_TRANSLATIONS = {
                before: function(element, node) {
                    element.parentNode.insertBefore(node, element)
                },
                top: function(element, node) {
                    element.insertBefore(node, element.firstChild)
                },
                bottom: function(element, node) {
                    element.appendChild(node)
                },
                after: function(element, node) {
                    element.parentNode.insertBefore(node, element.nextSibling)
                },
                tags: {
                    TABLE: ["<table>", "</table>", 1],
                    TBODY: ["<table><tbody>", "</tbody></table>", 2],
                    TR: ["<table><tbody><tr>", "</tr></tbody></table>", 3],
                    TD: ["<table><tbody><tr><td>", "</td></tr></tbody></table>", 4],
                    SELECT: ["<select>", "</select>", 1]
                }
            },
            tags = INSERTION_TRANSLATIONS.tags;
        Object.extend(tags, {
            THEAD: tags.TBODY,
            TFOOT: tags.TBODY,
            TH: tags.TD
        }), "outerHTML" in document.documentElement && (replace = replace_IE), HAS_UNIQUE_ID_PROPERTY && (purgeCollection = purgeCollection_IE), Object.extend(methods, {
            remove: remove,
            update: update,
            replace: replace,
            insert: insert,
            wrap: wrap,
            cleanWhitespace: cleanWhitespace,
            empty: empty,
            clone: clone,
            purge: purge
        });
        var descendantOf;
        descendantOf = DIV.compareDocumentPosition ? descendantOf_compareDocumentPosition : DIV.contains ? descendantOf_contains : descendantOf_DOM, Object.extend(methods, {
            recursivelyCollect: recursivelyCollect,
            ancestors: ancestors,
            descendants: descendants,
            firstDescendant: firstDescendant,
            immediateDescendants: immediateDescendants,
            previousSiblings: previousSiblings,
            nextSiblings: nextSiblings,
            siblings: siblings,
            match: match,
            up: up,
            down: down,
            previous: previous,
            next: next,
            select: select,
            adjacent: adjacent,
            descendantOf: descendantOf,
            getElementsBySelector: select,
            childElements: immediateDescendants
        });
        var idCounter = 1,
            PROBLEMATIC_ATTRIBUTE_READING = function() {
                DIV.setAttribute("onclick", []);
                var value = DIV.getAttribute("onclick"),
                    isFunction = Object.isArray(value);
                return DIV.removeAttribute("onclick"), isFunction
            }();
        PROBLEMATIC_ATTRIBUTE_READING ? readAttribute = readAttribute_IE : Prototype.Browser.Opera && (readAttribute = readAttribute_Opera);
        var PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES = function() {
            if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) return !1;
            var checkbox = document.createElement('<input type="checkbox">');
            checkbox.checked = !0;
            var node = checkbox.getAttributeNode("checked");
            return !node || !node.specified
        }();
        GLOBAL.Element.Methods.Simulated.hasAttribute = PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES ? hasAttribute_IE : hasAttribute;
        var regExpCache = {},
            ATTRIBUTE_TRANSLATIONS = {},
            classProp = "className",
            forProp = "for";
        DIV.setAttribute(classProp, "x"), "x" !== DIV.className && (DIV.setAttribute("class", "x"), "x" === DIV.className && (classProp = "class"));
        var LABEL = document.createElement("label");
        LABEL.setAttribute(forProp, "x"), "x" !== LABEL.htmlFor && (LABEL.setAttribute("htmlFor", "x"), "x" === LABEL.htmlFor && (forProp = "htmlFor")), LABEL = null, DIV.onclick = Prototype.emptyFunction;
        var _getEv, onclickValue = DIV.getAttribute("onclick");
        String(onclickValue).indexOf("{") > -1 ? _getEv = function(element, attribute) {
            var value = element.getAttribute(attribute);
            return value ? (value = value.toString(), value = value.split("{")[1], value = value.split("}")[0], value.strip()) : null
        } : "" === onclickValue && (_getEv = function(element, attribute) {
            var value = element.getAttribute(attribute);
            return value ? value.strip() : null
        }), ATTRIBUTE_TRANSLATIONS.read = {
            names: {
                "class": classProp,
                className: classProp,
                "for": forProp,
                htmlFor: forProp
            },
            values: {
                style: function(element) {
                    return element.style.cssText.toLowerCase()
                },
                title: function(element) {
                    return element.title
                }
            }
        }, ATTRIBUTE_TRANSLATIONS.write = {
            names: {
                className: "class",
                htmlFor: "for",
                cellpadding: "cellPadding",
                cellspacing: "cellSpacing"
            },
            values: {
                checked: function(element, value) {
                    element.checked = !!value
                },
                style: function(element, value) {
                    element.style.cssText = value ? value : ""
                }
            }
        }, ATTRIBUTE_TRANSLATIONS.has = {
            names: {}
        }, Object.extend(ATTRIBUTE_TRANSLATIONS.write.names, ATTRIBUTE_TRANSLATIONS.read.names);
        for (var attr, CAMEL_CASED_ATTRIBUTE_NAMES = $w("colSpan rowSpan vAlign dateTime accessKey tabIndex encType maxLength readOnly longDesc frameBorder"), i = 0; attr = CAMEL_CASED_ATTRIBUTE_NAMES[i]; i++) ATTRIBUTE_TRANSLATIONS.write.names[attr.toLowerCase()] = attr, ATTRIBUTE_TRANSLATIONS.has.names[attr.toLowerCase()] = attr;
        Object.extend(ATTRIBUTE_TRANSLATIONS.read.values, {
            href: _getAttr2,
            src: _getAttr2,
            type: _getAttr,
            action: _getAttrNode,
            disabled: _getFlag,
            checked: _getFlag,
            readonly: _getFlag,
            multiple: _getFlag,
            onload: _getEv,
            onunload: _getEv,
            onclick: _getEv,
            ondblclick: _getEv,
            onmousedown: _getEv,
            onmouseup: _getEv,
            onmouseover: _getEv,
            onmousemove: _getEv,
            onmouseout: _getEv,
            onfocus: _getEv,
            onblur: _getEv,
            onkeypress: _getEv,
            onkeydown: _getEv,
            onkeyup: _getEv,
            onsubmit: _getEv,
            onreset: _getEv,
            onselect: _getEv,
            onchange: _getEv
        }), Object.extend(methods, {
            identify: identify,
            readAttribute: readAttribute,
            writeAttribute: writeAttribute,
            classNames: classNames,
            hasClassName: hasClassName,
            addClassName: addClassName,
            removeClassName: removeClassName,
            toggleClassName: toggleClassName
        });
        var STANDARD_CSS_OPACITY_SUPPORTED = function() {
            return DIV.style.cssText = "opacity:.55", /^0.55/.test(DIV.style.opacity)
        }();
        Object.extend(methods, {
            setStyle: setStyle,
            getStyle: getStyle,
            setOpacity: setOpacity,
            getOpacity: getOpacity
        }), "styleFloat" in DIV.style && (methods.getStyle = getStyle_IE, methods.setOpacity = setOpacity_IE, methods.getOpacity = getOpacity_IE), GLOBAL.Element.Storage = {
            UID: 1
        };
        var HAS_UNIQUE_ID_PROPERTY = "uniqueID" in DIV;
        HAS_UNIQUE_ID_PROPERTY && (getUniqueElementID = getUniqueElementID_IE), Object.extend(methods, {
            getStorage: getStorage,
            store: store,
            retrieve: retrieve
        });
        var Methods = {},
            ByTag = Element.Methods.ByTag,
            F = Prototype.BrowserFeatures;
        !F.ElementExtensions && "__proto__" in DIV && (GLOBAL.HTMLElement = {}, GLOBAL.HTMLElement.prototype = DIV.__proto__, F.ElementExtensions = !0);
        var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY = checkElementPrototypeDeficiency("object"),
            EXTENDED = {};
        F.SpecificElementExtensions && (extend = HTMLOBJECTELEMENT_PROTOTYPE_BUGGY ? extend_IE8 : Prototype.K), Object.extend(GLOBAL.Element, {
            extend: extend,
            addMethods: addMethods
        }), GLOBAL.Element.extend.refresh = extend === Prototype.K ? Prototype.emptyFunction : function() {
            Prototype.BrowserFeatures.ElementExtensions || (Object.extend(Methods, Element.Methods), Object.extend(Methods, Element.Methods.Simulated), EXTENDED = {})
        }, Element.addMethods(methods), window.attachEvent && window.attachEvent("onunload", destroyCache_IE)
    }(this),
    function() {
        function toDecimal(pctString) {
            var match = pctString.match(/^(\d+)%?$/i);
            return match ? Number(match[1]) / 100 : null
        }

        function getRawStyle(element, style) {
            element = $(element);
            var value = element.style[style];
            if (!value || "auto" === value) {
                var css = document.defaultView.getComputedStyle(element, null);
                value = css ? css[style] : null
            }
            return "opacity" === style ? value ? parseFloat(value) : 1 : "auto" === value ? null : value
        }

        function getRawStyle_IE(element, style) {
            var value = element.style[style];
            return !value && element.currentStyle && (value = element.currentStyle[style]), value
        }

        function getContentWidth(element, context) {
            var boxWidth = element.offsetWidth,
                bl = getPixelValue(element, "borderLeftWidth", context) || 0,
                br = getPixelValue(element, "borderRightWidth", context) || 0,
                pl = getPixelValue(element, "paddingLeft", context) || 0,
                pr = getPixelValue(element, "paddingRight", context) || 0;
            return boxWidth - bl - br - pl - pr
        }

        function getPixelValue(value, property, context) {
            var element = null;
            if (Object.isElement(value) && (element = value, value = getRawStyle(element, property)), null === value || Object.isUndefined(value)) return null;
            if (/^(?:-)?\d+(\.\d+)?(px)?$/i.test(value)) return window.parseFloat(value);
            var isPercentage = value.include("%"),
                isViewport = context === document.viewport;
            if (/\d/.test(value) && element && element.runtimeStyle && (!isPercentage || !isViewport)) {
                var style = element.style.left,
                    rStyle = element.runtimeStyle.left;
                return element.runtimeStyle.left = element.currentStyle.left, element.style.left = value || 0, value = element.style.pixelLeft, element.style.left = style, element.runtimeStyle.left = rStyle, value
            }
            if (element && isPercentage) {
                context = context || element.parentNode;
                var decimal = toDecimal(value),
                    whole = null,
                    isHorizontal = property.include("left") || property.include("right") || property.include("width"),
                    isVertical = property.include("top") || property.include("bottom") || property.include("height");
                return context === document.viewport ? isHorizontal ? whole = document.viewport.getWidth() : isVertical && (whole = document.viewport.getHeight()) : isHorizontal ? whole = $(context).measure("width") : isVertical && (whole = $(context).measure("height")), null === whole ? 0 : whole * decimal
            }
            return 0
        }

        function isDisplayed(element) {
            for (; element && element.parentNode;) {
                var display = element.getStyle("display");
                if ("none" === display) return !1;
                element = $(element.parentNode)
            }
            return !0
        }

        function cssNameFor(key) {
            return key.include("border") && (key += "-width"), key.camelize()
        }

        function getLayout(element, preCompute) {
            return new Element.Layout(element, preCompute)
        }

        function measure(element, property) {
            return $(element).getLayout().get(property)
        }

        function getHeight(element) {
            return Element.getDimensions(element).height
        }

        function getWidth(element) {
            return Element.getDimensions(element).width
        }

        function getDimensions(element) {
            element = $(element);
            var display = Element.getStyle(element, "display");
            if (display && "none" !== display) return {
                width: element.offsetWidth,
                height: element.offsetHeight
            };
            var style = element.style,
                originalStyles = {
                    visibility: style.visibility,
                    position: style.position,
                    display: style.display
                },
                newStyles = {
                    visibility: "hidden",
                    display: "block"
                };
            "fixed" !== originalStyles.position && (newStyles.position = "absolute"), Element.setStyle(element, newStyles);
            var dimensions = {
                width: element.offsetWidth,
                height: element.offsetHeight
            };
            return Element.setStyle(element, originalStyles), dimensions
        }

        function getOffsetParent(element) {
            if (element = $(element), isDocument(element) || isDetached(element) || isBody(element) || isHtml(element)) return $(document.body);
            var isInline = "inline" === Element.getStyle(element, "display");
            if (!isInline && element.offsetParent) return $(element.offsetParent);
            for (;
                (element = element.parentNode) && element !== document.body;)
                if ("static" !== Element.getStyle(element, "position")) return isHtml(element) ? $(document.body) : $(element);
            return $(document.body)
        }

        function cumulativeOffset(element) {
            element = $(element);
            var valueT = 0,
                valueL = 0;
            if (element.parentNode)
                do valueT += element.offsetTop || 0, valueL += element.offsetLeft || 0, element = element.offsetParent; while (element);
            return new Element.Offset(valueL, valueT)
        }

        function positionedOffset(element) {
            element = $(element);
            var layout = element.getLayout(),
                valueT = 0,
                valueL = 0;
            do
                if (valueT += element.offsetTop || 0, valueL += element.offsetLeft || 0, element = element.offsetParent) {
                    if (isBody(element)) break;
                    var p = Element.getStyle(element, "position");
                    if ("static" !== p) break
                }
            while (element);
            return valueL -= layout.get("margin-top"), valueT -= layout.get("margin-left"), new Element.Offset(valueL, valueT)
        }

        function cumulativeScrollOffset(element) {
            var valueT = 0,
                valueL = 0;
            do {
                if (element === document.body) {
                    var bodyScrollNode = document.documentElement || document.body.parentNode || document.body;
                    valueT += Object.isUndefined(window.pageYOffset) ? bodyScrollNode.scrollTop || 0 : window.pageYOffset, valueL += Object.isUndefined(window.pageXOffset) ? bodyScrollNode.scrollLeft || 0 : window.pageXOffset;
                    break
                }
                valueT += element.scrollTop || 0, valueL += element.scrollLeft || 0, element = element.parentNode
            } while (element);
            return new Element.Offset(valueL, valueT)
        }

        function viewportOffset(forElement) {
            var valueT = 0,
                valueL = 0,
                docBody = document.body;
            forElement = $(forElement);
            var element = forElement;
            do
                if (valueT += element.offsetTop || 0, valueL += element.offsetLeft || 0, element.offsetParent == docBody && "absolute" == Element.getStyle(element, "position")) break;
            while (element = element.offsetParent);
            element = forElement;
            do element != docBody && (valueT -= element.scrollTop || 0, valueL -= element.scrollLeft || 0); while (element = element.parentNode);
            return new Element.Offset(valueL, valueT)
        }

        function absolutize(element) {
            if (element = $(element), "absolute" === Element.getStyle(element, "position")) return element;
            var offsetParent = getOffsetParent(element),
                eOffset = element.viewportOffset(),
                pOffset = offsetParent.viewportOffset(),
                offset = eOffset.relativeTo(pOffset),
                layout = element.getLayout();
            return element.store("prototype_absolutize_original_styles", {
                position: element.getStyle("position"),
                left: element.getStyle("left"),
                top: element.getStyle("top"),
                width: element.getStyle("width"),
                height: element.getStyle("height")
            }), element.setStyle({
                position: "absolute",
                top: offset.top + "px",
                left: offset.left + "px",
                width: layout.get("width") + "px",
                height: layout.get("height") + "px"
            }), element
        }

        function relativize(element) {
            if (element = $(element), "relative" === Element.getStyle(element, "position")) return element;
            var originalStyles = element.retrieve("prototype_absolutize_original_styles");
            return originalStyles && element.setStyle(originalStyles), element
        }

        function scrollTo(element) {
            element = $(element);
            var pos = Element.cumulativeOffset(element);
            return window.scrollTo(pos.left, pos.top), element
        }

        function makePositioned(element) {
            element = $(element);
            var position = Element.getStyle(element, "position"),
                styles = {};
            return "static" !== position && position || (styles.position = "relative", Prototype.Browser.Opera && (styles.top = 0, styles.left = 0), Element.setStyle(element, styles), Element.store(element, "prototype_made_positioned", !0)), element
        }

        function undoPositioned(element) {
            element = $(element);
            var storage = Element.getStorage(element),
                madePositioned = storage.get("prototype_made_positioned");
            return madePositioned && (storage.unset("prototype_made_positioned"), Element.setStyle(element, {
                position: "",
                top: "",
                bottom: "",
                left: "",
                right: ""
            })), element
        }

        function makeClipping(element) {
            element = $(element);
            var storage = Element.getStorage(element),
                madeClipping = storage.get("prototype_made_clipping");
            if (Object.isUndefined(madeClipping)) {
                var overflow = Element.getStyle(element, "overflow");
                storage.set("prototype_made_clipping", overflow), "hidden" !== overflow && (element.style.overflow = "hidden")
            }
            return element
        }

        function undoClipping(element) {
            element = $(element);
            var storage = Element.getStorage(element),
                overflow = storage.get("prototype_made_clipping");
            return Object.isUndefined(overflow) || (storage.unset("prototype_made_clipping"), element.style.overflow = overflow || ""), element
        }

        function clonePosition(element, source, options) {
            options = Object.extend({
                setLeft: !0,
                setTop: !0,
                setWidth: !0,
                setHeight: !0,
                offsetTop: 0,
                offsetLeft: 0
            }, options || {}), source = $(source), element = $(element);
            var p, delta, layout, styles = {};
            if ((options.setLeft || options.setTop) && (p = Element.viewportOffset(source), delta = [0, 0], "absolute" === Element.getStyle(element, "position"))) {
                var parent = Element.getOffsetParent(element);
                parent !== document.body && (delta = Element.viewportOffset(parent))
            }
            return (options.setWidth || options.setHeight) && (layout = Element.getLayout(source)), options.setLeft && (styles.left = p[0] - delta[0] + options.offsetLeft + "px"), options.setTop && (styles.top = p[1] - delta[1] + options.offsetTop + "px"), options.setWidth && (styles.width = layout.get("border-box-width") + "px"), options.setHeight && (styles.height = layout.get("border-box-height") + "px"), Element.setStyle(element, styles)
        }

        function isBody(element) {
            return "BODY" === element.nodeName.toUpperCase()
        }

        function isHtml(element) {
            return "HTML" === element.nodeName.toUpperCase()
        }

        function isDocument(element) {
            return element.nodeType === Node.DOCUMENT_NODE
        }

        function isDetached(element) {
            return element !== document.body && !Element.descendantOf(element, document.body)
        }
        "currentStyle" in document.documentElement && (getRawStyle = getRawStyle_IE);
        var hasLayout = Prototype.K;
        "currentStyle" in document.documentElement && (hasLayout = function(element) {
            return element.currentStyle.hasLayout || (element.style.zoom = 1), element
        }), Element.Layout = Class.create(Hash, {
            initialize: function($super, element, preCompute) {
                $super(), this.element = $(element), Element.Layout.PROPERTIES.each(function(property) {
                    this._set(property, null)
                }, this), preCompute && (this._preComputing = !0, this._begin(), Element.Layout.PROPERTIES.each(this._compute, this), this._end(), this._preComputing = !1)
            },
            _set: function(property, value) {
                return Hash.prototype.set.call(this, property, value)
            },
            set: function() {
                throw "Properties of Element.Layout are read-only."
            },
            get: function($super, property) {
                var value = $super(property);
                return null === value ? this._compute(property) : value
            },
            _begin: function() {
                if (!this._isPrepared()) {
                    var element = this.element;
                    if (isDisplayed(element)) return this._setPrepared(!0), void 0;
                    var originalStyles = {
                        position: element.style.position || "",
                        width: element.style.width || "",
                        visibility: element.style.visibility || "",
                        display: element.style.display || ""
                    };
                    element.store("prototype_original_styles", originalStyles);
                    var position = getRawStyle(element, "position"),
                        width = element.offsetWidth;
                    (0 === width || null === width) && (element.style.display = "block", width = element.offsetWidth);
                    var context = "fixed" === position ? document.viewport : element.parentNode,
                        tempStyles = {
                            visibility: "hidden",
                            display: "block"
                        };
                    "fixed" !== position && (tempStyles.position = "absolute"), element.setStyle(tempStyles);
                    var newWidth, positionedWidth = element.offsetWidth;
                    if (width && positionedWidth === width) newWidth = getContentWidth(element, context);
                    else if ("absolute" === position || "fixed" === position) newWidth = getContentWidth(element, context);
                    else {
                        var parent = element.parentNode,
                            pLayout = $(parent).getLayout();
                        newWidth = pLayout.get("width") - this.get("margin-left") - this.get("border-left") - this.get("padding-left") - this.get("padding-right") - this.get("border-right") - this.get("margin-right")
                    }
                    element.setStyle({
                        width: newWidth + "px"
                    }), this._setPrepared(!0)
                }
            },
            _end: function() {
                var element = this.element,
                    originalStyles = element.retrieve("prototype_original_styles");
                element.store("prototype_original_styles", null), element.setStyle(originalStyles), this._setPrepared(!1)
            },
            _compute: function(property) {
                var COMPUTATIONS = Element.Layout.COMPUTATIONS;
                if (!(property in COMPUTATIONS)) throw "Property not found.";
                return this._set(property, COMPUTATIONS[property].call(this, this.element))
            },
            _isPrepared: function() {
                return this.element.retrieve("prototype_element_layout_prepared", !1)
            },
            _setPrepared: function(bool) {
                return this.element.store("prototype_element_layout_prepared", bool)
            },
            toObject: function() {
                var args = $A(arguments),
                    keys = 0 === args.length ? Element.Layout.PROPERTIES : args.join(" ").split(" "),
                    obj = {};
                return keys.each(function(key) {
                    if (Element.Layout.PROPERTIES.include(key)) {
                        var value = this.get(key);
                        null != value && (obj[key] = value)
                    }
                }, this), obj
            },
            toHash: function() {
                var obj = this.toObject.apply(this, arguments);
                return new Hash(obj)
            },
            toCSS: function() {
                var args = $A(arguments),
                    keys = 0 === args.length ? Element.Layout.PROPERTIES : args.join(" ").split(" "),
                    css = {};
                return keys.each(function(key) {
                    if (Element.Layout.PROPERTIES.include(key) && !Element.Layout.COMPOSITE_PROPERTIES.include(key)) {
                        var value = this.get(key);
                        null != value && (css[cssNameFor(key)] = value + "px")
                    }
                }, this), css
            },
            inspect: function() {
                return "#<Element.Layout>"
            }
        }), Object.extend(Element.Layout, {
            PROPERTIES: $w("height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height"),
            COMPOSITE_PROPERTIES: $w("padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height"),
            COMPUTATIONS: {
                height: function() {
                    this._preComputing || this._begin();
                    var bHeight = this.get("border-box-height");
                    if (0 >= bHeight) return this._preComputing || this._end(), 0;
                    var bTop = this.get("border-top"),
                        bBottom = this.get("border-bottom"),
                        pTop = this.get("padding-top"),
                        pBottom = this.get("padding-bottom");
                    return this._preComputing || this._end(), bHeight - bTop - bBottom - pTop - pBottom
                },
                width: function() {
                    this._preComputing || this._begin();
                    var bWidth = this.get("border-box-width");
                    if (0 >= bWidth) return this._preComputing || this._end(), 0;
                    var bLeft = this.get("border-left"),
                        bRight = this.get("border-right"),
                        pLeft = this.get("padding-left"),
                        pRight = this.get("padding-right");
                    return this._preComputing || this._end(), bWidth - bLeft - bRight - pLeft - pRight
                },
                "padding-box-height": function() {
                    var height = this.get("height"),
                        pTop = this.get("padding-top"),
                        pBottom = this.get("padding-bottom");
                    return height + pTop + pBottom
                },
                "padding-box-width": function() {
                    var width = this.get("width"),
                        pLeft = this.get("padding-left"),
                        pRight = this.get("padding-right");
                    return width + pLeft + pRight
                },
                "border-box-height": function(element) {
                    this._preComputing || this._begin();
                    var height = element.offsetHeight;
                    return this._preComputing || this._end(), height
                },
                "border-box-width": function(element) {
                    this._preComputing || this._begin();
                    var width = element.offsetWidth;
                    return this._preComputing || this._end(), width
                },
                "margin-box-height": function() {
                    var bHeight = this.get("border-box-height"),
                        mTop = this.get("margin-top"),
                        mBottom = this.get("margin-bottom");
                    return 0 >= bHeight ? 0 : bHeight + mTop + mBottom
                },
                "margin-box-width": function() {
                    var bWidth = this.get("border-box-width"),
                        mLeft = this.get("margin-left"),
                        mRight = this.get("margin-right");
                    return 0 >= bWidth ? 0 : bWidth + mLeft + mRight
                },
                top: function(element) {
                    var offset = element.positionedOffset();
                    return offset.top
                },
                bottom: function(element) {
                    var offset = element.positionedOffset(),
                        parent = element.getOffsetParent(),
                        pHeight = parent.measure("height"),
                        mHeight = this.get("border-box-height");
                    return pHeight - mHeight - offset.top
                },
                left: function(element) {
                    var offset = element.positionedOffset();
                    return offset.left
                },
                right: function(element) {
                    var offset = element.positionedOffset(),
                        parent = element.getOffsetParent(),
                        pWidth = parent.measure("width"),
                        mWidth = this.get("border-box-width");
                    return pWidth - mWidth - offset.left
                },
                "padding-top": function(element) {
                    return getPixelValue(element, "paddingTop")
                },
                "padding-bottom": function(element) {
                    return getPixelValue(element, "paddingBottom")
                },
                "padding-left": function(element) {
                    return getPixelValue(element, "paddingLeft")
                },
                "padding-right": function(element) {
                    return getPixelValue(element, "paddingRight")
                },
                "border-top": function(element) {
                    return getPixelValue(element, "borderTopWidth")
                },
                "border-bottom": function(element) {
                    return getPixelValue(element, "borderBottomWidth")
                },
                "border-left": function(element) {
                    return getPixelValue(element, "borderLeftWidth")
                },
                "border-right": function(element) {
                    return getPixelValue(element, "borderRightWidth")
                },
                "margin-top": function(element) {
                    return getPixelValue(element, "marginTop")
                },
                "margin-bottom": function(element) {
                    return getPixelValue(element, "marginBottom")
                },
                "margin-left": function(element) {
                    return getPixelValue(element, "marginLeft")
                },
                "margin-right": function(element) {
                    return getPixelValue(element, "marginRight")
                }
            }
        }), "getBoundingClientRect" in document.documentElement && Object.extend(Element.Layout.COMPUTATIONS, {
            right: function(element) {
                var parent = hasLayout(element.getOffsetParent()),
                    rect = element.getBoundingClientRect(),
                    pRect = parent.getBoundingClientRect();
                return (pRect.right - rect.right).round()
            },
            bottom: function(element) {
                var parent = hasLayout(element.getOffsetParent()),
                    rect = element.getBoundingClientRect(),
                    pRect = parent.getBoundingClientRect();
                return (pRect.bottom - rect.bottom).round()
            }
        }), Element.Offset = Class.create({
            initialize: function(left, top) {
                this.left = left.round(), this.top = top.round(), this[0] = this.left, this[1] = this.top
            },
            relativeTo: function(offset) {
                return new Element.Offset(this.left - offset.left, this.top - offset.top)
            },
            inspect: function() {
                return "#<Element.Offset left: #{left} top: #{top}>".interpolate(this)
            },
            toString: function() {
                return "[#{left}, #{top}]".interpolate(this)
            },
            toArray: function() {
                return [this.left, this.top]
            }
        }), Prototype.Browser.IE ? (getOffsetParent = getOffsetParent.wrap(function(proceed, element) {
            if (element = $(element), isDocument(element) || isDetached(element) || isBody(element) || isHtml(element)) return $(document.body);
            var position = element.getStyle("position");
            if ("static" !== position) return proceed(element);
            element.setStyle({
                position: "relative"
            });
            var value = proceed(element);
            return element.setStyle({
                position: position
            }), value
        }), positionedOffset = positionedOffset.wrap(function(proceed, element) {
            if (element = $(element), !element.parentNode) return new Element.Offset(0, 0);
            var position = element.getStyle("position");
            if ("static" !== position) return proceed(element);
            var offsetParent = element.getOffsetParent();
            offsetParent && "fixed" === offsetParent.getStyle("position") && hasLayout(offsetParent), element.setStyle({
                position: "relative"
            });
            var value = proceed(element);
            return element.setStyle({
                position: position
            }), value
        })) : Prototype.Browser.Webkit && (cumulativeOffset = function(element) {
            element = $(element);
            var valueT = 0,
                valueL = 0;
            do {
                if (valueT += element.offsetTop || 0, valueL += element.offsetLeft || 0, element.offsetParent == document.body && "absolute" == Element.getStyle(element, "position")) break;
                element = element.offsetParent
            } while (element);
            return new Element.Offset(valueL, valueT)
        }), Element.addMethods({
            getLayout: getLayout,
            measure: measure,
            getWidth: getWidth,
            getHeight: getHeight,
            getDimensions: getDimensions,
            getOffsetParent: getOffsetParent,
            cumulativeOffset: cumulativeOffset,
            positionedOffset: positionedOffset,
            cumulativeScrollOffset: cumulativeScrollOffset,
            viewportOffset: viewportOffset,
            absolutize: absolutize,
            relativize: relativize,
            scrollTo: scrollTo,
            makePositioned: makePositioned,
            undoPositioned: undoPositioned,
            makeClipping: makeClipping,
            undoClipping: undoClipping,
            clonePosition: clonePosition
        }), "getBoundingClientRect" in document.documentElement && Element.addMethods({
            viewportOffset: function(element) {
                if (element = $(element), isDetached(element)) return new Element.Offset(0, 0);
                var rect = element.getBoundingClientRect(),
                    docEl = document.documentElement;
                return new Element.Offset(rect.left - docEl.clientLeft, rect.top - docEl.clientTop)
            }
        })
    }(),
    function() {
        function getRootElement() {
            return ROOT ? ROOT : ROOT = IS_OLD_OPERA ? document.body : document.documentElement
        }

        function getDimensions() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            }
        }

        function getWidth() {
            return getRootElement().clientWidth
        }

        function getHeight() {
            return getRootElement().clientHeight
        }

        function getScrollOffsets() {
            var x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
                y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
            return new Element.Offset(x, y)
        }
        var IS_OLD_OPERA = Prototype.Browser.Opera && window.parseFloat(window.opera.version()) < 9.5,
            ROOT = null;
        document.viewport = {
            getDimensions: getDimensions,
            getWidth: getWidth,
            getHeight: getHeight,
            getScrollOffsets: getScrollOffsets
        }
    }(), window.$$ = function() {
        var expression = $A(arguments).join(", ");
        return Prototype.Selector.select(expression, document)
    }, Prototype.Selector = function() {
        function select() {
            throw new Error('Method "Prototype.Selector.select" must be defined.')
        }

        function match() {
            throw new Error('Method "Prototype.Selector.match" must be defined.')
        }

        function find(elements, expression, index) {
            index = index || 0;
            var i, match = Prototype.Selector.match,
                length = elements.length,
                matchIndex = 0;
            for (i = 0; length > i; i++)
                if (match(elements[i], expression) && index == matchIndex++) return Element.extend(elements[i])
        }

        function extendElements(elements) {
            for (var i = 0, length = elements.length; length > i; i++) Element.extend(elements[i]);
            return elements
        }
        var K = Prototype.K;
        return {
            select: select,
            match: match,
            find: find,
            extendElements: Element.extend === K ? K : extendElements,
            extendElement: Element.extend
        }
    }(), Prototype._original_property = window.Sizzle,
    function(window) {
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, results = results || [], !selector || "string" != typeof selector) return results;
            if (1 !== (nodeType = context.nodeType) && 9 !== nodeType) return [];
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector))
                    if (m = match[1]) {
                        if (9 === nodeType) {
                            if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
                            if (elem.id === m) return results.push(elem), results
                        } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), results
                    } else {
                        if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), results;
                        if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), results
                    }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (nid = old = expando, newContext = context, newSelector = 9 === nodeType && selector, 1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                        for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), nid = "[id='" + nid + "'] ", i = groups.length; i--;) groups[i] = nid + toSelector(groups[i]);
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context, newSelector = groups.join(",")
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results
                    } catch (qsaError) {} finally {
                        old || context.removeAttribute("id")
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed)
        }

        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
            }
            var keys = [];
            return cache
        }

        function markFunction(fn) {
            return fn[expando] = !0, fn
        }

        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div)
            } catch (e) {
                return !1
            } finally {
                div.parentNode && div.parentNode.removeChild(div), div = null
            }
        }

        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = attrs.length; i--;) Expr.attrHandle[arr[i]] = handler
        }

        function siblingCheck(a, b) {
            var cur = b && a,
                diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) return diff;
            if (cur)
                for (; cur = cur.nextSibling;)
                    if (cur === b) return -1;
            return a ? 1 : -1
        }

        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && elem.type === type
            }
        }

        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type
            }
        }

        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                })
            })
        }

        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context
        }

        function setFilters() {}

        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        }

        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
            return selector
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                checkNonElements = base && "parentNode" === dir,
                doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (; elem = elem[dir];)
                    if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml)
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                    for (; elem = elem[dir];)
                        if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
                } else
                    for (; elem = elem[dir];)
                        if (1 === elem.nodeType || checkNonElements) {
                            if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                            if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0
                        }
            }
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--;)
                    if (!matchers[i](elem, context, xml)) return !1;
                return !0
            } : matchers[0]
        }

        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
            return results
        }

        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++)(elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), mapped && map.push(i));
            return newUnmatched
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [],
                    postMap = [],
                    preexisting = results.length,
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                    matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
                    matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                    for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml)
                        }
                        for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
            })
        }

        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                    return elem === checkContext
                }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                    return indexOf.call(checkContext, elem) > -1
                }, implicitRelative, !0), matchers = [function(elem, context, xml) {
                    return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                }]; len > i; i++)
                if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                else {
                    if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                        for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++);
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: " " === tokens[i - 2].type ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
            return elementMatcher(matchers)
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function(seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        elems = seed || byElement && Expr.find.TAG("*", outermost),
                        dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1,
                        len = elems.length;
                    for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                        if (byElement && elem) {
                            for (j = 0; matcher = elementMatchers[j++];)
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break
                                }
                            outermost && (dirruns = dirrunsUnique)
                        }
                        bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                    }
                    if (matchedCount += i, bySet && i !== matchedCount) {
                        for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                        if (seed) {
                            if (matchedCount > 0)
                                for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                            setMatched = condense(setMatched)
                        }
                        push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                    }
                    return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                };
            return bySet ? markFunction(superMatcher) : superMatcher
        }
        var i, support, Expr, getText, isXML, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date,
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function(a, b) {
                return a === b && (hasDuplicate = !0), 0
            },
            strundefined = "undefined",
            MAX_NEGATIVE = 1 << 31,
            hasOwn = {}.hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            indexOf = arr.indexOf || function(elem) {
                for (var i = 0, len = this.length; len > i; i++)
                    if (this[i] === elem) return i;
                return -1
            },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            whitespace = "[\\x20\\t\\r\\n\\f]",
            characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            identifier = characterEncoding.replace("w", "w#"),
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
            pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
                ID: new RegExp("^#(" + characterEncoding + ")"),
                CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                ATTR: new RegExp("^" + attributes),
                PSEUDO: new RegExp("^" + pseudos),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + booleans + ")$", "i"),
                needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            rescape = /'|\\/g,
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function(_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(55296 | high >> 10, 56320 | 1023 & high)
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els))
                } : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++];);
                    target.length = j - 1
                }
            }
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc,
                parent = doc.defaultView;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = doc.documentElement, documentIsHTML = !isXML(doc), parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", function() {
                setDocument()
            }, !1) : parent.attachEvent && parent.attachEvent("onunload", function() {
                setDocument()
            })), support.attributes = assert(function(div) {
                return div.className = "i", !div.getAttribute("className")
            }), support.getElementsByTagName = assert(function(div) {
                return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length
            }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                return div.innerHTML = "<div class='a'></div><div class='a i'></div>", div.firstChild.className = "i", 2 === div.getElementsByClassName("i").length
            }), support.getById = assert(function(div) {
                return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length
            }), support.getById ? (Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== strundefined && documentIsHTML) {
                    var m = context.getElementById(id);
                    return m && m.parentNode ? [m] : []
                }
            }, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId
                }
            }) : (delete Expr.find.ID, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                    return node && node.value === attrId
                }
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag) : void 0
            } : function(tag, context) {
                var elem, tmp = [],
                    i = 0,
                    results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                    return tmp
                }
                return results
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                return typeof context.getElementsByClassName !== strundefined && documentIsHTML ? context.getElementsByClassName(className) : void 0
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function(div) {
                div.innerHTML = "<select t=''><option selected=''></option></select>", div.querySelectorAll("[t^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked")
            }), assert(function(div) {
                var input = doc.createElement("input");
                input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
            })), (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(div) {
                support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
            } : function(a, b) {
                if (b)
                    for (; b = b.parentNode;)
                        if (b === a) return !0;
                return !1
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0 : 4 & compare ? -1 : 1)
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [a],
                    bp = [b];
                if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
                for (; ap[i] === bp[i];) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            }, doc) : document
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements)
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), !(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
            } catch (e) {}
            return Sizzle(expr, document, null, [elem]).length > 0
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()],
                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg)
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [],
                j = 0,
                i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
                for (; j--;) results.splice(duplicates[j], 1)
            }
            return sortInput = null, results
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "",
                i = 0,
                nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
            } else
                for (; node = elem[i++];) ret += getText(node);
            return ret
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[5] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] && void 0 !== match[4] ? match[2] = match[4] : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                    }
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "")
                    })
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0
                    }
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3),
                        forward = "last" !== type.slice(-4),
                        ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                for (; dir;) {
                                    for (node = elem; node = node[dir];)
                                        if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling"
                                }
                                return !0
                            }
                            if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                                    if (1 === node.nodeType && ++diff && node === elem) {
                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                        break
                                    }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1];
                            else
                                for (;
                                    (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [dirruns, diff]), node !== elem)););
                            return diff -= last, diff === first || 0 === diff % first && diff / first >= 0
                        }
                    }
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--;) idx = indexOf.call(seed, matched[i]), seed[idx] = !(matches[idx] = matched[i])
                    }) : function(elem) {
                        return fn(elem, 0, args)
                    }) : fn
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), !results.pop()
                    }
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0
                    }
                }),
                contains: markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                    }
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(),
                        function(elem) {
                            var elemLang;
                            do
                                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), elemLang === lang || 0 === elemLang.indexOf(lang + "-");
                            while ((elem = elem.parentNode) && 1 === elem.nodeType);
                            return !1
                        }
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id
                },
                root: function(elem) {
                    return elem === docElem
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                },
                enabled: function(elem) {
                    return elem.disabled === !1
                },
                disabled: function(elem) {
                    return elem.disabled === !0
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        if (elem.nodeType < 6) return !1;
                    return !0
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem)
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName)
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName)
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                },
                first: createPositionalPseudo(function() {
                    return [0]
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1]
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [0 > argument ? argument + length : argument]
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; --i >= 0;) matchIndexes.push(i);
                    return matchIndexes
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                    return matchIndexes
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
                submit: !0,
                reset: !0
            }) Expr.pseudos[i] = createButtonPseudo(i);
        setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--;) cached = matcherFromTokens(match[i]), cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), cached.selector = selector
            }
            return cached
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector,
                match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], !context) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
                    if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                        if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), results;
                        break
                    }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), results
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(div1) {
            return 1 & div1.compareDocumentPosition(document.createElement("div"))
        }), assert(function(div) {
            return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href")
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
        }), support.attributes && assert(function(div) {
            return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value")
        }) || addHandle("value", function(elem, name, isXML) {
            return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue
        }), assert(function(div) {
            return null == div.getAttribute("disabled")
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }), "function" == typeof define && define.amd ? define(function() {
            return Sizzle
        }) : "undefined" != typeof module && module.exports ? module.exports = Sizzle : window.Sizzle = Sizzle
    }(window),
    function(engine) {
        function select(selector, scope) {
            return extendElements(engine(selector, scope || document))
        }

        function match(element, selector) {
            return 1 == engine.matches(selector, [element]).length
        }
        var extendElements = Prototype.Selector.extendElements;
        Prototype.Selector.engine = engine, Prototype.Selector.select = select, Prototype.Selector.match = match
    }(Sizzle), window.Sizzle = Prototype._original_property, delete Prototype._original_property;
var Form = {
    reset: function(form) {
        return form = $(form), form.reset(), form
    },
    serializeElements: function(elements, options) {
        "object" != typeof options ? options = {
            hash: !!options
        } : Object.isUndefined(options.hash) && (options.hash = !0);
        var key, value, accumulator, initial, submitted = !1,
            submit = options.submit;
        return options.hash ? (initial = {}, accumulator = function(result, key, value) {
            return key in result ? (Object.isArray(result[key]) || (result[key] = [result[key]]), result[key] = result[key].concat(value)) : result[key] = value, result
        }) : (initial = "", accumulator = function(result, key, values) {
            if (Object.isArray(values) || (values = [values]), !values.length) return result;
            var encodedKey = encodeURIComponent(key).gsub(/%20/, "+");
            return result + (result ? "&" : "") + values.map(function(value) {
                return value = value.gsub(/(\r)?\n/, "\r\n"), value = encodeURIComponent(value), value = value.gsub(/%20/, "+"), encodedKey + "=" + value
            }).join("&")
        }), elements.inject(initial, function(result, element) {
            return !element.disabled && element.name && (key = element.name, value = $(element).getValue(), null == value || "file" == element.type || "submit" == element.type && (submitted || submit === !1 || submit && key != submit || !(submitted = !0)) || (result = accumulator(result, key, value))), result
        })
    }
};
Form.Methods = {
    serialize: function(form, options) {
        return Form.serializeElements(Form.getElements(form), options)
    },
    getElements: function(form) {
        for (var element, elements = $(form).getElementsByTagName("*"), results = [], serializers = Form.Element.Serializers, i = 0; element = elements[i]; i++) serializers[element.tagName.toLowerCase()] && results.push(Element.extend(element));
        return results
    },
    getInputs: function(form, typeName, name) {
        form = $(form);
        var inputs = form.getElementsByTagName("input");
        if (!typeName && !name) return $A(inputs).map(Element.extend);
        for (var i = 0, matchingInputs = [], length = inputs.length; length > i; i++) {
            var input = inputs[i];
            typeName && input.type != typeName || name && input.name != name || matchingInputs.push(Element.extend(input))
        }
        return matchingInputs
    },
    disable: function(form) {
        return form = $(form), Form.getElements(form).invoke("disable"), form
    },
    enable: function(form) {
        return form = $(form), Form.getElements(form).invoke("enable"), form
    },
    findFirstElement: function(form) {
        var elements = $(form).getElements().findAll(function(element) {
                return "hidden" != element.type && !element.disabled
            }),
            firstByIndex = elements.findAll(function(element) {
                return element.hasAttribute("tabIndex") && element.tabIndex >= 0
            }).sortBy(function(element) {
                return element.tabIndex
            }).first();
        return firstByIndex ? firstByIndex : elements.find(function(element) {
            return /^(?:input|select|textarea)$/i.test(element.tagName)
        })
    },
    focusFirstElement: function(form) {
        form = $(form);
        var element = form.findFirstElement();
        return element && element.activate(), form
    },
    request: function(form, options) {
        form = $(form), options = Object.clone(options || {});
        var params = options.parameters,
            action = form.readAttribute("action") || "";
        return action.blank() && (action = window.location.href), options.parameters = form.serialize(!0), params && (Object.isString(params) && (params = params.toQueryParams()), Object.extend(options.parameters, params)), form.hasAttribute("method") && !options.method && (options.method = form.method), new Ajax.Request(action, options)
    }
}, Form.Element = {
    focus: function(element) {
        return $(element).focus(), element
    },
    select: function(element) {
        return $(element).select(), element
    }
}, Form.Element.Methods = {
    serialize: function(element) {
        if (element = $(element), !element.disabled && element.name) {
            var value = element.getValue();
            if (void 0 != value) {
                var pair = {};
                return pair[element.name] = value, Object.toQueryString(pair)
            }
        }
        return ""
    },
    getValue: function(element) {
        element = $(element);
        var method = element.tagName.toLowerCase();
        return Form.Element.Serializers[method](element)
    },
    setValue: function(element, value) {
        element = $(element);
        var method = element.tagName.toLowerCase();
        return Form.Element.Serializers[method](element, value), element
    },
    clear: function(element) {
        return $(element).value = "", element
    },
    present: function(element) {
        return "" != $(element).value
    },
    activate: function(element) {
        element = $(element);
        try {
            element.focus(), !element.select || "input" == element.tagName.toLowerCase() && /^(?:button|reset|submit)$/i.test(element.type) || element.select()
        } catch (e) {}
        return element
    },
    disable: function(element) {
        return element = $(element), element.disabled = !0, element
    },
    enable: function(element) {
        return element = $(element), element.disabled = !1, element
    }
};
var Field = Form.Element,
    $F = Form.Element.Methods.getValue;
Form.Element.Serializers = function() {
        function input(element, value) {
            switch (element.type.toLowerCase()) {
                case "checkbox":
                case "radio":
                    return inputSelector(element, value);
                default:
                    return valueSelector(element, value)
            }
        }

        function inputSelector(element, value) {
            return Object.isUndefined(value) ? element.checked ? element.value : null : (element.checked = !!value, void 0)
        }

        function valueSelector(element, value) {
            return Object.isUndefined(value) ? element.value : (element.value = value, void 0)
        }

        function select(element, value) {
            if (Object.isUndefined(value)) return ("select-one" === element.type ? selectOne : selectMany)(element);
            for (var opt, currentValue, single = !Object.isArray(value), i = 0, length = element.length; length > i; i++)
                if (opt = element.options[i], currentValue = this.optionValue(opt), single) {
                    if (currentValue == value) return opt.selected = !0, void 0
                } else opt.selected = value.include(currentValue)
        }

        function selectOne(element) {
            var index = element.selectedIndex;
            return index >= 0 ? optionValue(element.options[index]) : null
        }

        function selectMany(element) {
            var values, length = element.length;
            if (!length) return null;
            for (var i = 0, values = []; length > i; i++) {
                var opt = element.options[i];
                opt.selected && values.push(optionValue(opt))
            }
            return values
        }

        function optionValue(opt) {
            return Element.hasAttribute(opt, "value") ? opt.value : opt.text
        }
        return {
            input: input,
            inputSelector: inputSelector,
            textarea: valueSelector,
            select: select,
            selectOne: selectOne,
            selectMany: selectMany,
            optionValue: optionValue,
            button: valueSelector
        }
    }(), Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
        initialize: function($super, element, frequency, callback) {
            $super(callback, frequency), this.element = $(element), this.lastValue = this.getValue()
        },
        execute: function() {
            var value = this.getValue();
            (Object.isString(this.lastValue) && Object.isString(value) ? this.lastValue != value : String(this.lastValue) != String(value)) && (this.callback(this.element, value), this.lastValue = value)
        }
    }), Form.Element.Observer = Class.create(Abstract.TimedObserver, {
        getValue: function() {
            return Form.Element.getValue(this.element)
        }
    }), Form.Observer = Class.create(Abstract.TimedObserver, {
        getValue: function() {
            return Form.serialize(this.element)
        }
    }), Abstract.EventObserver = Class.create({
        initialize: function(element, callback) {
            this.element = $(element), this.callback = callback, this.lastValue = this.getValue(), "form" == this.element.tagName.toLowerCase() ? this.registerFormCallbacks() : this.registerCallback(this.element)
        },
        onElementEvent: function() {
            var value = this.getValue();
            this.lastValue != value && (this.callback(this.element, value), this.lastValue = value)
        },
        registerFormCallbacks: function() {
            Form.getElements(this.element).each(this.registerCallback, this)
        },
        registerCallback: function(element) {
            if (element.type) switch (element.type.toLowerCase()) {
                case "checkbox":
                case "radio":
                    Event.observe(element, "click", this.onElementEvent.bind(this));
                    break;
                default:
                    Event.observe(element, "change", this.onElementEvent.bind(this))
            }
        }
    }), Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
        getValue: function() {
            return Form.Element.getValue(this.element)
        }
    }), Form.EventObserver = Class.create(Abstract.EventObserver, {
        getValue: function() {
            return Form.serialize(this.element)
        }
    }),
    function(GLOBAL) {
        function _isButtonForDOMEvents(event, code) {
            return event.which ? event.which === code + 1 : event.button === code
        }

        function _isButtonForLegacyEvents(event, code) {
            return event.button === legacyButtonMap[code]
        }

        function _isButtonForWebKit(event, code) {
            switch (code) {
                case 0:
                    return 1 == event.which && !event.metaKey;
                case 1:
                    return 2 == event.which || 1 == event.which && event.metaKey;
                case 2:
                    return 3 == event.which;
                default:
                    return !1
            }
        }

        function isLeftClick(event) {
            return _isButton(event, 0)
        }

        function isMiddleClick(event) {
            return _isButton(event, 1)
        }

        function isRightClick(event) {
            return _isButton(event, 2)
        }

        function element(event) {
            return Element.extend(_element(event))
        }

        function _element(event) {
            event = Event.extend(event);
            var node = event.target,
                type = event.type,
                currentTarget = event.currentTarget;
            return currentTarget && currentTarget.tagName && ("load" === type || "error" === type || "click" === type && "input" === currentTarget.tagName.toLowerCase() && "radio" === currentTarget.type) && (node = currentTarget), node.nodeType == Node.TEXT_NODE ? node.parentNode : node
        }

        function findElement(event, expression) {
            var element = _element(event),
                selector = Prototype.Selector;
            if (!expression) return Element.extend(element);
            for (; element;) {
                if (Object.isElement(element) && selector.match(element, expression)) return Element.extend(element);
                element = element.parentNode
            }
        }

        function pointer(event) {
            return {
                x: pointerX(event),
                y: pointerY(event)
            }
        }

        function pointerX(event) {
            var docElement = document.documentElement,
                body = document.body || {
                    scrollLeft: 0
                };
            return event.pageX || event.clientX + (docElement.scrollLeft || body.scrollLeft) - (docElement.clientLeft || 0)
        }

        function pointerY(event) {
            var docElement = document.documentElement,
                body = document.body || {
                    scrollTop: 0
                };
            return event.pageY || event.clientY + (docElement.scrollTop || body.scrollTop) - (docElement.clientTop || 0)
        }

        function stop(event) {
            Event.extend(event), event.preventDefault(), event.stopPropagation(), event.stopped = !0
        }

        function _relatedTarget(event) {
            var element;
            switch (event.type) {
                case "mouseover":
                case "mouseenter":
                    element = event.fromElement;
                    break;
                case "mouseout":
                case "mouseleave":
                    element = event.toElement;
                    break;
                default:
                    return null
            }
            return Element.extend(element)
        }

        function getDOMEventName(eventName) {
            return EVENT_TRANSLATIONS[eventName] || eventName
        }

        function getUniqueElementID(element) {
            return element === window ? 0 : ("undefined" == typeof element._prototypeUID && (element._prototypeUID = Element.Storage.UID++), element._prototypeUID)
        }

        function getUniqueElementID_IE(element) {
            return element === window ? 0 : element == document ? 1 : element.uniqueID
        }

        function isCustomEvent(eventName) {
            return eventName.include(":")
        }

        function getRegistryForElement(element, uid) {
            var CACHE = GLOBAL.Event.cache;
            return Object.isUndefined(uid) && (uid = getUniqueElementID(element)), CACHE[uid] || (CACHE[uid] = {
                element: element
            }), CACHE[uid]
        }

        function destroyRegistryForElement(element, uid) {
            Object.isUndefined(uid) && (uid = getUniqueElementID(element)), delete GLOBAL.Event.cache[uid]
        }

        function register(element, eventName, handler) {
            var registry = getRegistryForElement(element);
            registry[eventName] || (registry[eventName] = []);
            for (var entries = registry[eventName], i = entries.length; i--;)
                if (entries[i].handler === handler) return null;
            var uid = getUniqueElementID(element),
                responder = GLOBAL.Event._createResponder(uid, eventName, handler),
                entry = {
                    responder: responder,
                    handler: handler
                };
            return entries.push(entry), entry
        }

        function unregister(element, eventName, handler) {
            var registry = getRegistryForElement(element),
                entries = registry[eventName];
            if (entries) {
                for (var entry, i = entries.length; i--;)
                    if (entries[i].handler === handler) {
                        entry = entries[i];
                        break
                    }
                if (entry) {
                    var index = entries.indexOf(entry);
                    return entries.splice(index, 1), entry
                }
            }
        }

        function observe(element, eventName, handler) {
            element = $(element);
            var entry = register(element, eventName, handler);
            if (null === entry) return element;
            var responder = entry.responder;
            return isCustomEvent(eventName) ? observeCustomEvent(element, eventName, responder) : observeStandardEvent(element, eventName, responder), element
        }

        function observeStandardEvent(element, eventName, responder) {
            var actualEventName = getDOMEventName(eventName);
            element.addEventListener ? element.addEventListener(actualEventName, responder, !1) : element.attachEvent("on" + actualEventName, responder)
        }

        function observeCustomEvent(element, eventName, responder) {
            element.addEventListener ? element.addEventListener("dataavailable", responder, !1) : (element.attachEvent("ondataavailable", responder), element.attachEvent("onlosecapture", responder))
        }

        function stopObserving(element, eventName, handler) {
            element = $(element);
            var handlerGiven = !Object.isUndefined(handler),
                eventNameGiven = !Object.isUndefined(eventName);
            if (!eventNameGiven && !handlerGiven) return stopObservingElement(element), element;
            if (!handlerGiven) return stopObservingEventName(element, eventName), element;
            var entry = unregister(element, eventName, handler);
            return entry ? (removeEvent(element, eventName, entry.responder), element) : element
        }

        function stopObservingStandardEvent(element, eventName, responder) {
            var actualEventName = getDOMEventName(eventName);
            element.removeEventListener ? element.removeEventListener(actualEventName, responder, !1) : element.detachEvent("on" + actualEventName, responder)
        }

        function stopObservingCustomEvent(element, eventName, responder) {
            element.removeEventListener ? element.removeEventListener("dataavailable", responder, !1) : (element.detachEvent("ondataavailable", responder), element.detachEvent("onlosecapture", responder))
        }

        function stopObservingElement(element) {
            var uid = getUniqueElementID(element),
                registry = GLOBAL.Event.cache[uid];
            if (registry) {
                destroyRegistryForElement(element, uid);
                var entries, i;
                for (var eventName in registry)
                    if ("element" !== eventName)
                        for (entries = registry[eventName], i = entries.length; i--;) removeEvent(element, eventName, entries[i].responder)
            }
        }

        function stopObservingEventName(element, eventName) {
            var registry = getRegistryForElement(element),
                entries = registry[eventName];
            if (entries) {
                delete registry[eventName];
                for (var i = entries.length; i--;) removeEvent(element, eventName, entries[i].responder)
            }
        }

        function removeEvent(element, eventName, handler) {
            isCustomEvent(eventName) ? stopObservingCustomEvent(element, eventName, handler) : stopObservingStandardEvent(element, eventName, handler)
        }

        function getFireTarget(element) {
            return element !== document ? element : document.createEvent && !element.dispatchEvent ? document.documentElement : element
        }

        function fire(element, eventName, memo, bubble) {
            element = getFireTarget($(element)), Object.isUndefined(bubble) && (bubble = !0), memo = memo || {};
            var event = fireEvent(element, eventName, memo, bubble);
            return Event.extend(event)
        }

        function fireEvent_DOM(element, eventName, memo, bubble) {
            var event = document.createEvent("HTMLEvents");
            return event.initEvent("dataavailable", bubble, !0), event.eventName = eventName, event.memo = memo, element.dispatchEvent(event), event
        }

        function fireEvent_IE(element, eventName, memo, bubble) {
            var event = document.createEventObject();
            return event.eventType = bubble ? "ondataavailable" : "onlosecapture", event.eventName = eventName, event.memo = memo, element.fireEvent(event.eventType, event), event
        }

        function on(element, eventName, selector, callback) {
            return element = $(element), Object.isFunction(selector) && Object.isUndefined(callback) && (callback = selector, selector = null), new Event.Handler(element, eventName, selector, callback).start()
        }

        function destroyCache_IE() {
            GLOBAL.Event.cache = null
        }
        var DIV = document.createElement("div"),
            docEl = document.documentElement,
            MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = "onmouseenter" in docEl && "onmouseleave" in docEl,
            Event = {
                KEY_BACKSPACE: 8,
                KEY_TAB: 9,
                KEY_RETURN: 13,
                KEY_ESC: 27,
                KEY_LEFT: 37,
                KEY_UP: 38,
                KEY_RIGHT: 39,
                KEY_DOWN: 40,
                KEY_DELETE: 46,
                KEY_HOME: 36,
                KEY_END: 35,
                KEY_PAGEUP: 33,
                KEY_PAGEDOWN: 34,
                KEY_INSERT: 45
            },
            isIELegacyEvent = function() {
                return !1
            };
        window.attachEvent && (isIELegacyEvent = window.addEventListener ? function(event) {
            return !(event instanceof window.Event)
        } : function() {
            return !0
        });
        var _isButton, legacyButtonMap = {
            0: 1,
            1: 4,
            2: 2
        };
        _isButton = window.attachEvent ? window.addEventListener ? function(event, code) {
            return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) : _isButtonForDOMEvents(event, code)
        } : _isButtonForLegacyEvents : Prototype.Browser.WebKit ? _isButtonForWebKit : _isButtonForDOMEvents, Event.Methods = {
            isLeftClick: isLeftClick,
            isMiddleClick: isMiddleClick,
            isRightClick: isRightClick,
            element: element,
            findElement: findElement,
            pointer: pointer,
            pointerX: pointerX,
            pointerY: pointerY,
            stop: stop
        };
        var methods = Object.keys(Event.Methods).inject({}, function(m, name) {
            return m[name] = Event.Methods[name].methodize(), m
        });
        if (window.attachEvent) {
            var additionalMethods = {
                stopPropagation: function() {
                    this.cancelBubble = !0
                },
                preventDefault: function() {
                    this.returnValue = !1
                },
                inspect: function() {
                    return "[object Event]"
                }
            };
            Event.extend = function(event, element) {
                if (!event) return !1;
                if (!isIELegacyEvent(event)) return event;
                if (event._extendedByPrototype) return event;
                event._extendedByPrototype = Prototype.emptyFunction;
                var pointer = Event.pointer(event);
                return Object.extend(event, {
                    target: event.srcElement || element,
                    relatedTarget: _relatedTarget(event),
                    pageX: pointer.x,
                    pageY: pointer.y
                }), Object.extend(event, methods), Object.extend(event, additionalMethods), event
            }
        } else Event.extend = Prototype.K;
        window.addEventListener && (Event.prototype = window.Event.prototype || document.createEvent("HTMLEvents").__proto__, Object.extend(Event.prototype, methods));
        var EVENT_TRANSLATIONS = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        };
        MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED && (getDOMEventName = Prototype.K), "uniqueID" in DIV && (getUniqueElementID = getUniqueElementID_IE), Event._isCustomEvent = isCustomEvent;
        var fireEvent = document.createEvent ? fireEvent_DOM : fireEvent_IE;
        Event.Handler = Class.create({
            initialize: function(element, eventName, selector, callback) {
                this.element = $(element), this.eventName = eventName, this.selector = selector, this.callback = callback, this.handler = this.handleEvent.bind(this)
            },
            start: function() {
                return Event.observe(this.element, this.eventName, this.handler), this
            },
            stop: function() {
                return Event.stopObserving(this.element, this.eventName, this.handler), this
            },
            handleEvent: function(event) {
                var element = Event.findElement(event, this.selector);
                element && this.callback.call(this.element, event, element)
            }
        }), Object.extend(Event, Event.Methods), Object.extend(Event, {
            fire: fire,
            observe: observe,
            stopObserving: stopObserving,
            on: on
        }), Element.addMethods({
            fire: fire,
            observe: observe,
            stopObserving: stopObserving,
            on: on
        }), Object.extend(document, {
            fire: fire.methodize(),
            observe: observe.methodize(),
            stopObserving: stopObserving.methodize(),
            on: on.methodize(),
            loaded: !1
        }), GLOBAL.Event ? Object.extend(window.Event, Event) : GLOBAL.Event = Event, GLOBAL.Event.cache = {}, window.attachEvent && window.attachEvent("onunload", destroyCache_IE), DIV = null, docEl = null
    }(this),
    function(GLOBAL) {
        function isSimulatedMouseEnterLeaveEvent(eventName) {
            return !MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED && ("mouseenter" === eventName || "mouseleave" === eventName)
        }

        function createResponder(uid, eventName, handler) {
            return Event._isCustomEvent(eventName) ? createResponderForCustomEvent(uid, eventName, handler) : isSimulatedMouseEnterLeaveEvent(eventName) ? createMouseEnterLeaveResponder(uid, eventName, handler) : function(event) {
                if (Event.cache) {
                    var element = Event.cache[uid].element;
                    Event.extend(event, element), handler.call(element, event)
                }
            }
        }

        function createResponderForCustomEvent(uid, eventName, handler) {
            return function(event) {
                var element = Event.cache[uid].element;
                return Object.isUndefined(event.eventName) ? !1 : event.eventName !== eventName ? !1 : (Event.extend(event, element), handler.call(element, event), void 0)
            }
        }

        function createMouseEnterLeaveResponder(uid, eventName, handler) {
            return function(event) {
                var element = Event.cache[uid].element;
                Event.extend(event, element);
                for (var parent = event.relatedTarget; parent && parent !== element;) try {
                    parent = parent.parentNode
                } catch (e) {
                    parent = element
                }
                parent !== element && handler.call(element, event)
            }
        }
        var docEl = document.documentElement,
            MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = "onmouseenter" in docEl && "onmouseleave" in docEl;
        GLOBAL.Event._createResponder = createResponder, docEl = null
    }(this),
    function() {
        function fireContentLoadedEvent() {
            document.loaded || (TIMER && window.clearTimeout(TIMER), document.loaded = !0, document.fire("dom:loaded"))
        }

        function checkReadyState() {
            "complete" === document.readyState && (document.detachEvent("onreadystatechange", checkReadyState), fireContentLoadedEvent())
        }

        function pollDoScroll() {
            try {
                document.documentElement.doScroll("left")
            } catch (e) {
                return TIMER = pollDoScroll.defer(), void 0
            }
            fireContentLoadedEvent()
        }
        var TIMER;
        return "complete" === document.readyState ? (fireContentLoadedEvent(), void 0) : (document.addEventListener ? document.addEventListener("DOMContentLoaded", fireContentLoadedEvent, !1) : (document.attachEvent("onreadystatechange", checkReadyState), window == top && (TIMER = pollDoScroll.defer())), Event.observe(window, "load", fireContentLoadedEvent), void 0)
    }(this), Element.addMethods(), Hash.toQueryString = Object.toQueryString;
var Toggle = {
    display: Element.toggle
};
Element.Methods.childOf = Element.Methods.descendantOf;
var Insertion = {
        Before: function(element, content) {
            return Element.insert(element, {
                before: content
            })
        },
        Top: function(element, content) {
            return Element.insert(element, {
                top: content
            })
        },
        Bottom: function(element, content) {
            return Element.insert(element, {
                bottom: content
            })
        },
        After: function(element, content) {
            return Element.insert(element, {
                after: content
            })
        }
    },
    $continue = new Error('"throw $continue" is deprecated, use "return" instead'),
    Position = {
        includeScrollOffsets: !1,
        prepare: function() {
            this.deltaX = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0, this.deltaY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
        },
        within: function(element, x, y) {
            return this.includeScrollOffsets ? this.withinIncludingScrolloffsets(element, x, y) : (this.xcomp = x, this.ycomp = y, this.offset = Element.cumulativeOffset(element), y >= this.offset[1] && y < this.offset[1] + element.offsetHeight && x >= this.offset[0] && x < this.offset[0] + element.offsetWidth)
        },
        withinIncludingScrolloffsets: function(element, x, y) {
            var offsetcache = Element.cumulativeScrollOffset(element);
            return this.xcomp = x + offsetcache[0] - this.deltaX, this.ycomp = y + offsetcache[1] - this.deltaY, this.offset = Element.cumulativeOffset(element), this.ycomp >= this.offset[1] && this.ycomp < this.offset[1] + element.offsetHeight && this.xcomp >= this.offset[0] && this.xcomp < this.offset[0] + element.offsetWidth
        },
        overlap: function(mode, element) {
            return mode ? "vertical" == mode ? (this.offset[1] + element.offsetHeight - this.ycomp) / element.offsetHeight : "horizontal" == mode ? (this.offset[0] + element.offsetWidth - this.xcomp) / element.offsetWidth : void 0 : 0
        },
        cumulativeOffset: Element.Methods.cumulativeOffset,
        positionedOffset: Element.Methods.positionedOffset,
        absolutize: function(element) {
            return Position.prepare(), Element.absolutize(element)
        },
        relativize: function(element) {
            return Position.prepare(), Element.relativize(element)
        },
        realOffset: Element.Methods.cumulativeScrollOffset,
        offsetParent: Element.Methods.getOffsetParent,
        page: Element.Methods.viewportOffset,
        clone: function(source, target, options) {
            return options = options || {}, Element.clonePosition(target, source, options)
        }
    };
if (document.getElementsByClassName || (document.getElementsByClassName = function(instanceMethods) {
        function iter(name) {
            return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]"
        }
        return instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ? function(element, className) {
                className = className.toString().strip();
                var cond = /\s/.test(className) ? $w(className).map(iter).join("") : iter(className);
                return cond ? document._getElementsByXPath(".//*" + cond, element) : []
            } : function(element, className) {
                className = className.toString().strip();
                var elements = [],
                    classNames = /\s/.test(className) ? $w(className) : null;
                if (!classNames && !className) return elements;
                var nodes = $(element).getElementsByTagName("*");
                className = " " + className + " ";
                for (var child, cn, i = 0; child = nodes[i]; i++) child.className && (cn = " " + child.className + " ") && (cn.include(className) || classNames && classNames.all(function(name) {
                    return !name.toString().blank() && cn.include(" " + name + " ")
                })) && elements.push(Element.extend(child));
                return elements
            },
            function(className, parentElement) {
                return $(parentElement || document.body).getElementsByClassName(className)
            }
    }(Element.Methods)), Element.ClassNames = Class.create(), Element.ClassNames.prototype = {
        initialize: function(element) {
            this.element = $(element)
        },
        _each: function(iterator, context) {
            this.element.className.split(/\s+/).select(function(name) {
                return name.length > 0
            })._each(iterator, context)
        },
        set: function(className) {
            this.element.className = className
        },
        add: function(classNameToAdd) {
            this.include(classNameToAdd) || this.set($A(this).concat(classNameToAdd).join(" "))
        },
        remove: function(classNameToRemove) {
            this.include(classNameToRemove) && this.set($A(this).without(classNameToRemove).join(" "))
        },
        toString: function() {
            return $A(this).join(" ")
        }
    }, Object.extend(Element.ClassNames.prototype, Enumerable), function() {
        window.Selector = Class.create({
            initialize: function(expression) {
                this.expression = expression.strip()
            },
            findElements: function(rootElement) {
                return Prototype.Selector.select(this.expression, rootElement)
            },
            match: function(element) {
                return Prototype.Selector.match(element, this.expression)
            },
            toString: function() {
                return this.expression
            },
            inspect: function() {
                return "#<Selector: " + this.expression + ">"
            }
        }), Object.extend(Selector, {
            matchElements: function(elements, expression) {
                for (var match = Prototype.Selector.match, results = [], i = 0, length = elements.length; length > i; i++) {
                    var element = elements[i];
                    match(element, expression) && results.push(Element.extend(element))
                }
                return results
            },
            findElement: function(elements, expression, index) {
                index = index || 0;
                for (var element, matchIndex = 0, i = 0, length = elements.length; length > i; i++)
                    if (element = elements[i], Prototype.Selector.match(element, expression) && index === matchIndex++) return Element.extend(element)
            },
            findChildElements: function(element, expressions) {
                var selector = expressions.toArray().join(", ");
                return Prototype.Selector.select(selector, element || document)
            }
        })
    }(), !window.module) {
    window.module = function(dottedPath) {
        if ("" == dottedPath) return window;
        var path = dottedPath.split("."),
            name = path.pop(),
            parent = module(path.join("."));
        return parent[name] || (parent[name] = {
            requires: function() {
                return this
            },
            toRun: function(code) {
                code()
            },
            uri: function() {}
        }), parent[name]
    }, JSLoader = {
        loadJs: function() {}
    }, window.URL = {}, window.Properties = {
        all: function(object, predicate) {
            var a = [];
            for (var name in object) !object.__lookupGetter__(name) && Object.isFunction(object[name]) || (predicate ? !predicate(name, object) : 0) || a.push(name);
            return a
        },
        allOwnPropertiesOrFunctions: function(obj, predicate) {
            var result = [];
            return Object.getOwnPropertyNames(obj).forEach(function(name) {
                predicate(obj, name) && result.push(name)
            }), result
        },
        own: function(object) {
            var a = [];
            for (var name in object) !object.hasOwnProperty(name) || !object.__lookupGetter__(name) && Object.isFunction(object[name]) || a.push(name);
            return a
        },
        forEachOwn: function(object, func, context) {
            var result = [];
            for (var name in object)
                if (object.hasOwnProperty(name)) {
                    var value = object[name];
                    Object.isFunction(value) || result.push(func.call(context || this, name, value))
                }
            return result
        },
        nameFor: function(object, value) {
            for (var name in object)
                if (object[name] === value) return name;
            return void 0
        },
        values: function(obj) {
            var values = [];
            for (var name in obj) values.push(obj[name]);
            return values
        },
        ownValues: function(obj) {
            var values = [];
            for (var name in obj) obj.hasOwnProperty(name) && values.push(obj[name]);
            return values
        },
        printObjectSize: function(obj) {
            return Numbers.humanReadableByteSize(JSON.stringify(obj).length)
        },
        any: function(obj, predicate) {
            for (var name in obj)
                if (predicate(obj, name)) return !0;
            return !1
        },
        allProperties: function(obj, predicate) {
            var result = [];
            for (var name in obj) predicate(obj, name) && result.push(name);
            return result
        },
        hash: function(obj) {
            return Object.keys(obj).sort().join("").hashCode()
        }
    }, window.Config = {}, window.cop = {}, window.Global = window;
    var Module = function() {
        return null
    };
    window.lively = new Module, lively.Class = Class, lively.Module = Module, window.dbgOn = function(b) {}, Object.extend(Class, {
        isClass: function(object) {
            return object === Object || object === Array || object === Function || object === String || object === Boolean || object === Date || object === RegExp || object === Number ? !0 : object instanceof Function && void 0 !== object.superclass
        },
        namespaceFor: function(className) {
            var lastDot = className.lastIndexOf(".");
            return 0 > lastDot ? window : namespace(className.substring(0, lastDot))
        },
        unqualifiedNameFor: function(name) {
            var lastDot = name.lastIndexOf("."),
                unqualifiedName = name.substring(lastDot + 1);
            return unqualifiedName
        }
    }), Object.extend(Function.prototype, {
        subclass: function() {
            var args = $A(arguments),
                className = args.shift(),
                targetScope = Global,
                shortName = null;
            className ? (targetScope = lively.Class.namespaceFor(className), shortName = lively.Class.unqualifiedNameFor(className)) : (shortName = "anonymous_" + lively.Class.anonymousCounter++, className = shortName);
            var klass;
            if (className && targetScope[shortName] && targetScope[shortName].superclass === this) klass = targetScope[shortName];
            else {
                klass = function() {
                    return this.initialize && this.initialize.apply(this, arguments), this
                }, klass.name = shortName, klass.superclass = this;
                var protoclass = function() {};
                protoclass.prototype = this.prototype, klass.prototype = new protoclass, klass.prototype.constructor = klass, klass.prototype.constructor.type = className, klass.prototype.constructor.displayName = className, className && (targetScope[shortName] = klass), Global.lively && lively.Module && lively.Module.current && (klass.sourceModule = lively.Module.current())
            }
            return this.addMethods.apply(klass, args), klass.prototype.initialize || (klass.prototype.initialize = function() {}), klass
        },
        addMethods: function() {
            for (var args = arguments, i = 0; i < args.length; i++) Object.isString(args[i]) || this.addCategorizedMethods(args[i] instanceof Function ? args[i]() : args[i])
        },
        addCategorizedMethods: function(source) {
            var ancestor = this.superclass && this.superclass.prototype,
                className = this.type || "Anonymous";
            for (var property in source)
                if ("constructor" != property) {
                    var getter = source.__lookupGetter__(property);
                    getter && this.prototype.__defineGetter__(property, getter);
                    var setter = source.__lookupSetter__(property);
                    if (setter && this.prototype.__defineSetter__(property, setter), !getter && !setter) {
                        var value = source[property],
                            hasSuperCall = ancestor && Object.isFunction(value) && value.argumentNames && "$super" == value.argumentNames().first();
                        if (hasSuperCall && ! function() {
                                var method = value,
                                    advice = function(m) {
                                        return function() {
                                            var method = ancestor[m];
                                            if (!method) throw new Error(Strings.format("Trying to call super of %s>>%s but no super method in %s", className, m, ancestor.constructor.type));
                                            return method.apply(this, arguments)
                                        }
                                    }(property);
                                advice.methodName = "$super:" + (this.superclass ? this.superclass.type + ">>" : "") + property, value = Object.extend(advice.wrap(method), {
                                    valueOf: function() {
                                        return method
                                    },
                                    toString: function() {
                                        return method.toString()
                                    },
                                    originalFunction: method
                                }), method.varMapping = {
                                    $super: advice
                                }
                            }(), this.prototype[property] = value, Object.isFunction(value))
                            for (value.displayName = className + "$" + property; value; value = value.originalFunction) value.declaredClass = this.prototype.constructor.type, value.methodName = property
                    }
                }
            return this
        },
        binds: function() {
            return this
        },
        getVarMapping: function() {
            return this.varMapping
        }
    });
    for (var lutUUID = [], i = 0; 256 > i; i++) lutUUID[i] = (16 > i ? "0" : "") + i.toString(16);
    window.Strings = {
        newUUID: function() {
            var d0 = 0 | 4294967295 * Math.random(),
                d1 = 0 | 4294967295 * Math.random(),
                d2 = 0 | 4294967295 * Math.random(),
                d3 = 0 | 4294967295 * Math.random();
            return lutUUID[255 & d0] + lutUUID[255 & d0 >> 8] + lutUUID[255 & d0 >> 16] + lutUUID[255 & d0 >> 24] + "-" + lutUUID[255 & d1] + lutUUID[255 & d1 >> 8] + "-" + lutUUID[64 | 15 & d1 >> 16] + lutUUID[255 & d1 >> 24] + "-" + lutUUID[128 | 63 & d2] + lutUUID[255 & d2 >> 8] + "-" + lutUUID[255 & d2 >> 16] + lutUUID[255 & d2 >> 24] + lutUUID[255 & d3] + lutUUID[255 & d3 >> 8] + lutUUID[255 & d3 >> 16] + lutUUID[255 & d3 >> 24]
        },
        format: function() {
            return Strings.formatFromArray(Array.from(arguments))
        },
        formatFromArray: function(objects) {
            function appendText(object) {
                return "" + object
            }

            function appendInteger(value) {
                return value.toString()
            }

            function appendFloat(value, string, precision) {
                return precision > -1 ? value.toFixed(precision) : value.toString()
            }

            function appendObject(value) {
                return Objects.inspect(value)
            }

            function parseFormat(fmt) {
                for (var parts = [], m = reg.exec(fmt); m; m = reg.exec(fmt)) {
                    var type = m[8] || m[5],
                        appender = type in appenderMap ? appenderMap[type] : appendObject,
                        precision = m[3] ? parseInt(m[3]) : "." == m[4] ? -1 : 0;
                    parts.push(fmt.substr(0, "%" == m[0][0] ? m.index : m.index + 1)), parts.push({
                        appender: appender,
                        precision: precision
                    }), fmt = fmt.substr(m.index + m[0].length)
                }
                return fmt && parts.push(fmt.toString()), parts
            }
            var self = objects.shift();
            self || console.log("Error in Strings>>formatFromArray, arg1 undefined");
            for (var appenderMap = {
                    s: appendText,
                    d: appendInteger,
                    i: appendInteger,
                    f: appendFloat,
                    o: appendObject
                }, reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/, parts = parseFormat(self), str = "", objIndex = 0, i = 0; i < parts.length; ++i) {
                var part = parts[i];
                if (part && "object" == typeof part) {
                    var object = objects[objIndex++];
                    str += (part.appender || appendText)(object, str, part.precision)
                } else str += appendText(part, str)
            }
            return str
        }
    }, Array.prototype.removeAt = function(idx) {
        this.splice(idx, 1)
    }, Array.prototype.remove = function(obj) {
        var idx = this.indexOf(obj);
        idx >= 0 && this.removeAt(idx)
    }, Array.range = function(begin, end, step) {
        step = step || 1;
        for (var result = [], i = begin; end >= i; i += step) result.push(i);
        return result
    }, Array.prototype.equals = function(otherArray) {
        var len = this.length;
        if (!otherArray || len !== otherArray.length) return !1;
        for (var i = 0; len > i; i++) {
            if (this[i] && otherArray[i] && this[i].equals && otherArray[i].equals) {
                if (this[i].equals(otherArray[i])) continue;
                return !1
            }
            if (this[i] != otherArray[i]) return !1
        }
        return !0
    }, "undefined" == typeof Set && (Global.Set = function() {
        throw "Set not supported"
    }), window.alertOK = function(msg) {
        console.log(msg)
    }
}
module("cop.Layers").requires().toRun(function() {
    Config.ignoredepricatedProceed = !0;
    var log_layer_code = !1;
    Object.extend(cop, {
        dynamicInlining: Config.copDynamicInlining && !document.URL.include("noDynamicInlining"),
        staticInlining: !1,
        proceedStack: [],
        GlobalLayers: [],
        object_id_counter: 0
    }), Object.extend(cop, {
        withLogLayerCode: function(func) {
            try {
                var old = log_layer_code;
                log_layer_code = !0, func()
            } finally {
                log_layer_code = old
            }
        },
        getLayerDefinitionForObject: function(layer, object) {
            if (layer && object) {
                var result = layer[object._layer_object_id];
                return result ? result : cop.getLayerDefinitionForObject(layer, object.prototype)
            }
        },
        ensurePartialLayer: function(layer, object) {
            if (!layer) throw new Error("in ensurePartialLayer: layer is nil");
            return object.hasOwnProperty("_layer_object_id") || (object._layer_object_id = cop.object_id_counter++), layer[object._layer_object_id] || (layer[object._layer_object_id] = {
                _layered_object: object
            }), layer[object._layer_object_id]
        },
        layerMethod: function(layer, object, property, func) {
            cop.ensurePartialLayer(layer, object)[property] = func, func.displayName = "layered " + layer.name + " " + (object.constructor ? object.constructor.type + "$" : "") + property, cop.makeFunctionLayerAware(object, property, layer.isHidden), Object.isFunction(object.getName) && (layer.layeredFunctionsList[object][property] = !0)
        },
        layerGetterMethod: function(layer, object, property, getter) {
            cop.ensurePartialLayer(layer, object).__defineGetter__(property, getter)
        },
        layerSetterMethod: function(layer, object, property, setter) {
            cop.ensurePartialLayer(layer, object).__defineSetter__(property, setter)
        },
        layerProperty: function(layer, object, property, defs) {
            var getter = defs.__lookupGetter__(property);
            getter && cop.layerGetterMethod(layer, object, property, getter);
            var setter = defs.__lookupSetter__(property);
            setter && cop.layerSetterMethod(layer, object, property, setter), getter || setter ? cop.makePropertyLayerAware(object, property) : cop.layerMethod(layer, object, property, defs[property])
        },
        layerPropertyWithShadow: function(layer, object, property) {
            var defs = {},
                baseValue = object[property],
                layeredPropName = "_layered_" + layer.getName() + "_" + property;
            defs.__defineGetter__(property, function() {
                return void 0 === this[layeredPropName] ? cop.proceed() : this[layeredPropName]
            }.binds({
                layeredPropName: layeredPropName,
                baseValue: baseValue
            })), defs.__defineSetter__(property, function(v) {
                this[layeredPropName] = v
            }.binds({
                layeredPropName: layeredPropName
            })), cop.layerProperty(layer, object, property, defs)
        },
        computeLayersFor: function(obj) {
            return obj && obj.activeLayers ? obj.activeLayers(cop.currentLayers) : cop.currentLayers()
        },
        composeLayers: function(stack) {
            for (var result = cop.GlobalLayers.clone(), i = 0; i < stack.length; i++) {
                var current = stack[i];
                current.withLayers ? result = result.without.apply(result, current.withLayers).concat(current.withLayers) : current.withoutLayers && (result = result.without.apply(result, current.withoutLayers))
            }
            return result
        },
        currentLayers: function() {
            if (0 == cop.LayerStack.length) throw new Error("The default layer is missing");
            var current = cop.LayerStack.last();
            return (!current.composition || cop.dynamicInlining && !current.composition.hash) && (current.composition = cop.composeLayers(cop.LayerStack), cop.dynamicInlining && (current.composition.hash = cop.computeHashForLayers(current.composition))), current.composition
        },
        invalidateLayerComposition: function() {
            cop.LayerStack.forEach(function(ea) {
                ea.composition = null
            })
        },
        resetLayerStack: function() {
            cop.LayerStack = [{
                isStatic: !0,
                toString: function() {
                    return "BaseLayer"
                },
                composition: null
            }], cop.invalidateLayerComposition()
        },
        lookupLayeredFunctionForObject: function(self, layer, function_name, methodType) {
            if (!layer) return void 0;
            var layered_function, layer_definition_for_object = cop.getLayerDefinitionForObject(layer, self);
            if (layer_definition_for_object && ("getter" == methodType ? layered_function = layer_definition_for_object.__lookupGetter__(function_name) : "setter" == methodType ? layered_function = layer_definition_for_object.__lookupSetter__(function_name) : layer_definition_for_object.hasOwnProperty(function_name) && (layered_function = layer_definition_for_object[function_name])), !layered_function) {
                var superclass = self.constructor.superclass;
                if (superclass) return foundClass = superclass, cop.lookupLayeredFunctionForObject(superclass.prototype, layer, function_name, methodType)
            }
            return layered_function
        },
        pvtMakeFunctionOrPropertyLayerAware: function(obj, slotName, baseValue, type, isHidden) {
            return baseValue.isLayerAware ? void 0 : cop.staticInlining ? cop.makeSlotLayerAwareWithStaticInlining(obj, slotName, baseValue, type) : cop.dynamicInlining ? cop.makeSlotLayerAwareWithDynamicInlining(obj, slotName, baseValue, type) : (cop.makeSlotLayerAwareWithNormalLookup(obj, slotName, baseValue, type, isHidden), void 0)
        },
        makeSlotLayerAwareWithNormalLookup: function(obj, slotName, baseValue, type, isHidden) {
            var wrapped_function = function() {
                var composition = new cop.PartialLayerComposition(this, obj, slotName, baseValue, type);
                cop.proceedStack.push(composition);
                try {
                    return cop.proceed.apply(this, arguments)
                } finally {
                    cop.proceedStack.pop()
                }
            };
            wrapped_function.isLayerAware = !0, wrapped_function.isContextJSWrapper = !0, isHidden && (wrapped_function.toString = function() {
                return this.getOriginal().toString()
            }), wrapped_function.originalFunction = baseValue, "getter" == type ? obj.__defineGetter__(slotName, wrapped_function) : "setter" == type ? obj.__defineSetter__(slotName, wrapped_function) : obj[slotName] = wrapped_function
        },
        makeFunctionLayerAware: function(base_obj, function_name, isHidden) {
            if (!base_obj) throw new Error("can't layer an non existent object");
            var base_function = base_obj[function_name];
            base_function || (base_function = function() {
                return null
            }), cop.pvtMakeFunctionOrPropertyLayerAware(base_obj, function_name, base_function, void 0, isHidden)
        },
        makePropertyLayerAware: function(baseObj, property) {
            if (!baseObj) throw new Error("can't layer an non existent object");
            var getter = baseObj.__lookupGetter__(property),
                propName = "__layered_" + property + "__";
            getter || (baseObj[propName] = baseObj[property], getter = function() {
                return this[propName]
            }.binds({
                propName: propName
            }), baseObj.__defineGetter__(property, getter));
            var setter = baseObj.__lookupSetter__(property);
            setter || (setter = function(value) {
                return this[propName] = value
            }.binds({
                propName: propName
            }), baseObj.__defineSetter__(property, setter)), cop.pvtMakeFunctionOrPropertyLayerAware(baseObj, property, getter, "getter"), cop.pvtMakeFunctionOrPropertyLayerAware(baseObj, property, setter, "setter")
        },
        makeFunctionLayerUnaware: function(base_obj, function_name) {
            if (!base_obj) throw new Error("need object to makeFunctionLayerUnaware");
            var prevFunction, currentFunction = base_obj[function_name];
            if (void 0 !== currentFunction) {
                for (;
                    "function" == typeof currentFunction.originalFunction && !currentFunction.isLayerAware;) {
                    var prevFunction = currentFunction;
                    currentFunction = currentFunction.originalFunction
                }
                if (currentFunction.isLayerAware) {
                    var originalFunction = currentFunction.originalFunction;
                    if (!(originalFunction instanceof Function)) throw new Error("makeFunctionLayerUnaware Error: no orignal function");
                    prevFunction instanceof Function ? prevFunction.originalFunction = originalFunction : base_obj[function_name] = originalFunction
                }
            }
        },
        uninstallLayersInObject: function(object) {
            Functions.own(object).forEach(function(ea) {
                cop.makeFunctionLayerUnaware(object, ea)
            })
        },
        uninstallLayersInAllClasses: function() {
            Global.classes(!0).forEach(function(ea) {
                cop.uninstallLayersInObject(ea.prototype)
            })
        },
        allLayers: function(optObject) {
            return Object.values(optObject || Global).select(function(ea) {
                return ea instanceof Layer
            })
        }
    }), Object.extend(cop, {
        create: function(name) {
            var context = lively.Class.namespaceFor(name),
                layerName = lively.Class.unqualifiedNameFor(name);
            return context[layerName] = cop.basicCreate(layerName, context)
        },
        basicCreate: function(layerName, context) {
            return context = context || Global, context[layerName] || new Layer(layerName, context.namespaceIdentifier)
        },
        layer: function(name) {
            return console.log("SyntaxDepricated: cop.layer(... use cop.create("), cop.create(name, !0)
        },
        createLayer: function(name) {
            return console.log("SyntaxDepricated: cop.createLayer(... use cop.create("), cop.create(name, !1)
        },
        layerObject: function(layer, object, defs) {
            Object.isFunction(object.getName) && (layer.layeredFunctionsList[object] = {}), Object.keys(defs).forEach(function(function_name) {
                cop.layerProperty(layer, object, function_name, defs)
            })
        },
        layerClass: function(layer, classObject, defs) {
            if (!classObject || !classObject.prototype) throw new Error("ContextJS: can not refine class '" + classObject + "' in " + layer);
            cop.layerObject(layer, classObject.prototype, defs)
        },
        layerClassAndSubclasses: function(layer, classObject, defs) {
            cop.layerClass(layer, classObject, defs), classObject.allSubclasses().forEach(function(eaClass) {
                var obj = eaClass.prototype;
                Object.keys(defs).forEach(function(eaFunctionName) {
                    obj.hasOwnProperty(eaFunctionName) && obj[eaFunctionName] instanceof Function && cop.makeFunctionLayerAware(obj, eaFunctionName)
                })
            })
        },
        withLayers: function(layers, func) {
            cop.LayerStack.push({
                withLayers: layers
            });
            try {
                return func()
            } finally {
                cop.LayerStack.pop()
            }
        },
        withoutLayers: function(layers, func) {
            cop.LayerStack.push({
                withoutLayers: layers
            });
            try {
                return func()
            } finally {
                cop.LayerStack.pop()
            }
        },
        enableLayer: function(layer) {
            cop.GlobalLayers.include(layer) || (cop.GlobalLayers.push(layer), cop.invalidateLayerComposition())
        },
        disableLayer: function(layer) {
            var idx = cop.GlobalLayers.indexOf(layer);
            0 > idx || (cop.GlobalLayers.removeAt(idx), cop.invalidateLayerComposition())
        },
        proceed: function() {
            var composition = cop.proceedStack.last();
            if (!composition) return console.log("ContextJS: no composition to proceed (stack is empty) "), void 0;
            void 0 == composition.partialMethodIndex && (composition.partialMethodIndex = composition.partialMethods.length - 1);
            var index = composition.partialMethodIndex,
                partialMethod = composition.partialMethods[index];
            if (partialMethod) {
                try {
                    if (composition.partialMethodIndex = index - 1, !Config.ignoredepricatedProceed && partialMethod.toString().match(/^[\t ]*function ?\(\$?proceed/)) {
                        var args = $A(arguments);
                        args.unshift(cop.proceed);
                        var msg = "proceed in arguments list in " + composition.functionName;
                        if (Config.throwErrorOnDepricated) throw new Error("DEPRICATED ERROR: " + msg);
                        Config.logDepricated && console.log("DEPRICATED WARNING: " + msg);
                        var result = partialMethod.apply(composition.object, args)
                    } else var result = partialMethod.apply(composition.object, arguments)
                } finally {
                    composition.partialMethodIndex = index
                }
                return result
            }
            if (!partialMethod) throw new COPError("no partialMethod to proceed")
        }
    });
    var markNamespaceEntryAsDepricated = function(newNamespace, newName, oldNamespace, oldName) {
        oldNamespace[oldName] = newNamespace[newName].wrap(function(proceed) {
            if (Config.throwErrorOnDepricated) throw new Error("DEPRICATED ERROR: " + oldName + " is depricated");
            Config.logDepricated && console.log("DEPRICATED WARNING: " + oldName + " is depricated");
            var args = $A(arguments);
            return args.shift(), proceed.apply(this, args)
        })
    };
    markNamespaceEntryAsDepricated(cop, "enableLayer", Global, "enableLayer"), markNamespaceEntryAsDepricated(cop, "disableLayer", Global, "disableLayer"), markNamespaceEntryAsDepricated(cop, "withLayers", Global, "withLayers"), markNamespaceEntryAsDepricated(cop, "withoutLayers", Global, "withoutLayers"), markNamespaceEntryAsDepricated(cop, "createLayer", Global, "createLayer"), markNamespaceEntryAsDepricated(cop, "layerObject", Global, "layerObject"), markNamespaceEntryAsDepricated(cop, "layerClass", Global, "layerClass"), markNamespaceEntryAsDepricated(cop, "layerClassAndSubclasses", Global, "layerClassAndSubclasses"), Object.subclass("Layer", "initializing", {
        initialize: function(name, namespaceName) {
            this.name = name, this.namespaceName = namespaceName || "Global", this.layeredFunctionsList = {}, Global.lively && lively.lang && lively.Module && (this.sourceModule = lively.Module.current())
        }
    }, "accessing", {
        getName: function() {
            return this.name
        },
        fullName: function() {
            return this.namespaceName + "." + this.getName()
        },
        layeredObjects: function() {
            return Properties.own(this).collect(function(ea) {
                return this[ea] && this[ea]._layered_object
            }, this).select(function(ea) {
                return ea
            })
        },
        layeredClasses: function() {
            return this.layeredObjects().collect(function(ea) {
                return ea.constructor
            }).select(function(ea) {
                return lively.Class.isClass(ea)
            })
        }
    }, "testing", {
        isGlobal: function() {
            return cop.GlobalLayers.include(this)
        }
    }, "removing", {
        remove: function() {
            this.isGlobal() && this.beNotGlobal();
            var ns = module(this.namespaceName);
            delete ns[this.name]
        },
        uninstall: function() {
            var layer = this;
            this.layeredObjects().each(function(eachLayeredObj) {
                var layerIdx = Object.isFunction(eachLayeredObj.activeLayers) ? eachLayeredObj.activeLayers().indexOf(layer) : -1;
                Properties.own(layer.layeredFunctionsList[eachLayeredObj]).each(function(eachLayeredFunc) {
                    var newerLayer = eachLayeredObj.activeLayers().find(function(eachOtherLayer) {
                        var eachOtherLayerIdx = eachLayeredObj.activeLayers().indexOf(eachOtherLayer),
                            isNewer = -1 !== eachOtherLayerIdx && layerIdx > eachOtherLayerIdx;
                        return isNewer && eachOtherLayer.layeredFunctionsList[eachLayeredObj][eachLayeredFunc]
                    });
                    newerLayer || cop.makeFunctionLayerUnaware(eachLayeredObj, eachLayeredFunc)
                })
            }), this.remove(), alertOK("Successfully uninstalled Layer " + this + " in Global Classes")
        }
    }, "layer installation", {
        layerClass: function(classObj, methods) {
            return cop.layerClass(this, classObj, methods), this
        },
        layerObject: function(obj, methods) {
            return cop.layerObject(this, obj, methods), this
        },
        refineClass: function(classObj, methods) {
            return cop.layerClass(this, classObj, methods), this
        },
        refineObject: function(obj, methods) {
            return cop.layerObject(this, obj, methods), this
        },
        unrefineObject: function(obj) {
            var id = obj._layer_object_id;
            void 0 !== id && delete this[id]
        },
        unrefineClass: function(classObj) {
            this.unrefineObject(classObj.prototype)
        }
    }, "layer activation", {
        beGlobal: function() {
            return cop.enableLayer(this), this
        },
        beNotGlobal: function() {
            return cop.disableLayer(this), this
        },
        hide: function() {
            return this.isHidden = !0, this
        }
    }, "debugging", {
        toString: function() {
            return this.getName()
        }
    }, "deprecated serialization", {
        toLiteral: function() {
            return this.name || console.warn("Layer: Can not serialize without a name!"), {
                name: this.name
            }
        }
    }), Object.extend(Layer, {
        fromLiteral: function(literal) {
            return cop.create(literal.name, !1)
        }
    }), Object.extend(Global, {
        LayerableObjectTrait: {}
    }), Object.extend(LayerableObjectTrait, {
        activeLayers: function() {
            var result = {
                withLayers: [],
                withoutLayers: []
            };
            return this.dynamicLayers(result), this.structuralLayers(result), this.globalLayers(result), result.withLayers
        },
        collectWithLayersIn: function(layers, result) {
            for (var i = 0; i < layers.length; i++) {
                var ea = layers[i]; - 1 === result.withLayers.indexOf(ea) && -1 === result.withoutLayers.indexOf(ea) && result.withLayers.unshift(ea)
            }
        },
        collectWithoutLayersIn: function(layers, result) {
            for (var i = 0; i < layers.length; i++) {
                var ea = layers[i]; - 1 === result.withoutLayers.indexOf(ea) && result.withoutLayers.push(ea)
            }
        },
        dynamicLayers: function(result) {
            for (var stack = cop.LayerStack, j = stack.length - 1; j > 0; j--) {
                var current = stack[j];
                current.withLayers && this.collectWithLayersIn(current.withLayers, result), current.withoutLayers && this.collectWithoutLayersIn(current.withoutLayers, result)
            }
            return result
        },
        structuralLayers: function(result) {
            for (var obj = (result.withLayers, result.withoutLayers, this); obj;) obj.withLayers && this.collectWithLayersIn(obj.withLayers, result), obj.withoutLayers && this.collectWithoutLayersIn(obj.withoutLayers, result), obj = obj.owner;
            return result
        },
        globalLayers: function(result) {
            return this.collectWithLayersIn(cop.GlobalLayers, result), result
        },
        setWithLayers: function(layers) {
            this.withLayers = layers
        },
        addWithLayer: function(layer) {
            var layers = this.getWithLayers();
            layers.include(layer) || this.setWithLayers(layers.concat([layer]))
        },
        removeWithLayer: function(layer) {
            var layers = this.getWithLayers();
            layers.include(layer) && this.setWithLayers(layers.without(layer))
        },
        addWithoutLayer: function(layer) {
            var layers = this.getWithoutLayers();
            layers.include(layer) || this.setWithoutLayers(layers.concat([layer]))
        },
        removeWithoutLayer: function(layer) {
            var layers = this.getWithoutLayers();
            this.setWithoutLayers(layers.without(layer))
        },
        setWithoutLayers: function(layers) {
            this.withoutLayers = layers
        },
        getWithLayers: function() {
            return this.withLayers || []
        },
        getWithoutLayers: function() {
            return this.withoutLayers || []
        }
    }), Object.subclass("LayerableObject", LayerableObjectTrait), Object.subclass("COPError", {
        initialize: function(msg) {
            this.msg = msg
        },
        toString: function() {
            return "COP Error: " + this.msg
        }
    }), Object.subclass("cop.PartialLayerComposition", {
        initialize: function(obj, prototypeObject, functionName, baseFunction, methodType) {
            this.partialMethods = [baseFunction];
            for (var layers = cop.computeLayersFor(obj), i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    partialMethod = cop.lookupLayeredFunctionForObject(obj, layer, functionName, methodType);
                partialMethod && this.partialMethods.push(partialMethod)
            }
            this.object = obj, this.prototypeObject = prototypeObject, this.functionName = functionName
        }
    }), Object.extend(Function.prototype, {
        subclass: Object.subclass.wrap(function(proceed) {
            var args = $A(arguments);
            args.shift();
            for (var layeredMethods = [], i = 1; i < args.length; i++) {
                var methods = args[i];
                Object.isString(methods) || Object.keys(methods).forEach(function(ea) {
                    var m = ea.match(/([A-Za-z0-9]+)\$([A-Za-z0-9]*)/);
                    if (m) {
                        var getter = methods.__lookupGetter__(m[0]),
                            setter = methods.__lookupSetter__(m[0]);
                        layeredMethods.push({
                            layerName: m[1],
                            methodName: m[2],
                            methodBody: methods[ea],
                            getterMethod: getter,
                            setterMethod: setter
                        }), delete methods[ea]
                    }
                })
            }
            var klass = proceed.apply(this, args);
            return layeredMethods.forEach(function(ea) {
                var layer = Global[ea.layerName];
                if (!layer) throw new Error("could not find layer: " + ea.layerName);
                ea.getterMethod || ea.setterMethod ? (ea.getterMethod && cop.layerGetterMethod(layer, klass.prototype, ea.methodName, ea.getterMethod), ea.setterMethod && cop.layerSetterMethod(layer, klass.prototype, ea.methodName, ea.setterMethod), cop.makePropertyLayerAware(klass.prototype, ea.methodName)) : cop.layerMethod(layer, klass.prototype, ea.methodName, ea.methodBody)
            }), klass
        })
    }), cop.resetLayerStack(), cop.dynamicInlining && module("cop.Flatten").load(!0)
}), StringBuffer.prototype.nextPutAll = function(s) {
    this.strings.push(s)
}, StringBuffer.prototype.contents = function() {
    return this.strings.join("")
}, String.prototype.writeStream = function() {
    return new StringBuffer(this)
}, printOn = function(x, ws) {
    if (void 0 === x || null === x) ws.nextPutAll("" + x);
    else if (x.constructor === Array) {
        ws.nextPutAll("[");
        for (var idx = 0; idx < x.length; idx++) idx > 0 && ws.nextPutAll(", "), printOn(x[idx], ws);
        ws.nextPutAll("]")
    } else ws.nextPutAll(x.toString())
}, Array.prototype.ometaToString = function() {
    var ws = "".writeStream();
    return printOn(this, ws), ws.contents()
}, objectThatDelegatesTo = function(x, props) {
    var f = function() {};
    f.prototype = x;
    var r = new f;
    for (var p in props) props.hasOwnProperty(p) && (r[p] = props[p]);
    return r
}, ownPropertyNames = function(x) {
    var r = [];
    for (var name in x) x.hasOwnProperty(name) && r.push(name);
    return r
}, isImmutable = function(x) {
    return null === x || void 0 === x || "boolean" == typeof x || "number" == typeof x || "string" == typeof x
}, String.prototype.digitValue = function() {
    return this.charCodeAt(0) - "0".charCodeAt(0)
}, isSequenceable = function(x) {
    return "string" == typeof x || x.constructor === Array
}, Array.prototype.map = Array.prototype.map || function(f) {
    for (var r = [], idx = 0; idx < this.length; idx++) r[idx] = f(this[idx]);
    return r
}, Array.prototype.reduce = Array.prototype.reduce || function(f, z) {
    for (var r = z, idx = 0; idx < this.length; idx++) r = f(r, this[idx]);
    return r
}, Array.prototype.delimWith = function(d) {
    return this.reduce(function(xs, x) {
        return xs.length > 0 && xs.push(d), xs.push(x), xs
    }, [])
}, ReadStream.prototype.atEnd = function() {
    return this.pos >= this.src.length
}, ReadStream.prototype.next = function() {
    return this.src.at(this.pos++)
}, String.prototype.pad = function(s, len) {
    for (var r = this; r.length < len;) r = s + r;
    return r
}, escapeStringFor = new Object;
for (var c = 0; 128 > c; c++) escapeStringFor[c] = String.fromCharCode(c);
escapeStringFor["'".charCodeAt(0)] = "\\'", escapeStringFor['"'.charCodeAt(0)] = '\\"', escapeStringFor["\\".charCodeAt(0)] = "\\\\", escapeStringFor["\b".charCodeAt(0)] = "\\b", escapeStringFor["\f".charCodeAt(0)] = "\\f", escapeStringFor["\n".charCodeAt(0)] = "\\n", escapeStringFor["\r".charCodeAt(0)] = "\\r", escapeStringFor[" ".charCodeAt(0)] = "\\t", escapeStringFor["".charCodeAt(0)] = "\\v", escapeChar = function(c) {
    var charCode = c.charCodeAt(0);
    return 128 > charCode ? escapeStringFor[charCode] : charCode >= 128 && 256 > charCode ? "\\x" + charCode.toString(16).pad("0", 2) : "\\u" + charCode.toString(16).pad("0", 4)
}, String.prototype.toProgramString = function() {
    for (var ws = '"'.writeStream(), idx = 0; idx < this.length; idx++) ws.nextPutAll(escapeChar(this.charAt(idx)));
    return ws.nextPutAll('"'), ws.contents()
}, tempnam.n = 0, getTag = function() {
    var numIdx = 0;
    return function(x) {
        if (null === x || void 0 === x) return x;
        switch (typeof x) {
            case "boolean":
                return 1 == x ? "Btrue" : "Bfalse";
            case "string":
                return "S" + x;
            case "number":
                return "N" + x;
            default:
                return x.hasOwnProperty("_id_") ? x._id_ : x._id_ = "R" + numIdx++
        }
    }
}(), fail = {
    toString: function() {
        return "match failed"
    }
}, OMInputStream.prototype.head = function() {
    return this.hd
}, OMInputStream.prototype.tail = function() {
    return this.tl
}, OMInputStream.prototype.type = function() {
    return this.lst.constructor
}, OMInputStream.prototype.upTo = function(that) {
    for (var r = [], curr = this; curr != that;) r.push(curr.head()), curr = curr.tail();
    return this.type() == String ? r.join("") : r
}, OMInputStreamEnd.prototype = objectThatDelegatesTo(OMInputStream.prototype), OMInputStreamEnd.prototype.head = function() {
    throw fail
}, OMInputStreamEnd.prototype.tail = function() {
    throw fail
}, Array.prototype.at = function(idx) {
    return this[idx]
}, String.prototype.at = String.prototype.charAt, ListOMInputStream.prototype = objectThatDelegatesTo(OMInputStream.prototype), ListOMInputStream.prototype.head = function() {
    return this.hd
}, ListOMInputStream.prototype.tail = function() {
    return this.tl || (this.tl = makeListOMInputStream(this.lst, this.idx + 1))
}, Array.prototype.toOMInputStream = function() {
    return makeListOMInputStream(this, 0)
}, String.prototype.toOMInputStream = function() {
    return makeListOMInputStream(this, 0)
}, Failer.prototype.used = !1, OMeta = {
    _apply: function(rule) {
        var memoRec = this.input.memo[rule];
        if (void 0 == memoRec) {
            var origInput = this.input,
                failer = new Failer;
            if (void 0 === this[rule]) throw 'tried to apply undefined rule "' + rule + '"';
            if (this.input.memo[rule] = failer, this.input.memo[rule] = memoRec = {
                    ans: this[rule].call(this),
                    nextInput: this.input
                }, failer.used) {
                var sentinel = this.input;
                this._applyTryRules(origInput, rule, sentinel, memoRec)
            }
        } else if (memoRec instanceof Failer) throw memoRec.used = !0, fail;
        return this.input = memoRec.nextInput, memoRec.ans
    },
    _applyTryRules: function(origInput, rule, sentinel, memoRec) {
        for (;;) try {
            this.input = origInput;
            var ans = this[rule].call(this);
            if (this.input == sentinel) throw fail;
            memoRec.ans = ans, memoRec.nextInput = this.input
        } catch (f) {
            if (f != fail) throw f;
            break
        }
    },
    _applyWithArgs: function(rule) {
        for (var ruleFn = this[rule], ruleFnArity = ruleFn.length, idx = arguments.length - 1; idx >= ruleFnArity + 1; idx--) this._prependInput(arguments[idx]);
        return 0 == ruleFnArity ? ruleFn.call(this) : ruleFn.apply(this, Array.prototype.slice.call(arguments, 1, ruleFnArity + 1))
    },
    _superApplyWithArgs: function(recv, rule) {
        for (var ruleFn = this[rule], ruleFnArity = ruleFn.length, idx = arguments.length - 1; idx > ruleFnArity + 2; idx--) recv._prependInput(arguments[idx]);
        return 0 == ruleFnArity ? ruleFn.call(recv) : ruleFn.apply(recv, Array.prototype.slice.call(arguments, 2, ruleFnArity + 2))
    },
    _prependInput: function(v) {
        this.input = new OMInputStream(v, this.input)
    },
    memoizeParameterizedRules: function() {
        this._prependInput = function(v) {
            var newInput;
            isImmutable(v) ? (newInput = this.input[getTag(v)], newInput || (newInput = new OMInputStream(v, this.input), this.input[getTag(v)] = newInput)) : newInput = new OMInputStream(v, this.input), this.input = newInput
        }, this._applyWithArgs = function(rule) {
            for (var ruleFnArity = this[rule].length, idx = arguments.length - 1; idx >= ruleFnArity + 1; idx--) this._prependInput(arguments[idx]);
            return 0 == ruleFnArity ? this._apply(rule) : this[rule].apply(this, Array.prototype.slice.call(arguments, 1, ruleFnArity + 1))
        }
    },
    _pred: function(b) {
        if (b) return !0;
        throw fail
    },
    _not: function(x) {
        var origInput = this.input;
        try {
            x.call(this)
        } catch (f) {
            if (f != fail) throw f;
            return this.input = origInput, !0
        }
        throw fail
    },
    _lookahead: function(x) {
        var origInput = this.input,
            r = x.call(this);
        return this.input = origInput, r
    },
    _or: function() {
        for (var origInput = this.input, idx = 0; idx < arguments.length; idx++) try {
            return this.input = origInput, arguments[idx].call(this)
        } catch (f) {
            if (f != fail) throw f
        }
        throw fail
    },
    _xor: function(ruleName) {
        for (var newInput, ans, origInput = this.input, idx = 1; idx < arguments.length;) {
            try {
                if (this.input = origInput, ans = arguments[idx].call(this), newInput) throw 'more than one choice matched by "exclusive-OR" in ' + ruleName;
                newInput = this.input
            } catch (f) {
                if (f != fail) throw f
            }
            idx++
        }
        if (newInput) return this.input = newInput, ans;
        throw fail
    },
    disableXORs: function() {
        this._xor = this._or
    },
    _opt: function(x) {
        var ans, origInput = this.input;
        try {
            ans = x.call(this)
        } catch (f) {
            if (f != fail) throw f;
            this.input = origInput
        }
        return ans
    },
    _many: function(x) {
        for (var ans = void 0 != arguments[1] ? [arguments[1]] : [];;) {
            var origInput = this.input;
            try {
                ans.push(x.call(this))
            } catch (f) {
                if (f != fail) throw f;
                this.input = origInput;
                break
            }
        }
        return ans
    },
    _many1: function(x) {
        return this._many(x, x.call(this))
    },
    _form: function(x) {
        var v = this._apply("anything");
        if (!isSequenceable(v)) throw fail;
        var origInput = this.input;
        return this.input = v.toOMInputStream(), x.call(this), this._apply("end"), this.input = origInput, v
    },
    _consumedBy: function(x) {
        var origInput = this.input;
        return x.call(this), origInput.upTo(this.input)
    },
    _idxConsumedBy: function(x) {
        var origInput = this.input;
        return x.call(this), {
            fromIdx: origInput.idx,
            toIdx: this.input.idx
        }
    },
    _interleave: function() {
        for (var currInput = this.input, ans = [], idx = 0; idx < arguments.length; idx += 2) ans[idx / 2] = "*" == arguments[idx] || "+" == arguments[idx] ? [] : void 0;
        for (;;) {
            for (var idx = 0, allDone = !0; idx < arguments.length;) {
                if ("0" != arguments[idx]) try {
                    switch (this.input = currInput, arguments[idx]) {
                        case "*":
                            ans[idx / 2].push(arguments[idx + 1].call(this));
                            break;
                        case "+":
                            ans[idx / 2].push(arguments[idx + 1].call(this)), arguments[idx] = "*";
                            break;
                        case "?":
                            ans[idx / 2] = arguments[idx + 1].call(this), arguments[idx] = "0";
                            break;
                        case "1":
                            ans[idx / 2] = arguments[idx + 1].call(this), arguments[idx] = "0";
                            break;
                        default:
                            throw "invalid mode '" + arguments[idx] + "' in OMeta._interleave"
                    }
                    currInput = this.input;
                    break
                } catch (f) {
                    if (f != fail) throw f;
                    allDone = allDone && ("*" == arguments[idx] || "?" == arguments[idx])
                }
                idx += 2
            }
            if (idx == arguments.length) {
                if (allDone) return ans;
                throw fail
            }
        }
    },
    _currIdx: function() {
        return this.input.idx
    },
    anything: function() {
        var r = this.input.head();
        return this.input = this.input.tail(), r
    },
    end: function() {
        return this._not(function() {
            return this._apply("anything")
        })
    },
    pos: function() {
        return this.input.idx
    },
    empty: function() {
        return !0
    },
    apply: function(r) {
        return this._apply(r)
    },
    foreign: function(g, r) {
        var gi = objectThatDelegatesTo(g, {
                input: makeOMInputStreamProxy(this.input)
            }),
            ans = gi._apply(r);
        return this.input = gi.input.target, ans
    },
    exactly: function(wanted) {
        if (wanted === this._apply("anything")) return wanted;
        throw fail
    },
    "true": function() {
        var r = this._apply("anything");
        return this._pred(r === !0), r
    },
    "false": function() {
        var r = this._apply("anything");
        return this._pred(r === !1), r
    },
    undefined: function() {
        var r = this._apply("anything");
        return this._pred(void 0 === r), r
    },
    number: function() {
        var r = this._apply("anything");
        return this._pred("number" == typeof r), r
    },
    string: function() {
        var r = this._apply("anything");
        return this._pred("string" == typeof r), r
    },
    "char": function() {
        var r = this._apply("anything");
        return this._pred("string" == typeof r && 1 == r.length), r
    },
    space: function() {
        var r = this._apply("char"),
            code = r.charCodeAt(0);
        return this._pred(32 >= code || 160 === code), r
    },
    spaces: function() {
        return this._many(function() {
            return this._apply("space")
        })
    },
    digit: function() {
        var r = this._apply("char");
        return this._pred(r >= "0" && "9" >= r), r
    },
    lower: function() {
        var r = this._apply("char");
        return this._pred(r >= "a" && "z" >= r), r
    },
    upper: function() {
        var r = this._apply("char");
        return this._pred(r >= "A" && "Z" >= r), r
    },
    letter: function() {
        return this._or(function() {
            return this._apply("lower")
        }, function() {
            return this._apply("upper")
        })
    },
    letterOrDigit: function() {
        return this._or(function() {
            return this._apply("letter")
        }, function() {
            return this._apply("digit")
        })
    },
    firstAndRest: function(first, rest) {
        return this._many(function() {
            return this._apply(rest)
        }, this._apply(first))
    },
    seq: function(xs) {
        for (var idx = 0; idx < xs.length; idx++) this._applyWithArgs("exactly", xs.at(idx));
        return xs
    },
    notLast: function(rule) {
        var r = this._apply(rule);
        return this._lookahead(function() {
            return this._apply(rule)
        }), r
    },
    listOf: function(rule, delim) {
        return this._or(function() {
            var r = this._apply(rule);
            return this._many(function() {
                return this._applyWithArgs("token", delim), this._apply(rule)
            }, r)
        }, function() {
            return []
        })
    },
    token: function(cs) {
        return this._apply("spaces"), this._applyWithArgs("seq", cs)
    },
    fromTo: function(x, y) {
        return this._consumedBy(function() {
            this._applyWithArgs("seq", x), this._many(function() {
                this._not(function() {
                    this._applyWithArgs("seq", y)
                }), this._apply("char")
            }), this._applyWithArgs("seq", y)
        })
    },
    initialize: function() {},
    _genericMatch: function(input, rule, args, matchFailed) {
        void 0 == args && (args = []);
        for (var realArgs = [rule], idx = 0; idx < args.length; idx++) realArgs.push(args[idx]);
        var m = objectThatDelegatesTo(this, {
            input: input
        });
        m.initialize();
        try {
            return 1 == realArgs.length ? m._apply.call(m, realArgs[0]) : m._applyWithArgs.apply(m, realArgs)
        } catch (f) {
            if (f == fail && void 0 != matchFailed) {
                var input = m.input;
                if (void 0 != input.idx) {
                    for (; void 0 != input.tl && void 0 != input.tl.idx;) input = input.tl;
                    input.idx--
                }
                return matchFailed(m, input.idx)
            }
            throw f
        }
    },
    match: function(obj, rule, args, matchFailed) {
        var toString = Array.prototype.toString;
        Array.prototype.toString = Array.prototype.ometaToString;
        try {
            return this._genericMatch([obj].toOMInputStream(), rule, args, matchFailed)
        } finally {
            Array.prototype.toString = toString
        }
    },
    matchAll: function(listyObj, rule, args, matchFailed) {
        var toString = Array.prototype.toString;
        Array.prototype.toString = Array.prototype.ometaToString;
        try {
            return this._genericMatch(listyObj.toOMInputStream(), rule, args, matchFailed)
        } finally {
            Array.prototype.toString = toString
        }
    },
    createInstance: function() {
        var m = objectThatDelegatesTo(this);
        return m.initialize(), m.matchAll = function(listyObj, aRule) {
            return this.input = listyObj.toOMInputStream(), this._apply(aRule)
        }, m
    }
}, Parser = objectThatDelegatesTo(OMeta, {}), Global.ChunkParser = {
    start: function(ometaParser, chunkStart, chunkEnd) {
        this.ometaParser = ometaParser, this.isString = chunkStart === chunkEnd && ("'" === chunkStart || '"' === chunkStart), this.chunkStart = chunkStart, this.chunkEnd = chunkEnd, this.chunkEndFound = !1, this.next = null, this.counter = 0, this.result = [], this.parseStart();
        do this.makeStep(); while (!this.parseRest());
        return this.result
    },
    parseStart: function() {
        this.result.push(this.ometaParser._applyWithArgs("exactly", this.chunkStart))
    },
    makeStep: function() {
        return this.next = this.ometaParser._apply("anything"), this.result.push(this.next), this.nextNext = this.ometaParser.input.hd, this.next
    },
    backup: function() {
        this.backupRecorded = !0, this.backupInput = this.ometaParser.input, this.backupNext = this.next, this.backupNextNext = this.nextNext, this.backupCounter = this.counter, this.backupResult = this.result
    },
    useBackup: function() {
        if (!this.backupRecorded) throw dbgOn(new Error("Using Chunk parser backup but did not record it!"));
        this.ometaParser.input = this.backupInput, this.next = this.backupNext, this.nextNext = this.backupNextNext, this.counter = this.backupCounter, this.result = this.backupResult
    },
    parseEscapedChar: function() {
        for (;
            "\\" === this.next;) this.makeStep(), this.makeStep()
    },
    parseComment: function() {
        if ("/" !== this.next) return !1;
        var comment1Opened = "/" === this.nextNext,
            comment2Opened = "*" === this.nextNext;
        if (comment1Opened || comment2Opened)
            for (this.makeStep(), this.makeStep();;) {
                if (this.parseEscapedChar(), comment1Opened && ("\n" === this.next || "\r" === this.next)) return;
                if (comment2Opened && "*" === this.next && "/" === this.nextNext && this.makeStep()) return;
                this.makeStep()
            }
    },
    parseString: function() {
        var string1Opened, string2Opened;
        if ("'" !== this.chunkStart && '"' !== this.chunkStart && ("'" === this.next && (string1Opened = !0), '"' === this.next && (string2Opened = !0), string1Opened || string2Opened))
            for (this.makeStep();;) {
                if (this.parseEscapedChar(), string1Opened && "'" === this.next) return;
                if (string2Opened && '"' === this.next) return;
                this.makeStep()
            }
    },
    parseRegex: function() {
        var regexOpen = "/" === this.next && "*" !== this.nextNext && "/" !== this.nextNext;
        if (regexOpen)
            for (this.backup(), this.makeStep();;) {
                if (this.parseEscapedChar(), "\n" === this.next || "\r" === this.next) return this.useBackup(), void 0;
                if ("/" === this.next) return;
                this.makeStep()
            }
    },
    parseRest: function() {
        return this.parseEscapedChar(), this.isString || (this.parseRegex(), this.parseString(), this.parseComment()), this.next === this.chunkEnd && 0 === this.counter ? !0 : this.next === this.chunkEnd ? (this.counter--, !1) : (this.next === this.chunkStart && this.counter++, !1)
    }
}, OMeta.basicChunk = function() {
    var chunkStart = this._apply("anything"),
        chunkEnd = this._apply("anything");
    return this.chunkParser || (this.chunkParser = objectThatDelegatesTo(ChunkParser, {})), this.chunkParser.start(this, chunkStart, chunkEnd)
}, BSOMetaParser = objectThatDelegatesTo(OMeta, {
    space: function() {
        return this.input.idx, this._or(function() {
            return OMeta._superApplyWithArgs(this, "space")
        }, function() {
            return this._applyWithArgs("fromTo", "//", "\n")
        }, function() {
            return this._applyWithArgs("fromTo", "/*", "*/")
        })
    },
    nameFirst: function() {
        return this.input.idx, this._or(function() {
            return function() {
                switch (this._apply("anything")) {
                    case "_":
                        return "_";
                    case "$":
                        return "$";
                    default:
                        throw fail
                }
            }.call(this)
        }, function() {
            return this._apply("letter")
        })
    },
    nameRest: function() {
        return this.input.idx, this._or(function() {
            return this._apply("nameFirst")
        }, function() {
            return this._apply("digit")
        })
    },
    tsName: function() {
        return this.input.idx, this._consumedBy(function() {
            return function() {
                return this._apply("nameFirst"), this._many(function() {
                    return this._apply("nameRest")
                })
            }.call(this)
        })
    },
    name: function() {
        return this.input.idx,
            function() {
                return this._apply("spaces"), this._apply("tsName")
            }.call(this)
    },
    hexDigit: function() {
        var x, v;
        return this.input.idx,
            function() {
                return x = this._apply("char"), v = this.hexDigits.indexOf(x.toLowerCase()), this._pred(v >= 0), v
            }.call(this)
    },
    eChar: function() {
        var s;
        return this.input.idx, this._or(function() {
            return function() {
                return s = this._consumedBy(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "\\"), this._or(function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case "u":
                                        return function() {
                                            return this._apply("hexDigit"), this._apply("hexDigit"), this._apply("hexDigit"), this._apply("hexDigit")
                                        }.call(this);
                                    case "x":
                                        return function() {
                                            return this._apply("hexDigit"), this._apply("hexDigit")
                                        }.call(this);
                                    default:
                                        throw fail
                                }
                            }.call(this)
                        }, function() {
                            return this._apply("char")
                        })
                    }.call(this)
                }), unescape(s)
            }.call(this)
        }, function() {
            return this._apply("char")
        })
    },
    tsString: function() {
        var xs;
        return this.input.idx,
            function() {
                return this._applyWithArgs("exactly", "'"), xs = this._many(function() {
                    return function() {
                        return this._not(function() {
                            return this._applyWithArgs("exactly", "'")
                        }), this._apply("eChar")
                    }.call(this)
                }), this._applyWithArgs("exactly", "'"), xs.join("")
            }.call(this)
    },
    characters: function() {
        var xs;
        return this.input.idx,
            function() {
                return this._applyWithArgs("exactly", "`"), this._applyWithArgs("exactly", "`"), xs = this._many(function() {
                    return function() {
                        return this._not(function() {
                            return function() {
                                return this._applyWithArgs("exactly", "'"), this._applyWithArgs("exactly", "'")
                            }.call(this)
                        }), this._apply("eChar")
                    }.call(this)
                }), this._applyWithArgs("exactly", "'"), this._applyWithArgs("exactly", "'"), ["App", "seq", xs.join("").toProgramString()]
            }.call(this)
    },
    sCharacters: function() {
        var xs;
        return this.input.idx,
            function() {
                return this._applyWithArgs("exactly", '"'), xs = this._many(function() {
                    return function() {
                        return this._not(function() {
                            return this._applyWithArgs("exactly", '"')
                        }), this._apply("eChar")
                    }.call(this)
                }), this._applyWithArgs("exactly", '"'), ["App", "token", xs.join("").toProgramString()]
            }.call(this)
    },
    string: function() {
        var xs;
        return this.input.idx,
            function() {
                return xs = this._or(function() {
                    return function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case "#":
                                    return "#";
                                case "`":
                                    return "`";
                                default:
                                    throw fail
                            }
                        }.call(this), this._apply("tsName")
                    }.call(this)
                }, function() {
                    return this._apply("tsString")
                }), ["App", "exactly", xs.toProgramString()]
            }.call(this)
    },
    number: function() {
        var n;
        return this.input.idx,
            function() {
                return n = this._consumedBy(function() {
                    return function() {
                        return this._opt(function() {
                            return this._applyWithArgs("exactly", "-")
                        }), this._many1(function() {
                            return this._apply("digit")
                        })
                    }.call(this)
                }), ["App", "exactly", n]
            }.call(this)
    },
    keyword: function() {
        var xs;
        return this.input.idx,
            function() {
                return xs = this._apply("anything"), this._applyWithArgs("token", xs), this._not(function() {
                    return this._apply("letterOrDigit")
                }), xs
            }.call(this)
    },
    args: function() {
        var xs;
        return this.input.idx, this._or(function() {
            return function() {
                switch (this._apply("anything")) {
                    case "(":
                        return function() {
                            return xs = this._applyWithArgs("listOf", "hostExpr", ","), this._applyWithArgs("token", ")"), xs
                        }.call(this);
                    default:
                        throw fail
                }
            }.call(this)
        }, function() {
            return function() {
                return this._apply("empty"), []
            }.call(this)
        })
    },
    application: function() {
        var rule, as, grm;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "^"), rule = this._apply("name"), as = this._apply("args"), ["App", "super", "'" + rule + "'"].concat(as)
            }.call(this)
        }, function() {
            return function() {
                return grm = this._apply("name"), this._applyWithArgs("token", "."), rule = this._apply("name"), as = this._apply("args"), ["App", "foreign", grm, "'" + rule + "'"].concat(as)
            }.call(this)
        }, function() {
            return function() {
                return rule = this._apply("name"), as = this._apply("args"), ["App", rule].concat(as)
            }.call(this)
        })
    },
    hostExpr: function() {
        var r;
        return this.input.idx,
            function() {
                return r = this._applyWithArgs("foreign", BSSemActionParser, "expr"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
    },
    curlyHostExpr: function() {
        var r;
        return this.input.idx,
            function() {
                return r = this._applyWithArgs("foreign", BSSemActionParser, "curlySemAction"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
    },
    primHostExpr: function() {
        var r;
        return this.input.idx,
            function() {
                return r = this._applyWithArgs("foreign", BSSemActionParser, "semAction"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
    },
    atomicHostExpr: function() {
        return this.input.idx, this._or(function() {
            return this._apply("curlyHostExpr")
        }, function() {
            return this._apply("primHostExpr")
        })
    },
    semAction: function() {
        var x;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("curlyHostExpr"), ["Act", x]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "!"), x = this._apply("atomicHostExpr"), ["Act", x]
            }.call(this)
        })
    },
    arrSemAction: function() {
        var x;
        return this.input.idx,
            function() {
                return this._applyWithArgs("token", "->"), x = this._apply("atomicHostExpr"), ["Act", x]
            }.call(this)
    },
    semPred: function() {
        var x;
        return this.input.idx,
            function() {
                return this._applyWithArgs("token", "?"), x = this._apply("atomicHostExpr"), ["Pred", x]
            }.call(this)
    },
    expr: function() {
        var x, xs;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._applyWithArgs("expr5", !0), xs = this._many1(function() {
                    return function() {
                        return this._applyWithArgs("token", "|"), this._applyWithArgs("expr5", !0)
                    }.call(this)
                }), ["Or", x].concat(xs)
            }.call(this)
        }, function() {
            return function() {
                return x = this._applyWithArgs("expr5", !0), xs = this._many1(function() {
                    return function() {
                        return this._applyWithArgs("token", "||"), this._applyWithArgs("expr5", !0)
                    }.call(this)
                }), ["XOr", x].concat(xs)
            }.call(this)
        }, function() {
            return this._applyWithArgs("expr5", !1)
        })
    },
    expr5: function() {
        var ne, x, xs;
        return this.input.idx,
            function() {
                return ne = this._apply("anything"), this._or(function() {
                    return function() {
                        return x = this._apply("interleavePart"), xs = this._many1(function() {
                            return function() {
                                return this._applyWithArgs("token", "&&"), this._apply("interleavePart")
                            }.call(this)
                        }), ["Interleave", x].concat(xs)
                    }.call(this)
                }, function() {
                    return this._applyWithArgs("expr4", ne)
                })
            }.call(this)
    },
    interleavePart: function() {
        var part;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "("), part = this._applyWithArgs("expr4", !0), this._applyWithArgs("token", ")"), ["1", part]
            }.call(this)
        }, function() {
            return function() {
                return part = this._applyWithArgs("expr4", !0), this._applyWithArgs("modedIPart", part)
            }.call(this)
        })
    },
    modedIPart: function() {
        var part;
        return this.input.idx, this._or(function() {
            return function() {
                return this._form(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "And"), this._form(function() {
                            return function() {
                                return this._applyWithArgs("exactly", "Many"), part = this._apply("anything")
                            }.call(this)
                        })
                    }.call(this)
                }), ["*", part]
            }.call(this)
        }, function() {
            return function() {
                return this._form(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "And"), this._form(function() {
                            return function() {
                                return this._applyWithArgs("exactly", "Many1"), part = this._apply("anything")
                            }.call(this)
                        })
                    }.call(this)
                }), ["+", part]
            }.call(this)
        }, function() {
            return function() {
                return this._form(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "And"), this._form(function() {
                            return function() {
                                return this._applyWithArgs("exactly", "Opt"), part = this._apply("anything")
                            }.call(this)
                        })
                    }.call(this)
                }), ["?", part]
            }.call(this)
        }, function() {
            return function() {
                return part = this._apply("anything"), ["1", part]
            }.call(this)
        })
    },
    expr4: function() {
        var ne, xs, act;
        return this.input.idx,
            function() {
                return ne = this._apply("anything"), this._or(function() {
                    return function() {
                        return xs = this._many(function() {
                            return this._apply("expr3")
                        }), act = this._apply("arrSemAction"), ["And"].concat(xs).concat([act])
                    }.call(this)
                }, function() {
                    return function() {
                        return this._pred(ne), xs = this._many1(function() {
                            return this._apply("expr3")
                        }), ["And"].concat(xs)
                    }.call(this)
                }, function() {
                    return function() {
                        return this._pred(0 == ne), xs = this._many(function() {
                            return this._apply("expr3")
                        }), ["And"].concat(xs)
                    }.call(this)
                })
            }.call(this)
    },
    optIter: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("anything"), this._or(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "*":
                                return ["Many", x];
                            case "+":
                                return ["Many1", x];
                            case "?":
                                return ["Opt", x];
                            default:
                                throw fail
                        }
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), x
                    }.call(this)
                })
            }.call(this)
    },
    optBind: function() {
        var x, n;
        return this.input.idx,
            function() {
                return x = this._apply("anything"), this._or(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case ":":
                                return function() {
                                    return n = this._apply("name"),
                                        function() {
                                            return this.locals[n] = !0, ["Set", n, x]
                                        }.call(this)
                                }.call(this);
                            default:
                                throw fail
                        }
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), x
                    }.call(this)
                })
            }.call(this)
    },
    expr3: function() {
        var n, x, e;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", ":"), n = this._apply("name"),
                    function() {
                        return this.locals[n] = !0, ["Set", n, ["App", "anything"]]
                    }.call(this)
            }.call(this)
        }, function() {
            return function() {
                return e = this._or(function() {
                    return function() {
                        return x = this._apply("expr2"), this._applyWithArgs("optIter", x)
                    }.call(this)
                }, function() {
                    return this._apply("semAction")
                }), this._applyWithArgs("optBind", e)
            }.call(this)
        }, function() {
            return this._apply("semPred")
        })
    },
    expr2: function() {
        var x;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "~"), x = this._apply("expr2"), ["Not", x]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "&"), x = this._apply("expr1"), ["Lookahead", x]
            }.call(this)
        }, function() {
            return this._apply("expr1")
        })
    },
    expr1: function() {
        var x;
        return this.input.idx, this._or(function() {
            return this._apply("application")
        }, function() {
            return function() {
                return x = this._or(function() {
                    return this._applyWithArgs("keyword", "undefined")
                }, function() {
                    return this._applyWithArgs("keyword", "nil")
                }, function() {
                    return this._applyWithArgs("keyword", "true")
                }, function() {
                    return this._applyWithArgs("keyword", "false")
                }), ["App", "exactly", x]
            }.call(this)
        }, function() {
            return function() {
                return this._apply("spaces"), this._or(function() {
                    return this._apply("characters")
                }, function() {
                    return this._apply("sCharacters")
                }, function() {
                    return this._apply("string")
                }, function() {
                    return this._apply("number")
                })
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "["), x = this._apply("expr"), this._applyWithArgs("token", "]"), ["Form", x]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "<"), x = this._apply("expr"), this._applyWithArgs("token", ">"), ["ConsBy", x]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "@<"), x = this._apply("expr"), this._applyWithArgs("token", ">"), ["IdxConsBy", x]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "("), x = this._apply("expr"), this._applyWithArgs("token", ")"), x
            }.call(this)
        })
    },
    ruleName: function() {
        return this.input.idx, this._or(function() {
            return this._apply("name")
        }, function() {
            return function() {
                return this._apply("spaces"), this._apply("tsString")
            }.call(this)
        })
    },
    rule: function() {
        var n, x, xs;
        return this.input.idx,
            function() {
                return this._lookahead(function() {
                    return n = this._apply("ruleName")
                }), this.locals = {
                    "$elf=this": !0,
                    "_fromIdx=this.input.idx": !0
                }, x = this._applyWithArgs("rulePart", n), xs = this._many(function() {
                    return function() {
                        return this._applyWithArgs("token", ","), this._applyWithArgs("rulePart", n)
                    }.call(this)
                }), ["Rule", n, ownPropertyNames(this.locals), ["Or", x].concat(xs)]
            }.call(this)
    },
    rulePart: function() {
        var rn, n, b1, b2;
        return this.input.idx,
            function() {
                return rn = this._apply("anything"), n = this._apply("ruleName"), this._pred(n == rn), b1 = this._applyWithArgs("expr4", !1), this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "="), b2 = this._apply("expr"), ["And", b1, b2]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), b1
                    }.call(this)
                })
            }.call(this)
    },
    grammar: function() {
        var n, sn, rs;
        return this.input.idx,
            function() {
                return this._applyWithArgs("keyword", "ometa"), n = this._apply("name"), sn = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "<:"), this._apply("name")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), "OMeta"
                    }.call(this)
                }), this._applyWithArgs("token", "{"), rs = this._applyWithArgs("listOf", "rule", ","), this._applyWithArgs("token", "}"), this._applyWithArgs("foreign", BSOMetaOptimizer, "optimizeGrammar", ["Grammar", n, sn].concat(rs))
            }.call(this)
    }
}), BSOMetaParser.hexDigits = "0123456789abcdef", BSOMetaTranslator = objectThatDelegatesTo(OMeta, {
    App: function() {
        var args, rule;
        return this.input.idx, this._or(function() {
            return function() {
                switch (this._apply("anything")) {
                    case "super":
                        return function() {
                            return args = this._many1(function() {
                                return this._apply("anything")
                            }), [this.sName, "._superApplyWithArgs(this,", args.join(","), ")"].join("")
                        }.call(this);
                    default:
                        throw fail
                }
            }.call(this)
        }, function() {
            return function() {
                return rule = this._apply("anything"), args = this._many1(function() {
                    return this._apply("anything")
                }), ['this._applyWithArgs("', rule, '",', args.join(","), ")"].join("")
            }.call(this)
        }, function() {
            return function() {
                return rule = this._apply("anything"), ['this._apply("', rule, '")'].join("")
            }.call(this)
        })
    },
    Act: function() {
        var expr;
        return this.input.idx,
            function() {
                return expr = this._apply("anything")
            }.call(this)
    },
    Pred: function() {
        var expr;
        return this.input.idx,
            function() {
                return expr = this._apply("anything"), ["this._pred(", expr, ")"].join("")
            }.call(this)
    },
    Or: function() {
        var xs;
        return this.input.idx,
            function() {
                return xs = this._many(function() {
                    return this._apply("transFn")
                }), ["this._or(", xs.join(","), ")"].join("")
            }.call(this)
    },
    XOr: function() {
        var xs;
        return this.input.idx,
            function() {
                return xs = this._many(function() {
                    return this._apply("transFn")
                }), xs.unshift((this.name + "." + this.rName).toProgramString()), ["this._xor(", xs.join(","), ")"].join("")
            }.call(this)
    },
    And: function() {
        var xs, y;
        return this.input.idx, this._or(function() {
            return function() {
                return xs = this._many(function() {
                    return this._applyWithArgs("notLast", "trans")
                }), y = this._apply("trans"), xs.push("return " + y), ["(function(){", xs.join(";"), "}).call(this)"].join("")
            }.call(this)
        }, function() {
            return "undefined"
        })
    },
    Opt: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._opt(", x, ")"].join("")
            }.call(this)
    },
    Many: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._many(", x, ")"].join("")
            }.call(this)
    },
    Many1: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._many1(", x, ")"].join("")
            }.call(this)
    },
    Set: function() {
        var n, v;
        return this.input.idx,
            function() {
                return n = this._apply("anything"), v = this._apply("trans"), [n, "=", v].join("")
            }.call(this)
    },
    Not: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._not(", x, ")"].join("")
            }.call(this)
    },
    Lookahead: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._lookahead(", x, ")"].join("")
            }.call(this)
    },
    Form: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._form(", x, ")"].join("")
            }.call(this)
    },
    ConsBy: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._consumedBy(", x, ")"].join("")
            }.call(this)
    },
    IdxConsBy: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("transFn"), ["this._idxConsumedBy(", x, ")"].join("")
            }.call(this)
    },
    JumpTable: function() {
        var cases;
        return this.input.idx,
            function() {
                return cases = this._many(function() {
                    return this._apply("jtCase")
                }), this.jumpTableCode(cases)
            }.call(this)
    },
    Interleave: function() {
        var xs;
        return this.input.idx,
            function() {
                return xs = this._many(function() {
                    return this._apply("intPart")
                }), ["this._interleave(", xs.join(","), ")"].join("")
            }.call(this)
    },
    Rule: function() {
        var name, ls, body;
        return this.input.idx,
            function() {
                return name = this._apply("anything"), this.rName = name, ls = this._apply("locals"), body = this._apply("trans"), ['\n"', name, '":function(){', ls, "return ", body, "}"].join("")
            }.call(this)
    },
    Grammar: function() {
        var name, sName, rules;
        return this.input.idx,
            function() {
                return name = this._apply("anything"), sName = this._apply("anything"), this.name = name, this.sName = sName, rules = this._many(function() {
                    return this._apply("trans")
                }), [name, "=objectThatDelegatesTo(", sName, ",{", rules.join(","), "})"].join("")
            }.call(this)
    },
    intPart: function() {
        var mode, part;
        return this.input.idx,
            function() {
                return this._form(function() {
                    return function() {
                        return mode = this._apply("anything"), part = this._apply("transFn")
                    }.call(this)
                }), mode.toProgramString() + "," + part
            }.call(this)
    },
    jtCase: function() {
        var x, e;
        return this.input.idx,
            function() {
                return this._form(function() {
                    return function() {
                        return x = this._apply("anything"), e = this._apply("trans")
                    }.call(this)
                }), [x.toProgramString(), e]
            }.call(this)
    },
    locals: function() {
        var vs;
        return this.input.idx, this._or(function() {
            return function() {
                return this._form(function() {
                    return vs = this._many1(function() {
                        return this._apply("string")
                    })
                }), ["var ", vs.join(","), ";"].join("")
            }.call(this)
        }, function() {
            return function() {
                return this._form(function() {
                    return void 0
                }), ""
            }.call(this)
        })
    },
    trans: function() {
        var t, ans;
        return this.input.idx,
            function() {
                return this._form(function() {
                    return function() {
                        return t = this._apply("anything"), ans = this._applyWithArgs("apply", t)
                    }.call(this)
                }), ans
            }.call(this)
    },
    transFn: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("trans"), ["(function(){return ", x, "})"].join("")
            }.call(this)
    }
}), BSOMetaTranslator.jumpTableCode = function(cases) {
    var buf = new StringBuffer;
    buf.nextPutAll("(function(){switch(this._apply('anything')){");
    for (var i = 0; i < cases.length; i += 1) buf.nextPutAll("case " + cases[i][0] + ":return " + cases[i][1] + ";");
    return buf.nextPutAll("default: throw fail}}).call(this)"), buf.contents()
}, BSJSParser = objectThatDelegatesTo(OMeta, {
    space: function() {
        return this.input.idx, this._or(function() {
            return OMeta._superApplyWithArgs(this, "space")
        }, function() {
            return this._applyWithArgs("fromTo", "//", "\n")
        }, function() {
            return this._applyWithArgs("fromTo", "/*", "*/")
        })
    },
    nameFirst: function() {
        return this.input.idx, this._or(function() {
            return this._apply("letter")
        }, function() {
            return function() {
                switch (this._apply("anything")) {
                    case "$":
                        return "$";
                    case "_":
                        return "_";
                    default:
                        throw fail
                }
            }.call(this)
        })
    },
    nameRest: function() {
        return this.input.idx, this._or(function() {
            return this._apply("nameFirst")
        }, function() {
            return this._apply("digit")
        })
    },
    iName: function() {
        return this.input.idx, this._consumedBy(function() {
            return function() {
                return this._apply("nameFirst"), this._many(function() {
                    return this._apply("nameRest")
                })
            }.call(this)
        })
    },
    isKeyword: function() {
        var x;
        return this.input.idx,
            function() {
                return x = this._apply("anything"), this._pred(BSJSParser._isKeyword(x))
            }.call(this)
    },
    name: function() {
        var n;
        return this.input.idx,
            function() {
                return n = this._apply("iName"), this._not(function() {
                    return this._applyWithArgs("isKeyword", n)
                }), ["name", "self" == n ? "$elf" : n]
            }.call(this)
    },
    keyword: function() {
        var k;
        return this.input.idx,
            function() {
                return k = this._apply("iName"), this._applyWithArgs("isKeyword", k), [k, k]
            }.call(this)
    },
    hexDigit: function() {
        var x, v;
        return this.input.idx,
            function() {
                return x = this._apply("char"), v = this.hexDigits.indexOf(x.toLowerCase()), this._pred(v >= 0), v
            }.call(this)
    },
    hexLit: function() {
        var n, d;
        return this.input.idx, this._or(function() {
            return function() {
                return n = this._apply("hexLit"), d = this._apply("hexDigit"), 16 * n + d
            }.call(this)
        }, function() {
            return this._apply("hexDigit")
        })
    },
    number: function() {
        var n, f;
        return this.input.idx, this._or(function() {
            return function() {
                switch (this._apply("anything")) {
                    case "0":
                        return function() {
                            return this._applyWithArgs("exactly", "x"), n = this._apply("hexLit"), ["number", n]
                        }.call(this);
                    default:
                        throw fail
                }
            }.call(this)
        }, function() {
            return function() {
                return f = this._consumedBy(function() {
                    return function() {
                        return this._many1(function() {
                            return this._apply("digit")
                        }), this._opt(function() {
                            return function() {
                                return this._applyWithArgs("exactly", "."), this._many1(function() {
                                    return this._apply("digit")
                                })
                            }.call(this)
                        })
                    }.call(this)
                }), ["number", parseFloat(f)]
            }.call(this)
        })
    },
    escapeChar: function() {
        var s;
        return this.input.idx,
            function() {
                return s = this._consumedBy(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "\\"), this._or(function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case "u":
                                        return function() {
                                            return this._apply("hexDigit"), this._apply("hexDigit"), this._apply("hexDigit"), this._apply("hexDigit")
                                        }.call(this);
                                    case "x":
                                        return function() {
                                            return this._apply("hexDigit"), this._apply("hexDigit")
                                        }.call(this);
                                    default:
                                        throw fail
                                }
                            }.call(this)
                        }, function() {
                            return this._apply("char")
                        })
                    }.call(this)
                }), unescape(s)
            }.call(this)
    },
    str: function() {
        var cs, n;
        return this.input.idx, this._or(function() {
            return function() {
                switch (this._apply("anything")) {
                    case '"':
                        return this._or(function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case '"':
                                        return function() {
                                            return this._applyWithArgs("exactly", '"'), cs = this._many(function() {
                                                return function() {
                                                    return this._not(function() {
                                                        return function() {
                                                            return this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), '"""'
                                                        }.call(this)
                                                    }), this._apply("char")
                                                }.call(this)
                                            }), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), ["string", cs.join("")]
                                        }.call(this);
                                    default:
                                        throw fail
                                }
                            }.call(this)
                        }, function() {
                            return function() {
                                return cs = this._many(function() {
                                    return this._or(function() {
                                        return this._apply("escapeChar")
                                    }, function() {
                                        return function() {
                                            return this._not(function() {
                                                return this._applyWithArgs("exactly", '"')
                                            }), this._apply("char")
                                        }.call(this)
                                    })
                                }), this._applyWithArgs("exactly", '"'), ["string", cs.join("")]
                            }.call(this)
                        });
                    case "'":
                        return function() {
                            return cs = this._many(function() {
                                return this._or(function() {
                                    return this._apply("escapeChar")
                                }, function() {
                                    return function() {
                                        return this._not(function() {
                                            return this._applyWithArgs("exactly", "'")
                                        }), this._apply("char")
                                    }.call(this)
                                })
                            }), this._applyWithArgs("exactly", "'"), ["string", cs.join("")]
                        }.call(this);
                    default:
                        throw fail
                }
            }.call(this)
        }, function() {
            return function() {
                return function() {
                    switch (this._apply("anything")) {
                        case "#":
                            return "#";
                        case "`":
                            return "`";
                        default:
                            throw fail
                    }
                }.call(this), n = this._apply("iName"), ["string", n]
            }.call(this)
        })
    },
    special: function() {
        var s;
        return this.input.idx,
            function() {
                return s = function() {
                    switch (this._apply("anything")) {
                        case "(":
                            return "(";
                        case ")":
                            return ")";
                        case "{":
                            return "{";
                        case "}":
                            return "}";
                        case "[":
                            return "[";
                        case "]":
                            return "]";
                        case ",":
                            return ",";
                        case ";":
                            return ";";
                        case "?":
                            return "?";
                        case ":":
                            return ":";
                        case "!":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return this._or(function() {
                                                return function() {
                                                    switch (this._apply("anything")) {
                                                        case "=":
                                                            return "!==";
                                                        default:
                                                            throw fail
                                                    }
                                                }.call(this)
                                            }, function() {
                                                return "!="
                                            });
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "!"
                            });
                        case "=":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return this._or(function() {
                                                return function() {
                                                    switch (this._apply("anything")) {
                                                        case "=":
                                                            return "===";
                                                        default:
                                                            throw fail
                                                    }
                                                }.call(this)
                                            }, function() {
                                                return "=="
                                            });
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "="
                            });
                        case ">":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return ">=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return ">"
                            });
                        case "<":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return "<=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "<"
                            });
                        case "+":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "+":
                                            return "++";
                                        case "=":
                                            return "+=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "+"
                            });
                        case "-":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "-":
                                            return "--";
                                        case "=":
                                            return "-=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "-"
                            });
                        case "*":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return "*=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "*"
                            });
                        case "/":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return "/=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "/"
                            });
                        case "%":
                            return this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "=":
                                            return "%=";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return "%"
                            });
                        case "&":
                            return function() {
                                switch (this._apply("anything")) {
                                    case "&":
                                        return this._or(function() {
                                            return function() {
                                                switch (this._apply("anything")) {
                                                    case "=":
                                                        return "&&=";
                                                    default:
                                                        throw fail
                                                }
                                            }.call(this)
                                        }, function() {
                                            return "&&"
                                        });
                                    default:
                                        throw fail
                                }
                            }.call(this);
                        case "|":
                            return function() {
                                switch (this._apply("anything")) {
                                    case "|":
                                        return this._or(function() {
                                            return function() {
                                                switch (this._apply("anything")) {
                                                    case "=":
                                                        return "||=";
                                                    default:
                                                        throw fail
                                                }
                                            }.call(this)
                                        }, function() {
                                            return "||"
                                        });
                                    default:
                                        throw fail
                                }
                            }.call(this);
                        case ".":
                            return ".";
                        default:
                            throw fail
                    }
                }.call(this), [s, s]
            }.call(this)
    },
    tok: function() {
        return this.input.idx,
            function() {
                return this._apply("spaces"), this._or(function() {
                    return this._apply("name")
                }, function() {
                    return this._apply("keyword")
                }, function() {
                    return this._apply("number")
                }, function() {
                    return this._apply("str")
                }, function() {
                    return this._apply("special")
                })
            }.call(this)
    },
    toks: function() {
        var ts;
        return this.input.idx,
            function() {
                return ts = this._many(function() {
                    return this._apply("token")
                }), this._apply("spaces"), this._apply("end"), ts
            }.call(this)
    },
    token: function() {
        var tt, t;
        return this.input.idx,
            function() {
                return tt = this._apply("anything"), t = this._apply("tok"), this._pred(t[0] == tt), t[1]
            }.call(this)
    },
    spacesNoNl: function() {
        return this.input.idx, this._many(function() {
            return function() {
                return this._not(function() {
                    return this._applyWithArgs("exactly", "\n")
                }), this._apply("space")
            }.call(this)
        })
    },
    expr: function() {
        var e, t, f, rhs;
        return this.input.idx,
            function() {
                return e = this._apply("orExpr"), this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "?"), t = this._apply("expr"), this._applyWithArgs("token", ":"), f = this._apply("expr"), ["condExpr", e, t, f]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "="), rhs = this._apply("expr"), ["set", e, rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "+="), rhs = this._apply("expr"), ["mset", e, "+", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "-="), rhs = this._apply("expr"), ["mset", e, "-", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "*="), rhs = this._apply("expr"), ["mset", e, "*", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "/="), rhs = this._apply("expr"), ["mset", e, "/", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "%="), rhs = this._apply("expr"), ["mset", e, "%", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "&&="), rhs = this._apply("expr"), ["mset", e, "&&", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "||="), rhs = this._apply("expr"), ["mset", e, "||", rhs]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), e
                    }.call(this)
                })
            }.call(this)
    },
    orExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("orExpr"), this._applyWithArgs("token", "||"), y = this._apply("andExpr"), ["binop", "||", x, y]
            }.call(this)
        }, function() {
            return this._apply("andExpr")
        })
    },
    andExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("andExpr"), this._applyWithArgs("token", "&&"), y = this._apply("eqExpr"), ["binop", "&&", x, y]
            }.call(this)
        }, function() {
            return this._apply("eqExpr")
        })
    },
    eqExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("eqExpr"), this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "=="), y = this._apply("relExpr"), ["binop", "==", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "!="), y = this._apply("relExpr"), ["binop", "!=", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "==="), y = this._apply("relExpr"), ["binop", "===", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "!=="), y = this._apply("relExpr"), ["binop", "!==", x, y]
                    }.call(this)
                })
            }.call(this)
        }, function() {
            return this._apply("relExpr")
        })
    },
    relExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("relExpr"), this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", ">"), y = this._apply("addExpr"), ["binop", ">", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", ">="), y = this._apply("addExpr"), ["binop", ">=", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "<"), y = this._apply("addExpr"), ["binop", "<", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "<="), y = this._apply("addExpr"), ["binop", "<=", x, y]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "instanceof"), y = this._apply("addExpr"), ["binop", "instanceof", x, y]
                    }.call(this)
                })
            }.call(this)
        }, function() {
            return this._apply("addExpr")
        })
    },
    addExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("addExpr"), this._applyWithArgs("token", "+"), y = this._apply("mulExpr"), ["binop", "+", x, y]
            }.call(this)
        }, function() {
            return function() {
                return x = this._apply("addExpr"), this._applyWithArgs("token", "-"), y = this._apply("mulExpr"), ["binop", "-", x, y]
            }.call(this)
        }, function() {
            return this._apply("mulExpr")
        })
    },
    mulExpr: function() {
        var x, y;
        return this.input.idx, this._or(function() {
            return function() {
                return x = this._apply("mulExpr"), this._applyWithArgs("token", "*"), y = this._apply("unary"), ["binop", "*", x, y]
            }.call(this)
        }, function() {
            return function() {
                return x = this._apply("mulExpr"), this._applyWithArgs("token", "/"), y = this._apply("unary"), ["binop", "/", x, y]
            }.call(this)
        }, function() {
            return function() {
                return x = this._apply("mulExpr"), this._applyWithArgs("token", "%"), y = this._apply("unary"), ["binop", "%", x, y]
            }.call(this)
        }, function() {
            return this._apply("unary")
        })
    },
    unary: function() {
        var p;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "-"), p = this._apply("postfix"), ["unop", "-", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "+"), p = this._apply("postfix"), ["unop", "+", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "++"), p = this._apply("postfix"), ["preop", "++", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "--"), p = this._apply("postfix"), ["preop", "--", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "!"), p = this._apply("unary"), ["unop", "!", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "void"), p = this._apply("unary"), ["unop", "void", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "delete"), p = this._apply("unary"), ["unop", "delete", p]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "typeof"), p = this._apply("unary"), ["unop", "typeof", p]
            }.call(this)
        }, function() {
            return this._apply("postfix")
        })
    },
    postfix: function() {
        var p;
        return this.input.idx,
            function() {
                return p = this._apply("primExpr"), this._or(function() {
                    return function() {
                        return this._apply("spacesNoNl"), this._applyWithArgs("token", "++"), ["postop", "++", p]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("spacesNoNl"), this._applyWithArgs("token", "--"), ["postop", "--", p]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), p
                    }.call(this)
                })
            }.call(this)
    },
    primExpr: function() {
        var p, i, m, as, f;
        return this.input.idx, this._or(function() {
            return function() {
                return p = this._apply("primExpr"), this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "["), i = this._apply("expr"), this._applyWithArgs("token", "]"), ["getp", i, p]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "."), m = this._applyWithArgs("token", "name"), this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", ")"), ["send", m, p].concat(as)
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "."), f = this._applyWithArgs("token", "name"), ["getp", ["string", f], p]
                    }.call(this)
                }, function() {
                    return function() {
                        return this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", ")"), ["call", p].concat(as)
                    }.call(this)
                })
            }.call(this)
        }, function() {
            return this._apply("primExprHd")
        })
    },
    primExprHd: function() {
        var e, n, s, as, es;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), e
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "this"), ["this"]
            }.call(this)
        }, function() {
            return function() {
                return n = this._applyWithArgs("token", "name"), ["get", n]
            }.call(this)
        }, function() {
            return function() {
                return n = this._applyWithArgs("token", "number"), ["number", n]
            }.call(this)
        }, function() {
            return function() {
                return s = this._applyWithArgs("token", "string"), ["string", s]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "function"), this._apply("funcRest")
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "new"), n = this._applyWithArgs("token", "name"), this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", ")"), ["new", n].concat(as)
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "["), es = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", "]"), ["arr"].concat(es)
            }.call(this)
        }, function() {
            return this._apply("json")
        }, function() {
            return this._apply("re")
        })
    },
    json: function() {
        var bs;
        return this.input.idx,
            function() {
                return this._applyWithArgs("token", "{"), bs = this._applyWithArgs("listOf", "jsonBinding", ","), this._applyWithArgs("token", "}"), ["json"].concat(bs)
            }.call(this)
    },
    jsonBinding: function() {
        var n, v;
        return this.input.idx,
            function() {
                return n = this._apply("jsonPropName"), this._applyWithArgs("token", ":"), v = this._apply("expr"), ["binding", n, v]
            }.call(this)
    },
    jsonPropName: function() {
        return this.input.idx, this._or(function() {
            return this._applyWithArgs("token", "name")
        }, function() {
            return this._applyWithArgs("token", "number")
        }, function() {
            return this._applyWithArgs("token", "string")
        })
    },
    re: function() {
        var x;
        return this.input.idx,
            function() {
                return this._apply("spaces"), x = this._consumedBy(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "/"), this._apply("reBody"), this._applyWithArgs("exactly", "/"), this._many(function() {
                            return this._apply("reFlag")
                        })
                    }.call(this)
                }), ["regExpr", x]
            }.call(this)
    },
    reBody: function() {
        return this.input.idx,
            function() {
                return this._apply("re1stChar"), this._many(function() {
                    return this._apply("reChar")
                })
            }.call(this)
    },
    re1stChar: function() {
        return this.input.idx, this._or(function() {
            return function() {
                return this._not(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "*":
                                return "*";
                            case "\\":
                                return "\\";
                            case "/":
                                return "/";
                            case "[":
                                return "[";
                            default:
                                throw fail
                        }
                    }.call(this)
                }), this._apply("reNonTerm")
            }.call(this)
        }, function() {
            return this._apply("escapeChar")
        }, function() {
            return this._apply("reClass")
        })
    },
    reChar: function() {
        return this.input.idx, this._or(function() {
            return this._apply("re1stChar")
        }, function() {
            return function() {
                switch (this._apply("anything")) {
                    case "*":
                        return "*";
                    default:
                        throw fail
                }
            }.call(this)
        })
    },
    reNonTerm: function() {
        return this.input.idx,
            function() {
                return this._not(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "\n":
                                return "\n";
                            case "\r":
                                return "\r";
                            default:
                                throw fail
                        }
                    }.call(this)
                }), this._apply("char")
            }.call(this)
    },
    reClass: function() {
        return this.input.idx,
            function() {
                return this._applyWithArgs("exactly", "["), this._many(function() {
                    return this._apply("reClassChar")
                }), this._applyWithArgs("exactly", "]")
            }.call(this)
    },
    reClassChar: function() {
        return this.input.idx,
            function() {
                return this._not(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "[":
                                return "[";
                            case "]":
                                return "]";
                            default:
                                throw fail
                        }
                    }.call(this)
                }), this._apply("reChar")
            }.call(this)
    },
    reFlag: function() {
        return this.input.idx, this._apply("nameFirst")
    },
    formal: function() {
        return this.input.idx,
            function() {
                return this._apply("spaces"), this._applyWithArgs("token", "name")
            }.call(this)
    },
    funcRest: function() {
        var fs, body;
        return this.input.idx,
            function() {
                return this._applyWithArgs("token", "("), fs = this._applyWithArgs("listOf", "formal", ","), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), body = this._apply("srcElems"), this._applyWithArgs("token", "}"), ["func", fs, body]
            }.call(this)
    },
    sc: function() {
        return this.input.idx, this._or(function() {
            return function() {
                return this._apply("spacesNoNl"), this._or(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "\n":
                                return "\n";
                            default:
                                throw fail
                        }
                    }.call(this)
                }, function() {
                    return this._lookahead(function() {
                        return this._applyWithArgs("exactly", "}")
                    })
                }, function() {
                    return this._apply("end")
                })
            }.call(this)
        }, function() {
            return this._applyWithArgs("token", ";")
        })
    },
    binding: function() {
        var n, v;
        return this.input.idx,
            function() {
                return n = this._applyWithArgs("token", "name"), v = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "="), this._apply("expr")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), ["var", n, v]
            }.call(this)
    },
    block: function() {
        var ss;
        return this.input.idx,
            function() {
                return this._applyWithArgs("token", "{"), ss = this._apply("srcElems"), this._applyWithArgs("token", "}"), ss
            }.call(this)
    },
    stmt: function() {
        var bs, c, t, f, s, i, u, n, v, e, cs, x;
        return this.input.idx, this._or(function() {
            return this._apply("block")
        }, function() {
            return function() {
                return this._applyWithArgs("token", "var"), bs = this._applyWithArgs("listOf", "binding", ","), this._apply("sc"), ["begin"].concat(bs)
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "if"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), t = this._apply("stmt"), f = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "else"), this._apply("stmt")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), ["if", c, t, f]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["while", c, s]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "do"), s = this._apply("stmt"), this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), this._apply("sc"), ["doWhile", s, c]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), i = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "var"), this._apply("binding")
                    }.call(this)
                }, function() {
                    return this._apply("expr")
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), this._applyWithArgs("token", ";"), c = this._or(function() {
                    return this._apply("expr")
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "true"]
                    }.call(this)
                }), this._applyWithArgs("token", ";"), u = this._or(function() {
                    return this._apply("expr")
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["for", i, c, u, s]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), v = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "var"), n = this._applyWithArgs("token", "name"), ["var", n, ["get", "undefined"]]
                    }.call(this)
                }, function() {
                    return this._apply("expr")
                }), this._applyWithArgs("token", "in"), e = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["forIn", v, e, s]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "switch"), this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), cs = this._many(function() {
                    return this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "case"), c = this._apply("expr"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), ["case", c, cs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "default"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), ["default", cs]
                        }.call(this)
                    })
                }), this._applyWithArgs("token", "}"), ["switch", e].concat(cs)
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "break"), this._apply("sc"), ["break"]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "continue"), this._apply("sc"), ["continue"]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "throw"), this._apply("spacesNoNl"), e = this._apply("expr"), this._apply("sc"), ["throw", e]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "try"), t = this._apply("block"), this._applyWithArgs("token", "catch"), this._applyWithArgs("token", "("), e = this._applyWithArgs("token", "name"), this._applyWithArgs("token", ")"), c = this._apply("block"), f = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "finally"), this._apply("block")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), ["try", t, e, c, f]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "return"), e = this._or(function() {
                    return this._apply("expr")
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), this._apply("sc"), ["return", e]
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", "with"), this._applyWithArgs("token", "("), x = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["with", x, s]
            }.call(this)
        }, function() {
            return function() {
                return e = this._apply("expr"), this._apply("sc"), e
            }.call(this)
        }, function() {
            return function() {
                return this._applyWithArgs("token", ";"), ["get", "undefined"]
            }.call(this)
        })
    },
    srcElem: function() {
        var n, f;
        return this.input.idx, this._or(function() {
            return function() {
                return this._applyWithArgs("token", "function"), n = this._applyWithArgs("token", "name"), f = this._apply("funcRest"), ["var", n, f]
            }.call(this)
        }, function() {
            return this._apply("stmt")
        })
    },
    srcElems: function() {
        var ss;
        return this.input.idx,
            function() {
                return ss = this._many(function() {
                    return this._apply("srcElem")
                }), ["begin"].concat(ss)
            }.call(this)
    },
    topLevel: function() {
        var r;
        return this.input.idx,
            function() {
                return r = this._apply("srcElems"), this._apply("spaces"), this._apply("end"), r
            }.call(this)
    }
}), BSJSParser.hexDigits = "0123456789abcdef", BSJSParser.keywords = {}, keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "ometa"];
for (var idx = 0; idx < keywords.length; idx++) BSJSParser.keywords[keywords[idx]] = !0;
BSJSParser._isKeyword = function(k) {
        return this.keywords.hasOwnProperty(k)
    }, BSSemActionParser = objectThatDelegatesTo(BSJSParser, {
        curlySemAction: function() {
            var r, s, ss;
            return this.input.idx, this._or(function() {
                return function() {
                    return this._applyWithArgs("token", "{"), r = this._apply("expr"), this._apply("sc"), this._applyWithArgs("token", "}"), this._apply("spaces"), r
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "{"), ss = this._many(function() {
                        return function() {
                            return s = this._apply("srcElem"), this._lookahead(function() {
                                return this._apply("srcElem")
                            }), s
                        }.call(this)
                    }), s = this._or(function() {
                        return function() {
                            return r = this._apply("expr"), this._apply("sc"), ["return", r]
                        }.call(this)
                    }, function() {
                        return this._apply("srcElem")
                    }), ss.push(s), this._applyWithArgs("token", "}"), this._apply("spaces"), ["send", "call", ["func", [],
                            ["begin"].concat(ss)
                        ],
                        ["this"]
                    ]
                }.call(this)
            })
        },
        semAction: function() {
            var r;
            return this.input.idx, this._or(function() {
                return this._apply("curlySemAction")
            }, function() {
                return function() {
                    return r = this._apply("primExpr"), this._apply("spaces"), r
                }.call(this)
            })
        }
    }), BSJSTranslator = objectThatDelegatesTo(OMeta, {
        trans: function() {
            var t, ans;
            return this.input.idx,
                function() {
                    return this._form(function() {
                        return function() {
                            return t = this._apply("anything"), ans = this._applyWithArgs("apply", t)
                        }.call(this)
                    }), ans
                }.call(this)
        },
        curlyTrans: function() {
            var r, rs;
            return this.input.idx, this._or(function() {
                return function() {
                    return this._form(function() {
                        return function() {
                            return this._applyWithArgs("exactly", "begin"), r = this._apply("curlyTrans")
                        }.call(this)
                    }), r
                }.call(this)
            }, function() {
                return function() {
                    return this._form(function() {
                        return function() {
                            return this._applyWithArgs("exactly", "begin"), rs = this._many(function() {
                                return this._apply("trans")
                            })
                        }.call(this)
                    }), "{" + rs.join(";") + "}"
                }.call(this)
            }, function() {
                return function() {
                    return r = this._apply("trans"), "{" + r + "}"
                }.call(this)
            })
        },
        "this": function() {
            return this.input.idx, "this"
        },
        "break": function() {
            return this.input.idx, "break"
        },
        "continue": function() {
            return this.input.idx, "continue"
        },
        number: function() {
            var n;
            return this.input.idx,
                function() {
                    return n = this._apply("anything"), "(" + n + ")"
                }.call(this)
        },
        string: function() {
            var s;
            return this.input.idx,
                function() {
                    return s = this._apply("anything"), s.toProgramString()
                }.call(this)
        },
        regExpr: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("anything")
                }.call(this)
        },
        arr: function() {
            var xs;
            return this.input.idx,
                function() {
                    return xs = this._many(function() {
                        return this._apply("trans")
                    }), "[" + xs.join(",") + "]"
                }.call(this)
        },
        unop: function() {
            var op, x;
            return this.input.idx,
                function() {
                    return op = this._apply("anything"), x = this._apply("trans"), "(" + op + " " + x + ")"
                }.call(this)
        },
        getp: function() {
            var fd, x;
            return this.input.idx,
                function() {
                    return fd = this._apply("trans"), x = this._apply("trans"), x + "[" + fd + "]"
                }.call(this)
        },
        get: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("anything")
                }.call(this)
        },
        set: function() {
            var lhs, rhs;
            return this.input.idx,
                function() {
                    return lhs = this._apply("trans"), rhs = this._apply("trans"), "(" + lhs + "=" + rhs + ")"
                }.call(this)
        },
        mset: function() {
            var lhs, op, rhs;
            return this.input.idx,
                function() {
                    return lhs = this._apply("trans"), op = this._apply("anything"), rhs = this._apply("trans"), "(" + lhs + op + "=" + rhs + ")"
                }.call(this)
        },
        binop: function() {
            var op, x, y;
            return this.input.idx,
                function() {
                    return op = this._apply("anything"), x = this._apply("trans"), y = this._apply("trans"), "(" + x + " " + op + " " + y + ")"
                }.call(this)
        },
        preop: function() {
            var op, x;
            return this.input.idx,
                function() {
                    return op = this._apply("anything"), x = this._apply("trans"), op + x
                }.call(this)
        },
        postop: function() {
            var op, x;
            return this.input.idx,
                function() {
                    return op = this._apply("anything"), x = this._apply("trans"), x + op
                }.call(this)
        },
        "return": function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), "return " + x
                }.call(this)
        },
        "with": function() {
            var x, s;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), s = this._apply("curlyTrans"), "with(" + x + ")" + s
                }.call(this)
        },
        "if": function() {
            var cond, t, e;
            return this.input.idx,
                function() {
                    return cond = this._apply("trans"), t = this._apply("curlyTrans"), e = this._apply("curlyTrans"), "if(" + cond + ")" + t + "else" + e
                }.call(this)
        },
        condExpr: function() {
            var cond, t, e;
            return this.input.idx,
                function() {
                    return cond = this._apply("trans"), t = this._apply("trans"), e = this._apply("trans"), "(" + cond + "?" + t + ":" + e + ")"
                }.call(this)
        },
        "while": function() {
            var cond, body;
            return this.input.idx,
                function() {
                    return cond = this._apply("trans"), body = this._apply("curlyTrans"), "while(" + cond + ")" + body
                }.call(this)
        },
        doWhile: function() {
            var body, cond;
            return this.input.idx,
                function() {
                    return body = this._apply("curlyTrans"), cond = this._apply("trans"), "do" + body + "while(" + cond + ")"
                }.call(this)
        },
        "for": function() {
            var init, cond, upd, body;
            return this.input.idx,
                function() {
                    return init = this._apply("trans"), cond = this._apply("trans"), upd = this._apply("trans"), body = this._apply("curlyTrans"), "for(" + init + ";" + cond + ";" + upd + ")" + body
                }.call(this)
        },
        forIn: function() {
            var x, arr, body;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), arr = this._apply("trans"), body = this._apply("curlyTrans"), "for(" + x + " in " + arr + ")" + body
                }.call(this)
        },
        begin: function() {
            var x, xs;
            return this.input.idx, this._or(function() {
                return function() {
                    return x = this._apply("trans"), this._apply("end"), x
                }.call(this)
            }, function() {
                return function() {
                    return xs = this._many(function() {
                        return function() {
                            return x = this._apply("trans"), this._or(function() {
                                return function() {
                                    return this._or(function() {
                                        return this._pred("}" == x[x.length - 1])
                                    }, function() {
                                        return this._apply("end")
                                    }), x
                                }.call(this)
                            }, function() {
                                return function() {
                                    return this._apply("empty"), x + ";"
                                }.call(this)
                            })
                        }.call(this)
                    }), "{" + xs.join("") + "}"
                }.call(this)
            })
        },
        func: function() {
            var args, body;
            return this.input.idx,
                function() {
                    return args = this._apply("anything"), body = this._apply("curlyTrans"), "(function (" + args.join(",") + ")" + body + ")"
                }.call(this)
        },
        call: function() {
            var fn, args;
            return this.input.idx,
                function() {
                    return fn = this._apply("trans"), args = this._many(function() {
                        return this._apply("trans")
                    }), fn + "(" + args.join(",") + ")"
                }.call(this)
        },
        send: function() {
            var msg, recv, args;
            return this.input.idx,
                function() {
                    return msg = this._apply("anything"), recv = this._apply("trans"), args = this._many(function() {
                        return this._apply("trans")
                    }), recv + "." + msg + "(" + args.join(",") + ")"
                }.call(this)
        },
        "new": function() {
            var cls, args;
            return this.input.idx,
                function() {
                    return cls = this._apply("anything"), args = this._many(function() {
                        return this._apply("trans")
                    }), "new " + cls + "(" + args.join(",") + ")"
                }.call(this)
        },
        "var": function() {
            var name, val;
            return this.input.idx,
                function() {
                    return name = this._apply("anything"), val = this._apply("trans"), "var " + name + "=" + val
                }.call(this)
        },
        "throw": function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), "throw " + x
                }.call(this)
        },
        "try": function() {
            var x, name, c, f;
            return this.input.idx,
                function() {
                    return x = this._apply("curlyTrans"), name = this._apply("anything"), c = this._apply("curlyTrans"), f = this._apply("curlyTrans"), "try " + x + "catch(" + name + ")" + c + "finally" + f
                }.call(this)
        },
        json: function() {
            var props;
            return this.input.idx,
                function() {
                    return props = this._many(function() {
                        return this._apply("trans")
                    }), "({" + props.join(",") + "})"
                }.call(this)
        },
        binding: function() {
            var name, val;
            return this.input.idx,
                function() {
                    return name = this._apply("anything"), val = this._apply("trans"), name.toProgramString() + ": " + val
                }.call(this)
        },
        "switch": function() {
            var x, cases;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), cases = this._many(function() {
                        return this._apply("trans")
                    }), "switch(" + x + "){" + cases.join(";") + "}"
                }.call(this)
        },
        "case": function() {
            var x, y;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), y = this._apply("trans"), "case " + x + ": " + y
                }.call(this)
        },
        "default": function() {
            var y;
            return this.input.idx,
                function() {
                    return y = this._apply("trans"), "default: " + y
                }.call(this)
        }
    }), BSOMetaJSParser = objectThatDelegatesTo(BSJSParser, {
        srcElem: function() {
            var r;
            return this.input.idx, this._or(function() {
                return function() {
                    return this._apply("spaces"), r = this._applyWithArgs("foreign", BSOMetaParser, "grammar"), this._apply("sc"), r
                }.call(this)
            }, function() {
                return BSJSParser._superApplyWithArgs(this, "srcElem")
            })
        }
    }), BSOMetaJSTranslator = objectThatDelegatesTo(BSJSTranslator, {
        Grammar: function() {
            return this.input.idx, this._applyWithArgs("foreign", BSOMetaTranslator, "Grammar")
        }
    }), BSNullOptimization = objectThatDelegatesTo(OMeta, {
        setHelped: function() {
            return this.input.idx, this._didSomething = !0
        },
        helped: function() {
            return this.input.idx, this._pred(this._didSomething)
        },
        trans: function() {
            var t, ans;
            return this.input.idx,
                function() {
                    return this._form(function() {
                        return function() {
                            return t = this._apply("anything"), this._pred(void 0 != this[t]), ans = this._applyWithArgs("apply", t)
                        }.call(this)
                    }), ans
                }.call(this)
        },
        optimize: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), this._apply("helped"), x
                }.call(this)
        },
        App: function() {
            var rule, args;
            return this.input.idx,
                function() {
                    return rule = this._apply("anything"), args = this._many(function() {
                        return this._apply("anything")
                    }), ["App", rule].concat(args)
                }.call(this)
        },
        Act: function() {
            var expr;
            return this.input.idx,
                function() {
                    return expr = this._apply("anything"), ["Act", expr]
                }.call(this)
        },
        Pred: function() {
            var expr;
            return this.input.idx,
                function() {
                    return expr = this._apply("anything"), ["Pred", expr]
                }.call(this)
        },
        Or: function() {
            var xs;
            return this.input.idx,
                function() {
                    return xs = this._many(function() {
                        return this._apply("trans")
                    }), ["Or"].concat(xs)
                }.call(this)
        },
        XOr: function() {
            var xs;
            return this.input.idx,
                function() {
                    return xs = this._many(function() {
                        return this._apply("trans")
                    }), ["XOr"].concat(xs)
                }.call(this)
        },
        And: function() {
            var xs;
            return this.input.idx,
                function() {
                    return xs = this._many(function() {
                        return this._apply("trans")
                    }), ["And"].concat(xs)
                }.call(this)
        },
        Opt: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Opt", x]
                }.call(this)
        },
        Many: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Many", x]
                }.call(this)
        },
        Many1: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Many1", x]
                }.call(this)
        },
        Set: function() {
            var n, v;
            return this.input.idx,
                function() {
                    return n = this._apply("anything"), v = this._apply("trans"), ["Set", n, v]
                }.call(this)
        },
        Not: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Not", x]
                }.call(this)
        },
        Lookahead: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Lookahead", x]
                }.call(this)
        },
        Form: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["Form", x]
                }.call(this)
        },
        ConsBy: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["ConsBy", x]
                }.call(this)
        },
        IdxConsBy: function() {
            var x;
            return this.input.idx,
                function() {
                    return x = this._apply("trans"), ["IdxConsBy", x]
                }.call(this)
        },
        JumpTable: function() {
            var c, e, ces;
            return this.input.idx,
                function() {
                    return ces = this._many(function() {
                        return function() {
                            return this._form(function() {
                                return function() {
                                    return c = this._apply("anything"), e = this._apply("trans")
                                }.call(this)
                            }), [c, e]
                        }.call(this)
                    }), ["JumpTable"].concat(ces)
                }.call(this)
        },
        Interleave: function() {
            var m, p, xs;
            return this.input.idx,
                function() {
                    return xs = this._many(function() {
                        return function() {
                            return this._form(function() {
                                return function() {
                                    return m = this._apply("anything"), p = this._apply("trans")
                                }.call(this)
                            }), [m, p]
                        }.call(this)
                    }), ["Interleave"].concat(xs)
                }.call(this)
        },
        Rule: function() {
            var name, ls, body;
            return this.input.idx,
                function() {
                    return name = this._apply("anything"), ls = this._apply("anything"), body = this._apply("trans"), ["Rule", name, ls, body]
                }.call(this)
        }
    }), BSNullOptimization.initialize = function() {
        this._didSomething = !1
    }, BSAssociativeOptimization = objectThatDelegatesTo(BSNullOptimization, {
        And: function() {
            var x, xs;
            return this.input.idx, this._or(function() {
                return function() {
                    return x = this._apply("trans"), this._apply("end"), this._apply("setHelped"), x
                }.call(this)
            }, function() {
                return function() {
                    return xs = this._applyWithArgs("transInside", "And"), ["And"].concat(xs)
                }.call(this)
            })
        },
        Or: function() {
            var x, xs;
            return this.input.idx, this._or(function() {
                return function() {
                    return x = this._apply("trans"), this._apply("end"), this._apply("setHelped"), x
                }.call(this)
            }, function() {
                return function() {
                    return xs = this._applyWithArgs("transInside", "Or"), ["Or"].concat(xs)
                }.call(this)
            })
        },
        XOr: function() {
            var x, xs;
            return this.input.idx, this._or(function() {
                return function() {
                    return x = this._apply("trans"), this._apply("end"), this._apply("setHelped"), x
                }.call(this)
            }, function() {
                return function() {
                    return xs = this._applyWithArgs("transInside", "XOr"), ["XOr"].concat(xs)
                }.call(this)
            })
        },
        transInside: function() {
            var t, xs, ys, x;
            return this.input.idx,
                function() {
                    return t = this._apply("anything"), this._or(function() {
                        return function() {
                            return this._form(function() {
                                return function() {
                                    return this._applyWithArgs("exactly", t), xs = this._applyWithArgs("transInside", t)
                                }.call(this)
                            }), ys = this._applyWithArgs("transInside", t), this._apply("setHelped"), xs.concat(ys)
                        }.call(this)
                    }, function() {
                        return function() {
                            return x = this._apply("trans"), xs = this._applyWithArgs("transInside", t), [x].concat(xs)
                        }.call(this)
                    }, function() {
                        return []
                    })
                }.call(this)
        }
    }), BSSeqInliner = objectThatDelegatesTo(BSNullOptimization, {
        App: function() {
            var s, cs, rule, args;
            return this.input.idx, this._or(function() {
                return function() {
                    switch (this._apply("anything")) {
                        case "seq":
                            return function() {
                                return s = this._apply("anything"), this._apply("end"), cs = this._applyWithArgs("seqString", s), this._apply("setHelped"), ["And"].concat(cs).concat([
                                    ["Act", s]
                                ])
                            }.call(this);
                        default:
                            throw fail
                    }
                }.call(this)
            }, function() {
                return function() {
                    return rule = this._apply("anything"), args = this._many(function() {
                        return this._apply("anything")
                    }), ["App", rule].concat(args)
                }.call(this)
            })
        },
        inlineChar: function() {
            var c;
            return this.input.idx,
                function() {
                    return c = this._applyWithArgs("foreign", BSOMetaParser, "eChar"), this._not(function() {
                        return this._apply("end")
                    }), ["App", "exactly", c.toProgramString()]
                }.call(this)
        },
        seqString: function() {
            var s, cs;
            return this.input.idx,
                function() {
                    return this._lookahead(function() {
                        return function() {
                            return s = this._apply("anything"), this._pred("string" == typeof s)
                        }.call(this)
                    }), this._or(function() {
                        return function() {
                            return this._form(function() {
                                return function() {
                                    return this._applyWithArgs("exactly", '"'), cs = this._many(function() {
                                        return this._apply("inlineChar")
                                    }), this._applyWithArgs("exactly", '"')
                                }.call(this)
                            }), cs
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._form(function() {
                                return function() {
                                    return this._applyWithArgs("exactly", "'"), cs = this._many(function() {
                                        return this._apply("inlineChar")
                                    }), this._applyWithArgs("exactly", "'")
                                }.call(this)
                            }), cs
                        }.call(this)
                    })
                }.call(this)
        }
    }), JumpTable = function(choiceOp, choice) {
        this.choiceOp = choiceOp, this.choices = {}, this.add(choice)
    }, JumpTable.prototype.add = function(choice) {
        var c = choice[0],
            t = choice[1];
        this.choices[c] ? this.choices[c][0] == this.choiceOp ? this.choices[c].push(t) : this.choices[c] = [this.choiceOp, this.choices[c], t] : this.choices[c] = t
    }, JumpTable.prototype.toTree = function() {
        for (var r = ["JumpTable"], choiceKeys = ownPropertyNames(this.choices), i = 0; i < choiceKeys.length; i += 1) r.push([choiceKeys[i], this.choices[choiceKeys[i]]]);
        return r
    }, BSJumpTableOptimization = objectThatDelegatesTo(BSNullOptimization, {
        Or: function() {
            var cs;
            return this.input.idx,
                function() {
                    return cs = this._many(function() {
                        return this._or(function() {
                            return this._applyWithArgs("jtChoices", "Or")
                        }, function() {
                            return this._apply("trans")
                        })
                    }), ["Or"].concat(cs)
                }.call(this)
        },
        XOr: function() {
            var cs;
            return this.input.idx,
                function() {
                    return cs = this._many(function() {
                        return this._or(function() {
                            return this._applyWithArgs("jtChoices", "XOr")
                        }, function() {
                            return this._apply("trans")
                        })
                    }), ["XOr"].concat(cs)
                }.call(this)
        },
        quotedString: function() {
            var c, cs;
            return this.input.idx,
                function() {
                    return this._lookahead(function() {
                        return this._apply("string")
                    }), this._form(function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case '"':
                                    return function() {
                                        return cs = this._many(function() {
                                            return function() {
                                                return c = this._applyWithArgs("foreign", BSOMetaParser, "eChar"), this._not(function() {
                                                    return this._apply("end")
                                                }), c
                                            }.call(this)
                                        }), this._applyWithArgs("exactly", '"')
                                    }.call(this);
                                case "'":
                                    return function() {
                                        return cs = this._many(function() {
                                            return function() {
                                                return c = this._applyWithArgs("foreign", BSOMetaParser, "eChar"), this._not(function() {
                                                    return this._apply("end")
                                                }), c
                                            }.call(this)
                                        }), this._applyWithArgs("exactly", "'")
                                    }.call(this);
                                default:
                                    throw fail
                            }
                        }.call(this)
                    }), cs.join("")
                }.call(this)
        },
        jtChoice: function() {
            var x, rest;
            return this.input.idx, this._or(function() {
                return function() {
                    return this._form(function() {
                        return function() {
                            return this._applyWithArgs("exactly", "And"), this._form(function() {
                                return function() {
                                    return this._applyWithArgs("exactly", "App"), this._applyWithArgs("exactly", "exactly"), x = this._apply("quotedString")
                                }.call(this)
                            }), rest = this._many(function() {
                                return this._apply("anything")
                            })
                        }.call(this)
                    }), [x, ["And"].concat(rest)]
                }.call(this)
            }, function() {
                return function() {
                    return this._form(function() {
                        return function() {
                            return this._applyWithArgs("exactly", "App"), this._applyWithArgs("exactly", "exactly"), x = this._apply("quotedString")
                        }.call(this)
                    }), [x, ["Act", x.toProgramString()]]
                }.call(this)
            })
        },
        jtChoices: function() {
            var op, c, jt;
            return this.input.idx,
                function() {
                    return op = this._apply("anything"), c = this._apply("jtChoice"), jt = new JumpTable(op, c), this._many(function() {
                        return function() {
                            return c = this._apply("jtChoice"), jt.add(c)
                        }.call(this)
                    }), this._apply("setHelped"), jt.toTree()
                }.call(this)
        }
    }), BSOMetaOptimizer = objectThatDelegatesTo(OMeta, {
        optimizeGrammar: function() {
            var n, sn, rs;
            return this.input.idx,
                function() {
                    return this._form(function() {
                        return function() {
                            return this._applyWithArgs("exactly", "Grammar"), n = this._apply("anything"), sn = this._apply("anything"), rs = this._many(function() {
                                return this._apply("optimizeRule")
                            })
                        }.call(this)
                    }), ["Grammar", n, sn].concat(rs)
                }.call(this)
        },
        optimizeRule: function() {
            var r;
            return this.input.idx,
                function() {
                    return r = this._apply("anything"), this._or(function() {
                        return r = this._applyWithArgs("foreign", BSSeqInliner, "optimize", r)
                    }, function() {
                        return this._apply("empty")
                    }), this._many(function() {
                        return this._or(function() {
                            return r = this._applyWithArgs("foreign", BSAssociativeOptimization, "optimize", r)
                        }, function() {
                            return r = this._applyWithArgs("foreign", BSJumpTableOptimization, "optimize", r)
                        })
                    }), r
                }.call(this)
        }
    }), LKJSParser = objectThatDelegatesTo(BSJSParser, {
        regexp: function() {
            var cs, fs, flag;
            return function() {
                return this._applyWithArgs("exactly", "/"), cs = this._many(function() {
                    return this._or(function() {
                        return this._apply("escapeChar")
                    }, function() {
                        return function() {
                            return this._not(function() {
                                return this._applyWithArgs("exactly", "/")
                            }), this._not(function() {
                                return this._applyWithArgs("exactly", "\n")
                            }), this._apply("char")
                        }.call(this)
                    })
                }), this._applyWithArgs("exactly", "/"), flag = this._or(function() {
                    return function() {
                        return fs = this._many1(function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case "m":
                                        return "m";
                                    case "g":
                                        return "g";
                                    case "i":
                                        return "i";
                                    case "y":
                                        return "y";
                                    default:
                                        throw fail
                                }
                            }.call(this)
                        }), fs.join("")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), ""
                    }.call(this)
                }), ["regexp", "/" + cs.join("") + "/" + flag]
            }.call(this)
        },
        tok: function() {
            return function() {
                return this._apply("spaces"), this._or(function() {
                    return this._apply("name")
                }, function() {
                    return this._apply("keyword")
                }, function() {
                    return this._apply("number")
                }, function() {
                    return this._apply("str")
                }, function() {
                    return this._apply("regexp")
                }, function() {
                    return this._apply("special")
                })
            }.call(this)
        },
        relExpr: function() {
            var x, y, y, y, y, y, y;
            return this._or(function() {
                return function() {
                    return x = this._apply("relExpr"), this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", ">"), y = this._apply("addExpr"), ["binop", ">", x, y]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", ">="), y = this._apply("addExpr"), ["binop", ">=", x, y]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "<"), y = this._apply("addExpr"), ["binop", "<", x, y]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "<="), y = this._apply("addExpr"), ["binop", "<=", x, y]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "instanceof"), y = this._apply("addExpr"), ["binop", "instanceof", x, y]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "in"), y = this._apply("addExpr"), ["binop", "in", x, y]
                        }.call(this)
                    })
                }.call(this)
            }, function() {
                return this._apply("addExpr")
            })
        },
        primExprHd: function() {
            var e, n, n, s, r, n, f, n, name, as, newExpr, as, es;
            return this._or(function() {
                return function() {
                    return this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), e
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "this"), ["this"]
                }.call(this)
            }, function() {
                return function() {
                    return n = this._applyWithArgs("token", "name"), ["get", n]
                }.call(this)
            }, function() {
                return function() {
                    return n = this._applyWithArgs("token", "number"), ["number", n]
                }.call(this)
            }, function() {
                return function() {
                    return s = this._applyWithArgs("token", "string"), ["string", s]
                }.call(this)
            }, function() {
                return function() {
                    return r = this._applyWithArgs("token", "regexp"), ["regexp", r]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "function"), this._apply("funcRest")
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "function"), n = this._applyWithArgs("token", "name"), f = this._apply("funcRest"), ["var", n, f]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "new"), name = this._many(function() {
                        return function() {
                            return n = this._applyWithArgs("token", "name"), this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case ".":
                                            return ".";
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return this._apply("empty")
                            }), n
                        }.call(this)
                    }), this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", ")"), ["new", name.join(".")].concat(as)
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "new"), this._applyWithArgs("token", "("), newExpr = this._apply("expr"), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "expr", ","), this._applyWithArgs("token", ")"), ["newExpr", newExpr].concat(as)
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "["), es = this._applyWithArgs("listOf", "expr", ","), this._or(function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case ",":
                                    return ",";
                                default:
                                    throw fail
                            }
                        }.call(this)
                    }, function() {
                        return this._apply("empty")
                    }), this._applyWithArgs("token", "]"), ["arr"].concat(es)
                }.call(this)
            }, function() {
                return this._apply("json")
            })
        },
        json: function() {
            var bs;
            return function() {
                return this._applyWithArgs("token", "{"), bs = this._applyWithArgs("listOf", "jsonBinding", ","), this._or(function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case ",":
                                return ",";
                            default:
                                throw fail
                        }
                    }.call(this)
                }, function() {
                    return this._apply("empty")
                }), this._applyWithArgs("token", "}"), ["json"].concat(bs)
            }.call(this)
        },
        varBinding: function() {
            var n, v;
            return function() {
                return n = this._applyWithArgs("token", "name"), v = this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "="), this._apply("expr")
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("empty"), ["get", "undefined"]
                    }.call(this)
                }), ["var", n, v]
            }.call(this)
        },
        stmt: function() {
            var bs, c, t, f, c, s, s, c, vars, i, c, u, s, n, v, e, s, e, c, cs, cs, cs, e, t, e, c, ca, f, e, x, s, e;
            return this._or(function() {
                return this._apply("block")
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "var"), bs = this._applyWithArgs("listOf", "varBinding", ","), this._apply("sc"), ["begin"].concat(bs)
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "if"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), t = this._apply("stmt"), f = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "else"), this._apply("stmt")
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "undefined"]
                        }.call(this)
                    }), ["if", c, t, f]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["while", c, s]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "do"), s = this._apply("stmt"), this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), this._apply("sc"), ["doWhile", s, c]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), i = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "var"), vars = this._applyWithArgs("listOf", "varBinding", ","), ["multiVar", vars]
                        }.call(this)
                    }, function() {
                        return this._apply("expr")
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "undefined"]
                        }.call(this)
                    }), this._applyWithArgs("token", ";"), c = this._or(function() {
                        return this._apply("expr")
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "true"]
                        }.call(this)
                    }), this._applyWithArgs("token", ";"), u = this._or(function() {
                        return this._apply("expr")
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "undefined"]
                        }.call(this)
                    }), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["for", i, c, u, s]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), v = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "var"), n = this._applyWithArgs("token", "name"), ["var", n, ["get", "undefined"]]
                        }.call(this)
                    }, function() {
                        return this._apply("expr")
                    }), this._applyWithArgs("token", "in"), e = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["forIn", v, e, s]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "switch"), this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), cs = this._many(function() {
                        return this._or(function() {
                            return function() {
                                return this._applyWithArgs("token", "case"), c = this._apply("expr"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), ["case", c, cs]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "default"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), ["default", cs]
                            }.call(this)
                        })
                    }), this._applyWithArgs("token", "}"), ["switch", e].concat(cs)
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "break"), this._apply("sc"), ["break"]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "continue"), this._apply("sc"), ["continue"]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "throw"), this._apply("spacesNoNl"), e = this._apply("expr"), this._apply("sc"), ["throw", e]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "try"), t = this._apply("block"), ca = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "catch"), this._applyWithArgs("token", "("), e = this._applyWithArgs("token", "name"), this._applyWithArgs("token", ")"), c = this._apply("block"), [e, c]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["", ["get", "undefined"]]
                        }.call(this)
                    }), f = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "finally"), this._apply("block")
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "undefined"]
                        }.call(this)
                    }), ["try", t].concat(ca).concat([f])
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "return"), e = this._or(function() {
                        return this._apply("expr")
                    }, function() {
                        return function() {
                            return this._apply("empty"), ["get", "undefined"]
                        }.call(this)
                    }), this._apply("sc"), ["return", e]
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", "with"), this._applyWithArgs("token", "("), x = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), ["with", x, s]
                }.call(this)
            }, function() {
                return function() {
                    return e = this._apply("expr"), this._apply("sc"), e
                }.call(this)
            }, function() {
                return function() {
                    return this._applyWithArgs("token", ";"), ["get", "undefined"]
                }.call(this)
            })
        }
    }), LKJSTranslator = objectThatDelegatesTo(BSJSTranslator, {
        regexp: function() {
            var re;
            return function() {
                return re = this._apply("anything")
            }.call(this)
        },
        preopSpace: function() {
            var op, x;
            return function() {
                return op = this._apply("anything"), x = this._apply("trans"), op + " " + x
            }.call(this)
        },
        newExpr: function() {
            var newExpr, args;
            return function() {
                return newExpr = this._apply("trans"), args = this._many(function() {
                    return this._apply("trans")
                }), "new (" + newExpr + ")(" + args.join(",") + ")"
            }.call(this)
        },
        singleVar: function() {
            var name, val;
            return function() {
                return this._form(function() {
                    return function() {
                        return this._applyWithArgs("exactly", "var"), name = this._apply("anything"), val = this._apply("trans")
                    }.call(this)
                }), name + "=" + val
            }.call(this)
        },
        multiVar: function() {
            var xs;
            return function() {
                return this._form(function() {
                    return xs = this._many(function() {
                        return this._apply("singleVar")
                    })
                }), "var " + xs.join(",")
            }.call(this)
        },
        "try": function() {
            var x, name, c, f;
            return function() {
                return x = this._apply("curlyTrans"), name = this._apply("anything"), c = this._apply("curlyTrans"), f = this._apply("curlyTrans"), "try " + x + (name ? "catch(" + name + ")" + c : "") + "finally" + f
            }.call(this)
        }
    }), LKOMetaParser = objectThatDelegatesTo(BSOMetaParser, {
        hostExpr: function() {
            var r;
            return function() {
                return r = this._applyWithArgs("foreign", LKJSParser, "expr"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
        },
        atomicHostExpr: function() {
            var r;
            return function() {
                return r = this._applyWithArgs("foreign", LKJSParser, "semAction"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
        },
        curlyHostExpr: function() {
            var r;
            return function() {
                return r = this._applyWithArgs("foreign", LKJSParser, "curlySemAction"), this._applyWithArgs("foreign", BSJSTranslator, "trans", r)
            }.call(this)
        }
    }), LKOMetaJSParser = objectThatDelegatesTo(LKJSParser, {
        srcElem: function() {
            var r;
            return this._or(function() {
                return function() {
                    return this._apply("spaces"), r = this._applyWithArgs("foreign", LKOMetaParser, "grammar"), this._apply("sc"), r
                }.call(this)
            }, function() {
                return LKJSParser._superApplyWithArgs(this, "srcElem")
            })
        }
    }), LKOMetaJSTranslator = objectThatDelegatesTo(LKJSTranslator, {
        Grammar: function() {
            return this._applyWithArgs("foreign", BSOMetaTranslator, "Grammar")
        }
    }), module("lively.Ometa").requires("lively.Network", "ometa.lively").toRun(function() {
        Object.subclass("OMetaSupport"), Object.extend(OMetaSupport, {
            ometaGrammarDir: URL.codeBase,
            fromFile: function(fileName) {
                var src = OMetaSupport.fileContent(fileName),
                    grammar = OMetaSupport.ometaEval(src);
                return grammar
            },
            translateAndWrite: function(sourceFileName, destFileName, additionalRequirements) {
                var requirementsString = additionalRequirements ? ",'" + additionalRequirements.join("','") + "'" : "",
                    str = Strings.format("module('%s').requires('ometa.lively'%s).toRun(function() {\n%s\n});", destFileName.replace(/\.js$/, "").replace(/\//g, "."), requirementsString, OMetaSupport.translateToJs(OMetaSupport.fileContent(sourceFileName)));
                OMetaSupport.writeGrammar(destFileName, str), lively.morphic.World.current().setStatusMessage(Strings.format("Successfully compiled OMeta grammar %s to %s", sourceFileName, destFileName), Color.green, 3)
            },
            translate: function(source, additionalRequirements, destFileName) {
                destFileName = destFileName || "anonymousOMetaModule";
                var requirementsString = additionalRequirements ? ",'" + additionalRequirements.join("','") + "'" : "",
                    str = Strings.format("module('%s').requires('ometa.lively'%s).toRun(function() {\n%s\n});", destFileName.replace(/\.js$/, "").replace(/\//g, "."), requirementsString, OMetaSupport.translateToJs(source));
                return lively.morphic.World.current().setStatusMessage(Strings.format("Successfully compiled OMeta grammar %s", source.truncate(300)), Color.green, 3), str
            },
            ometaEval: function(src) {
                var jsSrc = OMetaSupport.translateToJs(src);
                return eval(jsSrc)
            },
            translateToJs: function(src) {
                var ometaSrc = OMetaSupport.matchAllWithGrammar(BSOMetaJSParser, "topLevel", src);
                if (!ometaSrc) throw new Error("Problem in translateToJs: Cannot create OMeta Ast from source");
                var jsSrc = OMetaSupport.matchWithGrammar(BSOMetaJSTranslator, "trans", ometaSrc);
                return jsSrc
            },
            matchAllWithGrammar: function(grammar, rule, src, errorHandling) {
                var errorFunc;
                return errorFunc = errorHandling ? errorHandling instanceof Function ? errorHandling : OMetaSupport.handleErrorDebug : OMetaSupport.handleErrorDebug, grammar.matchAll(src, rule, null, errorFunc.curry(src, rule))
            },
            matchWithGrammar: function(grammar, rule, src, errorHandling) {
                var errorFunc;
                return errorFunc = errorHandling ? errorHandling instanceof Function ? errorHandling : OMetaSupport.handleErrorDebug : OMetaSupport.handleErrorDebug, grammar.match(src, rule, null, errorFunc.curry(src, rule))
            },
            handleErrorDebug: function(src, rule, grammarInstance, errorIndex) {
                var charsBefore = 500,
                    charsAfter = 250,
                    msg = "OMeta Error -- " + rule + "\n",
                    startIndex = Math.max(0, errorIndex - charsBefore),
                    stopIndex = Math.min(src.length, errorIndex + charsAfter);
                return msg += src.constructor === Array ? "src = [" + src.toString() + "]" : src.substring(startIndex, errorIndex) + "<--Error-->" + src.substring(errorIndex, stopIndex), console.log(msg), msg
            },
            handleError: function() {},
            fileContent: function(fileName) {
                var url = URL.root.withFilename(fileName);
                return new WebResource(url).get().content
            },
            writeGrammar: function(fileName, src) {
                var url = URL.root.withFilename(fileName);
                return new WebResource(url).put(src)
            }
        })
    }), module("users.timfelgentreff.jsinterpreter.generated.Nodes").requires().toRun(function() {
        Object.subclass("users.timfelgentreff.jsinterpreter.Node"), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Sequence", "testing", {
            isSequence: !0
        }, "initializing", {
            initialize: function($super, pos, children) {
                this.pos = pos, this.children = children, children.forEach(function(node) {
                    node.setParent(this)
                }, this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.children)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.children.join(","))
            }
        }, "conversion", {
            asJS: function(depth) {
                var indent = this.indent(depth || 0);
                return depth = depth || -1, this.children.invoke("asJS", depth + 1).join(";\n" + indent)
            }
        }, "insertion", {
            insertBefore: function(newNode, existingNode) {
                for (var i = 0; i < this.children.length && !(this.children[i].nodesMatching(function(node) {
                        return node === existingNode
                    }).length > 0); i++);
                if (!this.children[i]) throw dbgOn(new Error("insertBefore: " + existingNode + " not in " + this));
                return this.insertAt(newNode, i)
            },
            insertAt: function(newNode, idx) {
                return this.children.pushAt(newNode, idx), newNode.setParent(this), newNode
            }
        }, "accessing", {
            parentSequence: function() {
                return this
            }
        }, "stepping", {
            firstStatement: function() {
                return this.children.length > 0 ? this.children[0].firstStatement() : this
            },
            nextStatement: function($super, node) {
                var idx = this.children.indexOf(node);
                return idx >= 0 && idx < this.children.length - 1 ? this.children[idx + 1] : $super(this)
            },
            isComposite: function() {
                return !0
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitSequence(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Number", "testing", {
            isNumber: !0
        }, "initializing", {
            initialize: function($super, pos, value) {
                this.pos = pos, this.value = value
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.pos, this.value)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.value)
            }
        }, "conversion", {
            asJS: function() {
                return this.value
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitNumber(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.String", "testing", {
            isString: !0
        }, "initializing", {
            initialize: function($super, pos, value) {
                this.pos = pos, this.value = value
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.value + '"')
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.value)
            }
        }, "conversion", {
            asJS: function() {
                return '"' + this.value + '"'
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitString(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Cond", "testing", {
            isCond: !0
        }, "initializing", {
            initialize: function($super, pos, condExpr, trueExpr, falseExpr) {
                this.pos = pos, this.condExpr = condExpr, this.trueExpr = trueExpr, this.falseExpr = falseExpr, condExpr.setParent(this), trueExpr.setParent(this), falseExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr)
            },
            toString: function() {
                return Strings.format("%s(%s?%s:%s)", this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("(%s) ? (%s) : (%s)", this.condExpr.asJS(depth), this.trueExpr.asJS(depth), this.falseExpr.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitCond(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.If", "testing", {
            isIf: !0
        }, "initializing", {
            initialize: function($super, pos, condExpr, trueExpr, falseExpr) {
                this.pos = pos, this.condExpr = condExpr, this.trueExpr = trueExpr.isSequence || this.isUndefined(trueExpr) ? trueExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [trueExpr]), this.falseExpr = falseExpr.isSequence || this.isUndefined(falseExpr) ? falseExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [falseExpr]), condExpr.setParent(this), this.trueExpr.setParent(this), this.falseExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr)
            },
            toString: function() {
                return Strings.format("%s(%s?%s:%s)", this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                var str = Strings.format("if (%s) {%s}", this.condExpr.asJS(depth), this.trueExpr.asJS(depth));
                return this.isUndefined(this.falseExpr) || (str += " else {" + this.falseExpr.asJS(depth) + "}"), str
            }
        }, "stepping", {
            firstStatement: function() {
                return this.condExpr.firstStatement()
            },
            nextStatement: function($super, node) {
                return node === this.condExpr ? this.trueExpr : $super(this)
            },
            isComposite: function() {
                return !0
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitIf(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.While", "testing", {
            isWhile: !0
        }, "initializing", {
            initialize: function($super, pos, condExpr, body) {
                this.pos = pos, this.condExpr = condExpr, this.body = body, condExpr.setParent(this), body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.condExpr, this.body)
            },
            toString: function() {
                return Strings.format("%s(%s?%s)", this.constructor.name, this.condExpr, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("while (%s) {%s}", this.condExpr.asJS(depth), this.body.asJS(depth))
            }
        }, "stepping", {
            firstStatement: function() {
                return this.condExpr.firstStatement()
            },
            nextStatement: function($super, node) {
                return node === this.condExpr ? this.body : node === this.body ? this.condExpr : $super(this)
            },
            isComposite: function() {
                return !0
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitWhile(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.DoWhile", "testing", {
            isDoWhile: !0
        }, "initializing", {
            initialize: function($super, pos, body, condExpr) {
                this.pos = pos, this.body = body, this.condExpr = condExpr, body.setParent(this), condExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.body, this.condExpr)
            },
            toString: function() {
                return Strings.format("%s(%s while%s)", this.constructor.name, this.body, this.condExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("do {%s} while (%s);", this.body.asJS(depth), this.condExpr.asJS(depth))
            }
        }, "stepping", {
            firstStatement: function() {
                return this.body.firstStatement()
            },
            nextStatement: function($super, node) {
                return node === this.condExpr ? this.body : node === this.body ? this.condExpr : $super(this)
            },
            isComposite: function() {
                return !0
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitDoWhile(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.For", "testing", {
            isFor: !0
        }, "initializing", {
            initialize: function($super, pos, init, condExpr, body, upd) {
                this.pos = pos, this.init = init, this.condExpr = condExpr, this.body = body, this.upd = upd, init.setParent(this), condExpr.setParent(this), body.setParent(this), upd.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.init, this.condExpr, this.body, this.upd)
            },
            toString: function() {
                return Strings.format("%s(%s;%s;%s do %s)", this.constructor.name, this.init, this.condExpr, this.upd, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("for (%s; %s; %s) {%s}", this.init.asJS(depth), this.condExpr.asJS(depth), this.upd.asJS(depth), this.body.asJS(depth))
            }
        }, "stepping", {
            firstStatement: function() {
                return this.init.firstStatement()
            },
            nextStatement: function($super, node) {
                return node === this.init || node === this.upd ? this.condExpr : node === this.condExpr ? this.body : node === this.body ? this.upd : $super(this)
            },
            isComposite: function() {
                return !0
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitFor(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ForIn", "testing", {
            isForIn: !0
        }, "initializing", {
            initialize: function($super, pos, name, obj, body) {
                this.pos = pos, this.name = name, this.obj = obj, this.body = body, name.setParent(this), obj.setParent(this), body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.name, this.obj, this.body)
            },
            toString: function() {
                return Strings.format("%s(%s in %s do %s)", this.constructor.name, this.name, this.obj, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("for (%s in %s) {%s}", this.name.asJS(depth), this.obj.asJS(depth), this.body.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitForIn(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Set", "testing", {
            isSet: !0
        }, "initializing", {
            initialize: function($super, pos, left, right) {
                this.pos = pos, this.left = left, this.right = right, left.setParent(this), right.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.left, this.right)
            },
            toString: function() {
                return Strings.format("%s(%s = %s)", this.constructor.name, this.left, this.right)
            }
        }, "conversion", {
            asJS: function(depth) {
                return this.left.asJS(depth) + " = " + this.right.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitSet(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ModifyingSet", "testing", {
            isModifyingSet: !0
        }, "initializing", {
            initialize: function($super, pos, left, name, right) {
                this.pos = pos, this.left = left, this.name = name, this.right = right, left.setParent(this), right.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.left, '"' + this.name + '"', this.right)
            },
            toString: function() {
                return Strings.format("%s(%s %s %s)", this.constructor.name, this.left, this.name, this.right)
            }
        }, "conversion", {
            asJS: function(depth) {
                return this.left.asJS(depth) + " " + this.name + "= " + this.right.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitModifyingSet(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.BinaryOp", "testing", {
            isBinaryOp: !0
        }, "initializing", {
            initialize: function($super, pos, name, left, right) {
                this.pos = pos, this.name = name, this.left = left, this.right = right, left.setParent(this), right.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.left, this.right)
            },
            toString: function() {
                return Strings.format("%s(%s %s %s)", this.constructor.name, this.left, this.name, this.right)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "(" + this.left.asJS(depth) + ") " + this.name + " (" + this.right.asJS(depth) + ")"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitBinaryOp(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.UnaryOp", "testing", {
            isUnaryOp: !0
        }, "initializing", {
            initialize: function($super, pos, name, expr) {
                this.pos = pos, this.name = name, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s%s)", this.constructor.name, this.name, this.expr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "(" + this.name + this.expr.asJS(depth) + ")"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitUnaryOp(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.PreOp", "testing", {
            isPreOp: !0
        }, "initializing", {
            initialize: function($super, pos, name, expr) {
                this.pos = pos, this.name = name, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s%s)", this.constructor.name, this.name, this.expr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "(" + this.name + this.expr.asJS(depth) + ")"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitPreOp(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.PostOp", "testing", {
            isPostOp: !0
        }, "initializing", {
            initialize: function($super, pos, name, expr) {
                this.pos = pos, this.name = name, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s%s)", this.constructor.name, this.expr, this.name)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "(" + this.expr.asJS(depth) + this.name + ")"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitPostOp(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.This", "testing", {
            isThis: !0
        }, "initializing", {
            initialize: function($super, pos) {
                this.pos = pos
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos)
            },
            toString: function() {
                return this.constructor.name
            }
        }, "conversion", {
            asJS: function() {
                return "this"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitThis(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Variable", "testing", {
            isVariable: !0
        }, "initializing", {
            initialize: function($super, pos, name) {
                this.pos = pos, this.name = name
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"')
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.name)
            }
        }, "conversion", {
            asJS: function() {
                return this.name
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitVariable(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.GetSlot", "testing", {
            isGetSlot: !0
        }, "initializing", {
            initialize: function($super, pos, slotName, obj) {
                this.pos = pos, this.slotName = slotName, this.obj = obj, slotName.setParent(this), obj.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.slotName, this.obj)
            },
            toString: function() {
                return Strings.format("%s(%s[%s])", this.constructor.name, this.obj, this.slotName)
            }
        }, "conversion", {
            asJS: function(depth) {
                var objJS = this.obj.asJS(depth);
                return this.obj.isFunction && (objJS = "(" + objJS + ")"), objJS + "[" + this.slotName.asJS(depth) + "]"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitGetSlot(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Break", "testing", {
            isBreak: !0
        }, "initializing", {
            initialize: function($super, pos, label) {
                this.pos = pos, this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], ""), this.label.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.label)
            }
        }, "conversion", {
            asJS: function() {
                return "break" + this.label.asJS()
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitBreak(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Debugger", "testing", {
            isDebugger: !0
        }, "initializing", {
            initialize: function($super, pos) {
                this.pos = pos
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos)
            }
        }, "conversion", {
            asJS: function() {
                return "debugger"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitDebugger(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Continue", "testing", {
            isContinue: !0
        }, "initializing", {
            initialize: function($super, pos, label) {
                this.pos = pos, this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], ""), this.label.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.label)
            }
        }, "conversion", {
            asJS: function() {
                return "continue" + this.label.asJS()
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitContinue(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ArrayLiteral", "testing", {
            isArrayLiteral: !0
        }, "initializing", {
            initialize: function($super, pos, elements) {
                this.pos = pos, this.elements = elements, elements.forEach(function(node) {
                    node.setParent(this)
                }, this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.elements)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.elements.join(","))
            }
        }, "conversion", {
            asJS: function() {
                return "[" + this.elements.invoke("asJS").join(",") + "]"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitArrayLiteral(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Return", "testing", {
            isReturn: !0
        }, "initializing", {
            initialize: function($super, pos, expr) {
                this.pos = pos, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.expr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "return " + this.expr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitReturn(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.With", "testing", {
            isWith: !0
        }, "initializing", {
            initialize: function($super, pos, obj, body) {
                this.pos = pos, this.obj = obj, this.body = body, obj.setParent(this), body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.obj, this.body)
            },
            toString: function() {
                return Strings.format("%s(%s %s)", this.constructor.name, this.obj, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "with (" + this.obj.asJS(depth) + ") {" + this.body.asJS(depth) + "}"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitWith(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Send", "testing", {
            isSend: !0
        }, "initializing", {
            initialize: function($super, pos, property, recv, args) {
                this.pos = pos, this.property = property, this.recv = recv, this.args = args, args.forEach(function(node) {
                    node.setParent(this)
                }, this), property.setParent(this), recv.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.property, this.recv, this.args)
            },
            toString: function() {
                return Strings.format("%s(%s[%s](%s))", this.constructor.name, this.recv, this.property, this.args.join(","))
            }
        }, "conversion", {
            asJS: function(depth) {
                var recvJS = this.recv.asJS(depth);
                return this.recv.isFunction && (recvJS = "(" + recvJS + ")"), Strings.format("%s[%s](%s)", recvJS, this.property.asJS(depth), this.args.invoke("asJS").join(","))
            }
        }, "accessing", {
            getName: function() {
                return this.property
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitSend(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Call", "testing", {
            isCall: !0
        }, "initializing", {
            initialize: function($super, pos, fn, args) {
                this.pos = pos, this.fn = fn, this.args = args, args.forEach(function(node) {
                    node.setParent(this)
                }, this), fn.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.fn, this.args)
            },
            toString: function() {
                return Strings.format("%s(%s(%s))", this.constructor.name, this.fn, this.args.join(","))
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("%s(%s)", this.fn.asJS(depth), this.args.invoke("asJS").join(","))
            }
        }, "accessing", {
            getName: function() {
                return this.fn.name
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitCall(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.New", "testing", {
            isNew: !0
        }, "initializing", {
            initialize: function($super, pos, clsExpr) {
                this.pos = pos, this.clsExpr = clsExpr, clsExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.clsExpr)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.clsExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "new " + this.clsExpr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitNew(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.VarDeclaration", "testing", {
            isVarDeclaration: !0
        }, "initializing", {
            initialize: function($super, pos, name, val) {
                this.pos = pos, this.name = name, this.val = val, val.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.val)
            },
            toString: function() {
                return Strings.format("%s(%s = %s)", this.constructor.name, this.name, this.val)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("var %s = %s", this.name, this.val.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitVarDeclaration(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Throw", "testing", {
            isThrow: !0
        }, "initializing", {
            initialize: function($super, pos, expr) {
                this.pos = pos, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.expr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "throw " + this.expr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitThrow(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.TryCatchFinally", "testing", {
            isTryCatchFinally: !0
        }, "initializing", {
            initialize: function($super, pos, trySeq, err, catchSeq, finallySeq) {
                this.pos = pos, this.trySeq = trySeq, this.err = err, this.catchSeq = catchSeq, this.finallySeq = finallySeq, trySeq.setParent(this), err.setParent(this), catchSeq.setParent(this), finallySeq.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.trySeq, '"' + this.err.name + '"', this.catchSeq, this.finallySeq)
            },
            toString: function() {
                return Strings.format("%s(%s %s %s)", this.constructor.name, this.trySeq, this.catchSeq, this.finallySeq)
            }
        }, "conversion", {
            asJS: function(depth) {
                var baseIndent = this.indent(depth - 1),
                    indent = this.indent(depth),
                    str = "try {\n" + indent + this.trySeq.asJS(depth) + "\n" + baseIndent + "}";
                return this.isUndefined(this.catchSeq) || (str += " catch(" + this.err.name + ") {\n" + indent + this.catchSeq.asJS(depth) + "\n" + baseIndent + "}"), this.isUndefined(this.finallySeq) || (str += " finally {\n" + indent + this.finallySeq.asJS(depth) + "\n" + baseIndent + "}"), str
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitTryCatchFinally(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Function", "testing", {
            isFunction: !0
        }, "initializing", {
            initialize: function($super, pos, body, args) {
                this.pos = pos, this.body = body, this.args = args, args.forEach(function(node) {
                    node.setParent(this)
                }, this), body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.body, this.args.collect(function(ea) {
                    return '"' + ea.name + '"'
                }))
            },
            toString: function() {
                return Strings.format("%s(function %s(%s) %s)", this.constructor.name, this.name(), this.argNames().join(","), this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("function%s(%s) {\n%s\n}", this.name() ? " " + this.name() : "", this.argNames().join(","), this.indent(depth + 1) + this.body.asJS(depth + 1))
            }
        }, "accessing", {
            name: function() {
                return this._parent && this._parent.isVarDeclaration ? this._parent.name : void 0
            },
            parentFunction: function() {
                return this
            },
            argNames: function() {
                return this.args.collect(function(a) {
                    return a.name
                })
            },
            statements: function() {
                return this.body.children
            }
        }, "stepping", {
            firstStatement: function() {
                return this.body.firstStatement()
            },
            nextStatement: function() {
                return null
            },
            isComposite: function() {
                return !0
            }
        }, "evaluation", {
            eval: function() {
                return new Function(this.argNames().join(","), this.body.asJS())
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitFunction(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ObjectLiteral", "testing", {
            isObjectLiteral: !0
        }, "initializing", {
            initialize: function($super, pos, properties) {
                this.pos = pos, this.properties = properties, properties.forEach(function(node) {
                    node.setParent(this)
                }, this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.properties)
            },
            toString: function() {
                return Strings.format("%s({%s})", this.constructor.name, this.properties.join(","))
            }
        }, "conversion", {
            asJS: function() {
                return "{" + this.properties.invoke("asJS").join(",") + "}"
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitObjectLiteral(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ObjProperty", "testing", {
            isObjProperty: !0
        }, "initializing", {
            initialize: function($super, pos, name, property) {
                this.pos = pos, this.name = name, this.property = property, property.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.property)
            },
            toString: function() {
                return Strings.format("%s(%s: %s)", this.constructor.name, this.name, this.property)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format('"%s": %s', this.name, this.property.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitObjProperty(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ObjPropertyGet", "testing", {
            isObjPropertyGet: !0
        }, "initializing", {
            initialize: function($super, pos, name, body) {
                this.pos = pos, this.name = name, this.body = body, body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.body)
            },
            toString: function() {
                return Strings.format("%s(%s() { %s })", this.constructor.name, this.name, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format('get "%s"() { %s }', this.name, this.body.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitObjPropertyGet(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.ObjPropertySet", "testing", {
            isObjPropertySet: !0
        }, "initializing", {
            initialize: function($super, pos, name, body, arg) {
                this.pos = pos, this.name = name, this.body = body, this.arg = arg, body.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.body, this.arg)
            },
            toString: function() {
                return Strings.format("%s(%s(%s) { %s })", this.constructor.name, this.name, this.arg, this.body)
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format('set "%s"(%s) { %s }', this.name, this.arg, this.body.asJS(depth))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitObjPropertySet(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Switch", "testing", {
            isSwitch: !0
        }, "initializing", {
            initialize: function($super, pos, expr, cases) {
                this.pos = pos, this.expr = expr, this.cases = cases, cases.forEach(function(node) {
                    node.setParent(this)
                }, this), expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.expr, this.cases)
            },
            toString: function() {
                return Strings.format("%s(%s %s)", this.constructor.name, this.expr, this.cases.join("\n"))
            }
        }, "conversion", {
            asJS: function(depth) {
                return Strings.format("switch (%s) {%s}", this.expr.asJS(depth), this.cases.invoke("asJS").join("\n"))
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitSwitch(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Case", "testing", {
            isCase: !0
        }, "initializing", {
            initialize: function($super, pos, condExpr, thenExpr) {
                this.pos = pos, this.condExpr = condExpr, this.thenExpr = thenExpr, condExpr.setParent(this), thenExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.condExpr, this.thenExpr)
            },
            toString: function() {
                return Strings.format("%s(%s: %s)", this.constructor.name, this.condExpr, this.thenExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "case " + this.condExpr.asJS(depth) + ": " + this.thenExpr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitCase(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Default", "testing", {
            isDefault: !0
        }, "initializing", {
            initialize: function($super, pos, defaultExpr) {
                this.pos = pos, this.defaultExpr = defaultExpr, defaultExpr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.defaultExpr)
            },
            toString: function() {
                return Strings.format("%s(default: %s)", this.constructor.name, this.defaultExpr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return "default: " + this.defaultExpr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitDefault(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Regex", "testing", {
            isRegex: !0
        }, "initializing", {
            initialize: function($super, pos, exprString, flags) {
                this.pos = pos, this.exprString = exprString, this.flags = flags
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, this.exprString, this.flags)
            },
            toString: function() {
                return Strings.format("(/%s/%s)", this.exprString, this.flags)
            }
        }, "conversion", {
            asJS: function() {
                return "/" + this.exprString + "/" + this.flags
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitRegex(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.Label", "testing", {
            isLabel: !0
        }, "initializing", {
            initialize: function($super, pos, name) {
                this.pos = pos, this.name = name
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"')
            },
            toString: function() {
                return Strings.format("%s(%s)", this.constructor.name, this.name)
            }
        }, "conversion", {
            asJS: function() {
                return this.name
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitLabel(this)
            }
        }), users.timfelgentreff.jsinterpreter.Node.subclass("users.timfelgentreff.jsinterpreter.LabelDeclaration", "testing", {
            isLabelDeclaration: !0
        }, "initializing", {
            initialize: function($super, pos, name, expr) {
                this.pos = pos, this.name = name, this.expr = expr, expr.setParent(this)
            }
        }, "debugging", {
            printConstruction: function() {
                return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
            },
            toString: function() {
                return Strings.format("%s(%s is %s)", this.constructor.name, this.name, this.expr)
            }
        }, "conversion", {
            asJS: function(depth) {
                return this.name + ": " + this.expr.asJS(depth)
            }
        }, "visiting", {
            accept: function(visitor) {
                return visitor.visitLabelDeclaration(this)
            }
        }), Object.subclass("users.timfelgentreff.jsinterpreter.Visitor", "visiting", {
            visit: function(node) {
                return node.accept(this)
            },
            visitSequence: function() {},
            visitNumber: function() {},
            visitString: function() {},
            visitCond: function() {},
            visitIf: function() {},
            visitWhile: function() {},
            visitDoWhile: function() {},
            visitFor: function() {},
            visitForIn: function() {},
            visitSet: function() {},
            visitModifyingSet: function() {},
            visitBinaryOp: function() {},
            visitUnaryOp: function() {},
            visitPreOp: function() {},
            visitPostOp: function() {},
            visitThis: function() {},
            visitVariable: function() {},
            visitGetSlot: function() {},
            visitBreak: function() {},
            visitDebugger: function() {},
            visitContinue: function() {},
            visitArrayLiteral: function() {},
            visitReturn: function() {},
            visitWith: function() {},
            visitSend: function() {},
            visitCall: function() {},
            visitNew: function() {},
            visitVarDeclaration: function() {},
            visitThrow: function() {},
            visitTryCatchFinally: function() {},
            visitFunction: function() {},
            visitObjectLiteral: function() {},
            visitObjProperty: function() {},
            visitObjPropertyGet: function() {},
            visitObjPropertySet: function() {},
            visitSwitch: function() {},
            visitCase: function() {},
            visitDefault: function() {},
            visitRegex: function() {},
            visitLabel: function() {},
            visitLabelDeclaration: function() {}
        })
    }), module("users.timfelgentreff.jsinterpreter.generated.Translator").requires("ometa.lively").toRun(function() {
        JSTranslator = objectThatDelegatesTo(Parser, {
            trans: function() {
                var t, ans;
                return function() {
                    return this._form(function() {
                        return function() {
                            return t = this._apply("anything"), ans = this._applyWithArgs("apply", t)
                        }.call(this)
                    }), ans
                }.call(this)
            },
            begin: function() {
                var pos, children;
                return function() {
                    return pos = this._apply("anything"), children = this._many(function() {
                        return this._apply("trans")
                    }), this._apply("end"), new users.timfelgentreff.jsinterpreter.Sequence(pos, children)
                }.call(this)
            },
            number: function() {
                var pos, value;
                return function() {
                    return pos = this._apply("anything"), value = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Number(pos, value)
                }.call(this)
            },
            string: function() {
                var pos, value;
                return function() {
                    return pos = this._apply("anything"), value = this._apply("anything"), new users.timfelgentreff.jsinterpreter.String(pos, value)
                }.call(this)
            },
            condExpr: function() {
                var pos, condExpr, trueExpr, falseExpr;
                return function() {
                    return pos = this._apply("anything"), condExpr = this._apply("trans"), trueExpr = this._apply("trans"), falseExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Cond(pos, condExpr, trueExpr, falseExpr)
                }.call(this)
            },
            "if": function() {
                var pos, condExpr, trueExpr, falseExpr;
                return function() {
                    return pos = this._apply("anything"), condExpr = this._apply("trans"), trueExpr = this._apply("trans"), falseExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.If(pos, condExpr, trueExpr, falseExpr)
                }.call(this)
            },
            "while": function() {
                var pos, condExpr, body;
                return function() {
                    return pos = this._apply("anything"), condExpr = this._apply("trans"), body = this._apply("trans"), new users.timfelgentreff.jsinterpreter.While(pos, condExpr, body)
                }.call(this)
            },
            doWhile: function() {
                var pos, body, condExpr;
                return function() {
                    return pos = this._apply("anything"), body = this._apply("trans"), condExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.DoWhile(pos, body, condExpr)
                }.call(this)
            },
            "for": function() {
                var pos, init, condExpr, body, upd;
                return function() {
                    return pos = this._apply("anything"), init = this._apply("trans"), condExpr = this._apply("trans"), body = this._apply("trans"), upd = this._apply("trans"), new users.timfelgentreff.jsinterpreter.For(pos, init, condExpr, body, upd)
                }.call(this)
            },
            forIn: function() {
                var pos, name, obj, body;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("trans"), obj = this._apply("trans"), body = this._apply("trans"), new users.timfelgentreff.jsinterpreter.ForIn(pos, name, obj, body)
                }.call(this)
            },
            set: function() {
                var pos, left, right;
                return function() {
                    return pos = this._apply("anything"), left = this._apply("trans"), right = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Set(pos, left, right)
                }.call(this)
            },
            mset: function() {
                var pos, left, name, right;
                return function() {
                    return pos = this._apply("anything"), left = this._apply("trans"), name = this._apply("anything"), right = this._apply("trans"), new users.timfelgentreff.jsinterpreter.ModifyingSet(pos, left, name, right)
                }.call(this)
            },
            binop: function() {
                var pos, name, left, right;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), left = this._apply("trans"), right = this._apply("trans"), new users.timfelgentreff.jsinterpreter.BinaryOp(pos, name, left, right)
                }.call(this)
            },
            unop: function() {
                var pos, name, expr;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), expr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.UnaryOp(pos, name, expr)
                }.call(this)
            },
            preop: function() {
                var pos, name, expr;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), expr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.PreOp(pos, name, expr)
                }.call(this)
            },
            postop: function() {
                var pos, name, expr;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), expr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.PostOp(pos, name, expr)
                }.call(this)
            },
            "this": function() {
                var pos;
                return function() {
                    return pos = this._apply("anything"), new users.timfelgentreff.jsinterpreter.This(pos)
                }.call(this)
            },
            get: function() {
                var pos, name;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Variable(pos, name)
                }.call(this)
            },
            getp: function() {
                var pos, slotName, obj;
                return function() {
                    return pos = this._apply("anything"), slotName = this._apply("trans"), obj = this._apply("trans"), new users.timfelgentreff.jsinterpreter.GetSlot(pos, slotName, obj)
                }.call(this)
            },
            "break": function() {
                var pos;
                return function() {
                    return pos = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Break(pos)
                }.call(this)
            },
            "debugger": function() {
                var pos;
                return function() {
                    return pos = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Debugger(pos)
                }.call(this)
            },
            "continue": function() {
                var pos;
                return function() {
                    return pos = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Continue(pos)
                }.call(this)
            },
            arr: function() {
                var pos, elements;
                return function() {
                    return pos = this._apply("anything"), elements = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.ArrayLiteral(pos, elements)
                }.call(this)
            },
            "return": function() {
                var pos, expr;
                return function() {
                    return pos = this._apply("anything"), expr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Return(pos, expr)
                }.call(this)
            },
            "with": function() {
                var pos, obj, body;
                return function() {
                    return pos = this._apply("anything"), obj = this._apply("trans"), body = this._apply("trans"), new users.timfelgentreff.jsinterpreter.With(pos, obj, body)
                }.call(this)
            },
            send: function() {
                var pos, property, recv, args;
                return function() {
                    return pos = this._apply("anything"), property = this._apply("trans"), recv = this._apply("trans"), args = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.Send(pos, property, recv, args)
                }.call(this)
            },
            call: function() {
                var pos, fn, args;
                return function() {
                    return pos = this._apply("anything"), fn = this._apply("trans"), args = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.Call(pos, fn, args)
                }.call(this)
            },
            "new": function() {
                var pos, clsExpr;
                return function() {
                    return pos = this._apply("anything"), clsExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.New(pos, clsExpr)
                }.call(this)
            },
            "var": function() {
                var pos, name, val;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), val = this._apply("trans"), new users.timfelgentreff.jsinterpreter.VarDeclaration(pos, name, val)
                }.call(this)
            },
            "throw": function() {
                var pos, expr;
                return function() {
                    return pos = this._apply("anything"), expr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Throw(pos, expr)
                }.call(this)
            },
            "try": function() {
                var pos, trySeq, err, catchSeq, finallySeq;
                return function() {
                    return pos = this._apply("anything"), trySeq = this._apply("trans"), err = this._apply("trans"), catchSeq = this._apply("trans"), finallySeq = this._apply("trans"), new users.timfelgentreff.jsinterpreter.TryCatchFinally(pos, trySeq, err, catchSeq, finallySeq)
                }.call(this)
            },
            func: function() {
                var pos, body, args;
                return function() {
                    return pos = this._apply("anything"), body = this._apply("trans"), args = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.Function(pos, body, args)
                }.call(this)
            },
            json: function() {
                var pos, properties;
                return function() {
                    return pos = this._apply("anything"), properties = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.ObjectLiteral(pos, properties)
                }.call(this)
            },
            binding: function() {
                var pos, name, property;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), property = this._apply("trans"), new users.timfelgentreff.jsinterpreter.ObjProperty(pos, name, property)
                }.call(this)
            },
            jsonGetter: function() {
                var pos, name, body;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), body = this._apply("trans"), new users.timfelgentreff.jsinterpreter.ObjPropertyGet(pos, name, body)
                }.call(this)
            },
            jsonSetter: function() {
                var pos, name, body, arg;
                return function() {
                    return pos = this._apply("anything"), name = this._apply("anything"), body = this._apply("trans"), arg = this._apply("anything"), new users.timfelgentreff.jsinterpreter.ObjPropertySet(pos, name, body, arg)
                }.call(this)
            },
            "switch": function() {
                var pos, expr, cases;
                return function() {
                    return pos = this._apply("anything"), expr = this._apply("trans"), cases = this._many(function() {
                        return this._apply("trans")
                    }), new users.timfelgentreff.jsinterpreter.Switch(pos, expr, cases)
                }.call(this)
            },
            "case": function() {
                var pos, condExpr, thenExpr;
                return function() {
                    return pos = this._apply("anything"), condExpr = this._apply("trans"), thenExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Case(pos, condExpr, thenExpr)
                }.call(this)
            },
            "default": function() {
                var pos, defaultExpr;
                return function() {
                    return pos = this._apply("anything"), defaultExpr = this._apply("trans"), new users.timfelgentreff.jsinterpreter.Default(pos, defaultExpr)
                }.call(this)
            },
            regex: function() {
                var pos, exprString, flags;
                return function() {
                    return pos = this._apply("anything"), exprString = this._apply("anything"), flags = this._apply("anything"), new users.timfelgentreff.jsinterpreter.Regex(pos, exprString, flags)
                }.call(this)
            }
        })
    }), module("users.timfelgentreff.jsinterpreter.LivelyJSParser").requires("ometa.lively").toRun(function() {
        LivelyJSParser = objectThatDelegatesTo(Parser, {
            whereAreYou: function() {
                return function() {
                    var charsBefore = 120,
                        charsAfter = 120,
                        src = this._originalInput.arr,
                        startIndex = Math.max(0, this.pos() - charsBefore),
                        stopIndex = Math.min(src.length, this.pos() + charsAfter),
                        msg = src.substring(startIndex, this.pos()) + "<--I am here-->" + src.substring(this.pos(), stopIndex);
                    return msg += "\nRules: " + this._ruleStack, msg += "\nStack: " + this.stack, alert(msg), !0
                }.call(this)
            },
            fromTo: function() {
                var x, y;
                return function() {
                    return x = this._apply("anything"), y = this._apply("anything"), this._applyWithArgs("seq", x), this._many(function() {
                        return function() {
                            return this._not(function() {
                                return this._applyWithArgs("seq", y)
                            }), this._apply("char")
                        }.call(this)
                    }), this._applyWithArgs("seq", y)
                }.call(this)
            },
            fromToWithout: function() {
                var x, y;
                return function() {
                    return x = this._apply("anything"), y = this._apply("anything"), this._applyWithArgs("seq", x), this._many(function() {
                        return function() {
                            return this._not(function() {
                                return this._applyWithArgs("seq", y)
                            }), this._apply("char")
                        }.call(this)
                    })
                }.call(this)
            },
            space: function() {
                return this._or(function() {
                    return Parser._superApplyWithArgs(this, "space")
                }, function() {
                    return this._applyWithArgs("fromToWithout", "//", "\n")
                }, function() {
                    return this._applyWithArgs("fromTo", "//", "end")
                }, function() {
                    return this._applyWithArgs("fromTo", "/*", "*/")
                })
            },
            nameFirst: function() {
                return this._or(function() {
                    return this._apply("letter")
                }, function() {
                    return function() {
                        switch (this._apply("anything")) {
                            case "$":
                                return "$";
                            case "_":
                                return "_";
                            default:
                                throw fail
                        }
                    }.call(this)
                })
            },
            nameRest: function() {
                return this._or(function() {
                    return this._apply("nameFirst")
                }, function() {
                    return this._apply("digit")
                })
            },
            iName: function() {
                var r;
                return function() {
                    return r = this._applyWithArgs("firstAndRest", "nameFirst", "nameRest"), r.join("")
                }.call(this)
            },
            isKeyword: function() {
                var x;
                return function() {
                    return x = this._apply("anything"), this._pred(LivelyJSParser._isKeyword(x))
                }.call(this)
            },
            name: function() {
                var p1, n, p2;
                return function() {
                    return p1 = this._apply("pos"), n = this._apply("iName"), this._not(function() {
                        return this._applyWithArgs("isKeyword", n)
                    }), p2 = this._apply("pos"), ["name", [p1, p2], n]
                }.call(this)
            },
            keyword: function() {
                var p1, k, p2;
                return function() {
                    return p1 = this._apply("pos"), k = this._apply("iName"), this._applyWithArgs("isKeyword", k), p2 = this._apply("pos"), [k, [p1, p2], k]
                }.call(this)
            },
            hexDigit: function() {
                var x, v;
                return function() {
                    return x = this._apply("char"), v = this.hexDigits.indexOf(x.toLowerCase()), this._pred(v >= 0), v
                }.call(this)
            },
            hexLit: function() {
                var n, d;
                return this._or(function() {
                    return function() {
                        return n = this._apply("hexLit"), d = this._apply("hexDigit"), 16 * n + d
                    }.call(this)
                }, function() {
                    return this._apply("hexDigit")
                })
            },
            number: function() {
                var p1, n, p2, fs, p2, ws, fs, sig, exp, p2;
                return function() {
                    return p1 = this._apply("pos"), this._or(function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case "0":
                                    return function() {
                                        return this._applyWithArgs("exactly", "x"), n = this._apply("hexLit"), p2 = this._apply("pos"), ["number", [p1, p2], n]
                                    }.call(this);
                                case ".":
                                    return function() {
                                        return fs = this._many1(function() {
                                            return this._apply("digit")
                                        }), p2 = this._apply("pos"), ["number", [p1, p2], parseFloat("." + fs.join(""))]
                                    }.call(this);
                                default:
                                    throw fail
                            }
                        }.call(this)
                    }, function() {
                        return function() {
                            return ws = this._many1(function() {
                                return this._apply("digit")
                            }), fs = this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case ".":
                                            return this._many1(function() {
                                                return this._apply("digit")
                                            });
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return function() {
                                    return this._apply("empty"), []
                                }.call(this)
                            }), exp = this._or(function() {
                                return function() {
                                    switch (this._apply("anything")) {
                                        case "e":
                                            return function() {
                                                return sig = this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "+":
                                                                return "+";
                                                            case "-":
                                                                return "-";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return function() {
                                                        return this._apply("empty"), ""
                                                    }.call(this)
                                                }), this._many1(function() {
                                                    return this._apply("digit")
                                                })
                                            }.call(this);
                                        default:
                                            throw fail
                                    }
                                }.call(this)
                            }, function() {
                                return function() {
                                    return this._apply("empty"), []
                                }.call(this)
                            }), p2 = this._apply("pos"), ["number", [p1, p2], parseFloat(ws.join("") + "." + fs.join("") + "e" + sig + exp.join(""))]
                        }.call(this)
                    })
                }.call(this)
            },
            escapeChar: function() {
                var c;
                return function() {
                    return this._applyWithArgs("exactly", "\\"), c = this._apply("char"), ometaUnescape("\\" + c)
                }.call(this)
            },
            str: function() {
                var p1, cs, p2, cs, p2, cs, p2, n, p2;
                return function() {
                    return p1 = this._apply("pos"), this._or(function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case '"':
                                    return this._or(function() {
                                        return function() {
                                            switch (this._apply("anything")) {
                                                case '"':
                                                    return function() {
                                                        return this._applyWithArgs("exactly", '"'), cs = this._many(function() {
                                                            return this._or(function() {
                                                                return this._apply("escapeChar")
                                                            }, function() {
                                                                return function() {
                                                                    return this._not(function() {
                                                                        return function() {
                                                                            return this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), '"""'
                                                                        }.call(this)
                                                                    }), this._apply("char")
                                                                }.call(this)
                                                            })
                                                        }), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), this._applyWithArgs("exactly", '"'), p2 = this._apply("pos"), ["string", [p1, p2], cs.join("")]
                                                    }.call(this);
                                                default:
                                                    throw fail
                                            }
                                        }.call(this)
                                    }, function() {
                                        return function() {
                                            return cs = this._many(function() {
                                                return this._or(function() {
                                                    return this._apply("escapeChar")
                                                }, function() {
                                                    return function() {
                                                        return this._not(function() {
                                                            return this._applyWithArgs("exactly", '"')
                                                        }), this._apply("char")
                                                    }.call(this)
                                                })
                                            }), this._applyWithArgs("exactly", '"'), p2 = this._apply("pos"), ["string", [p1, p2], cs.join("")]
                                        }.call(this)
                                    });
                                case "'":
                                    return function() {
                                        return cs = this._many(function() {
                                            return this._or(function() {
                                                return this._apply("escapeChar")
                                            }, function() {
                                                return function() {
                                                    return this._not(function() {
                                                        return this._applyWithArgs("exactly", "'")
                                                    }), this._apply("char")
                                                }.call(this)
                                            })
                                        }), this._applyWithArgs("exactly", "'"), p2 = this._apply("pos"), ["string", [p1, p2], cs.join("")]
                                    }.call(this);
                                default:
                                    throw fail
                            }
                        }.call(this)
                    }, function() {
                        return function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case "#":
                                        return "#";
                                    case "`":
                                        return "`";
                                    default:
                                        throw fail
                                }
                            }.call(this), n = this._apply("iName"), p2 = this._apply("pos"), ["string", [p1, p2], n]
                        }.call(this)
                    })
                }.call(this)
            },
            special: function() {
                var p1, s, p2;
                return function() {
                    return p1 = this._apply("pos"), s = function() {
                        switch (this._apply("anything")) {
                            case "(":
                                return "(";
                            case ")":
                                return ")";
                            case "{":
                                return "{";
                            case "}":
                                return "}";
                            case "[":
                                return "[";
                            case "]":
                                return "]";
                            case ",":
                                return ",";
                            case ";":
                                return ";";
                            case "?":
                                return "?";
                            case ":":
                                return ":";
                            case "!":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "=":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "=":
                                                                return "!==";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return "!="
                                                });
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "!"
                                });
                            case "=":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "=":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "=":
                                                                return "===";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return "=="
                                                });
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "="
                                });
                            case ">":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case ">":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case ">":
                                                                return ">>>";
                                                            case "=":
                                                                return ">>=";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return ">>"
                                                });
                                            case "=":
                                                return ">=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return ">"
                                });
                            case "<":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "<":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "=":
                                                                return "<<=";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return "<<"
                                                });
                                            case "=":
                                                return "<=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "<"
                                });
                            case "+":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "+":
                                                return "++";
                                            case "=":
                                                return "+=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "+"
                                });
                            case "-":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "-":
                                                return "--";
                                            case "=":
                                                return "-=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "-"
                                });
                            case "*":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "=":
                                                return "*=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "*"
                                });
                            case "~":
                                return "~";
                            case "/":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "=":
                                                return "/=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "/"
                                });
                            case "%":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "=":
                                                return "%=";
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "%"
                                });
                            case "&":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "&":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "=":
                                                                return "&&=";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return "&&"
                                                });
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "&"
                                });
                            case "|":
                                return this._or(function() {
                                    return function() {
                                        switch (this._apply("anything")) {
                                            case "|":
                                                return this._or(function() {
                                                    return function() {
                                                        switch (this._apply("anything")) {
                                                            case "=":
                                                                return "||=";
                                                            default:
                                                                throw fail
                                                        }
                                                    }.call(this)
                                                }, function() {
                                                    return "||"
                                                });
                                            default:
                                                throw fail
                                        }
                                    }.call(this)
                                }, function() {
                                    return "|"
                                });
                            case ".":
                                return ".";
                            case "^":
                                return "^";
                            default:
                                throw fail
                        }
                    }.call(this), p2 = this._apply("pos"), [s, [p1, p2], s]
                }.call(this)
            },
            tok: function() {
                return function() {
                    return this._apply("spaces"), this._or(function() {
                        return this._apply("name")
                    }, function() {
                        return this._apply("keyword")
                    }, function() {
                        return this._apply("number")
                    }, function() {
                        return this._apply("str")
                    }, function() {
                        return this._apply("special")
                    })
                }.call(this)
            },
            toks: function() {
                var ts;
                return function() {
                    return ts = this._many(function() {
                        return this._apply("token")
                    }), this._apply("spaces"), this._apply("end"), ts
                }.call(this)
            },
            token: function() {
                var tt, t;
                return function() {
                    return tt = this._apply("anything"), t = this._apply("tok"), this._pred(t[0] == tt), t[2]
                }.call(this)
            },
            spacesNoNl: function() {
                return this._many(function() {
                    return function() {
                        return this._not(function() {
                            return this._applyWithArgs("exactly", "\n")
                        }), this._apply("space")
                    }.call(this)
                })
            },
            expr: function() {
                var p1, f, s, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), f = this._apply("exprPart"), this._applyWithArgs("token", ","), s = this._apply("expr"), p2 = this._apply("pos"), ["begin", [p1, p2], f, s]
                    }.call(this)
                }, function() {
                    return this._apply("exprPart")
                })
            },
            exprPart: function() {
                var p1, e, t, f, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2, rhs, p2;
                return function() {
                    return p1 = this._apply("pos"), e = this._apply("ternaryExpr"), this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "?"), t = this._apply("exprPart"), this._applyWithArgs("token", ":"), f = this._apply("exprPart"), p2 = this._apply("pos"), ["condExpr", [p1, p2], e, t, f]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["set", [p1, p2], e, rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "+="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "+", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "-="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "-", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "*="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "*", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "/="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "/", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "%="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "%", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "&="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "&", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "&&="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "&&", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "|="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "|", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "||="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "||", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "^="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "^", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", ">>="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, ">>", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", "<<="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, "<<", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._applyWithArgs("token", ">>>="), rhs = this._apply("exprPart"), p2 = this._apply("pos"), ["mset", [p1, p2], e, ">>>", rhs]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), e
                        }.call(this)
                    })
                }.call(this)
            },
            ternaryExpr: function() {
                var p1, e, t, f, p2;
                return function() {
                    return p1 = this._apply("pos"), e = this._apply("orExpr"), this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "?"), t = this._apply("orExpr"), this._applyWithArgs("token", ":"), f = this._apply("orExpr"), p2 = this._apply("pos"), ["condExpr", [p1, p2], e, t, f]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), e
                        }.call(this)
                    })
                }.call(this)
            },
            orExpr: function() {
                var p1, x, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("orExpr"), this._applyWithArgs("token", "||"), y = this._apply("andExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], "||", x, y]
                    }.call(this)
                }, function() {
                    return this._apply("andExpr")
                })
            },
            andExpr: function() {
                var p1, x, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("andExpr"), this._applyWithArgs("token", "&&"), y = this._apply("bitOrExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], "&&", x, y]
                    }.call(this)
                }, function() {
                    return this._apply("bitOrExpr")
                })
            },
            bitOrExpr: function() {
                var p1, x, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("bitXorExpr"), this._applyWithArgs("token", "|"), y = this._apply("bitOrExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], "|", x, y]
                    }.call(this)
                }, function() {
                    return this._apply("bitXorExpr")
                })
            },
            bitXorExpr: function() {
                var p1, x, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("bitAndExpr"), this._applyWithArgs("token", "^"), y = this._apply("bitXorExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], "^", x, y]
                    }.call(this)
                }, function() {
                    return this._apply("bitAndExpr")
                })
            },
            bitAndExpr: function() {
                var p1, x, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("eqExpr"), this._applyWithArgs("token", "&"), y = this._apply("bitAndExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], "&", x, y]
                    }.call(this)
                }, function() {
                    return this._apply("eqExpr")
                })
            },
            eqExpr: function() {
                var p1, x, op, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("eqExpr"), op = this._or(function() {
                            return this._applyWithArgs("token", "==")
                        }, function() {
                            return this._applyWithArgs("token", "!=")
                        }, function() {
                            return this._applyWithArgs("token", "===")
                        }, function() {
                            return this._applyWithArgs("token", "!==")
                        }), y = this._apply("relExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], op, x, y]
                    }.call(this)
                }, function() {
                    return this._apply("relExpr")
                })
            },
            relExpr: function() {
                var p1, x, op, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("relExpr"), op = this._or(function() {
                            return this._applyWithArgs("token", ">")
                        }, function() {
                            return this._applyWithArgs("token", ">=")
                        }, function() {
                            return this._applyWithArgs("token", "<")
                        }, function() {
                            return this._applyWithArgs("token", "<=")
                        }, function() {
                            return this._applyWithArgs("token", "instanceof")
                        }, function() {
                            return this._applyWithArgs("token", "in")
                        }), y = this._apply("shiftExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], op, x, y]
                    }.call(this)
                }, function() {
                    return this._apply("shiftExpr")
                })
            },
            shiftExpr: function() {
                var p1, x, op, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("shiftExpr"), op = this._or(function() {
                            return this._applyWithArgs("token", ">>")
                        }, function() {
                            return this._applyWithArgs("token", "<<")
                        }, function() {
                            return this._applyWithArgs("token", ">>>")
                        }), y = this._apply("addExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], op, x, y]
                    }.call(this)
                }, function() {
                    return this._apply("addExpr")
                })
            },
            addExpr: function() {
                var p1, x, op, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("addExpr"), op = this._or(function() {
                            return this._applyWithArgs("token", "+")
                        }, function() {
                            return this._applyWithArgs("token", "-")
                        }), y = this._apply("mulExpr"), p2 = this._apply("pos"), ["binop", [p1, p2], op, x, y]
                    }.call(this)
                }, function() {
                    return this._apply("mulExpr")
                })
            },
            mulExpr: function() {
                var p1, x, op, y, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), x = this._apply("mulExpr"), op = this._or(function() {
                            return this._applyWithArgs("token", "*")
                        }, function() {
                            return this._applyWithArgs("token", "/")
                        }, function() {
                            return this._applyWithArgs("token", "%")
                        }), y = this._apply("unary"), p2 = this._apply("pos"), ["binop", [p1, p2], op, x, y]
                    }.call(this)
                }, function() {
                    return this._apply("unary")
                })
            },
            unary: function() {
                var p1, p, p2, p, p2, p, p2, p, p2, p, p2, p, p2, p, p2, p, p2, p, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), this._or(function() {
                            return function() {
                                return this._applyWithArgs("token", "-"), p = this._apply("postfix"), p2 = this._apply("pos"), ["unop", [p1, p2], "-", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "+"), p = this._apply("postfix"), p2 = this._apply("pos"), ["unop", [p1, p2], "+", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "++"), p = this._apply("postfix"), p2 = this._apply("pos"), ["preop", [p1, p2], "++", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "--"), p = this._apply("postfix"), p2 = this._apply("pos"), ["preop", [p1, p2], "--", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "!"), p = this._apply("unary"), p2 = this._apply("pos"), ["unop", [p1, p2], "!", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "~"), p = this._apply("unary"), p2 = this._apply("pos"), ["unop", [p1, p2], "~", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "void"), p = this._apply("unary"), p2 = this._apply("pos"), ["unop", [p1, p2], "void", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "delete"), p = this._apply("unary"), p2 = this._apply("pos"), ["unop", [p1, p2], "delete", p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "typeof"), p = this._apply("unary"), p2 = this._apply("pos"), ["unop", [p1, p2], "typeof", p]
                            }.call(this)
                        })
                    }.call(this)
                }, function() {
                    return this._apply("postfix")
                })
            },
            postfix: function() {
                var p1, p, p2, p2;
                return function() {
                    return p1 = this._apply("pos"), p = this._apply("callExpr"), this._or(function() {
                        return function() {
                            return this._apply("spacesNoNl"), this._applyWithArgs("token", "++"), p2 = this._apply("pos"), ["postop", [p1, p2], "++", p]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("spacesNoNl"), this._applyWithArgs("token", "--"), p2 = this._apply("pos"), ["postop", [p1, p2], "--", p]
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), p
                        }.call(this)
                    })
                }.call(this)
            },
            args: function() {
                var as;
                return function() {
                    return this._applyWithArgs("token", "("), as = this._applyWithArgs("listOf", "exprPart", ","), this._applyWithArgs("token", ")"), as
                }.call(this)
            },
            callExpr: function() {
                var p1, p, as, p2, p3, m, p4, as, p2, i, as, p2, i, p2, p3, f, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), p = this._apply("callExpr"), this._or(function() {
                            return function() {
                                return as = this._apply("args"), p2 = this._apply("pos"), ["call", [p1, p2], p].concat(as)
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "."), p3 = this._apply("pos"), m = this._applyWithArgs("token", "name"), p4 = this._apply("pos"), as = this._apply("args"), p2 = this._apply("pos"), ["send", [p1, p2],
                                    ["string", [p3, p4], m], p
                                ].concat(as)
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "["), i = this._apply("expr"), this._applyWithArgs("token", "]"), as = this._apply("args"), p2 = this._apply("pos"), ["send", [p1, p2], i, p].concat(as)
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "["), i = this._apply("expr"), this._applyWithArgs("token", "]"), p2 = this._apply("pos"), ["getp", [p1, p2], i, p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "."), p3 = this._apply("pos"), f = this._applyWithArgs("token", "name"), p2 = this._apply("pos"), ["getp", [p1, p2],
                                    ["string", [p3, p2], f], p
                                ]
                            }.call(this)
                        })
                    }.call(this)
                }, function() {
                    return this._apply("primExpr")
                })
            },
            memberExpr: function() {
                var p1, p, i, p2, p3, f, p2;
                return this._or(function() {
                    return function() {
                        return p1 = this._apply("pos"), p = this._apply("memberExpr"), this._or(function() {
                            return function() {
                                return this._applyWithArgs("token", "["), i = this._apply("expr"), this._applyWithArgs("token", "]"), p2 = this._apply("pos"), ["getp", [p1, p2], i, p]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "."), p3 = this._apply("pos"), f = this._applyWithArgs("token", "name"), p2 = this._apply("pos"), ["getp", [p1, p2],
                                    ["string", [p3, p2], f], p
                                ]
                            }.call(this)
                        })
                    }.call(this)
                }, function() {
                    return this._apply("primExpr")
                })
            },
            primExpr: function() {
                var e, p1, p2, p3, e, as, p2, n, p2, n, p2, s, p2, es, p2, e, f, p2;
                return this._or(function() {
                    return function() {
                        return this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), e
                    }.call(this)
                }, function() {
                    return function() {
                        return this._apply("spaces"), p1 = this._apply("pos"), this._or(function() {
                            return function() {
                                return this._applyWithArgs("token", "this"), p2 = this._apply("pos"), ["this", [p1, p2]]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "new"), p3 = this._apply("pos"), e = this._apply("memberExpr"), as = this._or(function() {
                                    return this._apply("args")
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), []
                                    }.call(this)
                                }), p2 = this._apply("pos"), ["new", [p1, p2],
                                    ["call", [p3, p2], e].concat(as)
                                ]
                            }.call(this)
                        }, function() {
                            return function() {
                                return n = this._applyWithArgs("token", "name"), p2 = this._apply("pos"), ["get", [p1, p2], n]
                            }.call(this)
                        }, function() {
                            return function() {
                                return n = this._applyWithArgs("token", "number"), p2 = this._apply("pos"), ["number", [p1, p2], n]
                            }.call(this)
                        }, function() {
                            return function() {
                                return s = this._applyWithArgs("token", "string"), p2 = this._apply("pos"), ["string", [p1, p2], s]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "function"), this._or(function() {
                                    return this._applyWithArgs("token", "name")
                                }, function() {
                                    return this._apply("empty")
                                }), this._apply("funcRest")
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "["), es = this._applyWithArgs("listOf", "exprPart", ","), this._or(function() {
                                    return this._applyWithArgs("token", ",")
                                }, function() {
                                    return this._apply("empty")
                                }), this._applyWithArgs("token", "]"), p2 = this._apply("pos"), ["arr", [p1, p2]].concat(es)
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "/"), e = this._many(function() {
                                    return this._or(function() {
                                        return this._apply("escapeChar")
                                    }, function() {
                                        return function() {
                                            return this._not(function() {
                                                return this._applyWithArgs("exactly", "/")
                                            }), this._apply("char")
                                        }.call(this)
                                    })
                                }), this._applyWithArgs("token", "/"), f = this._many(function() {
                                    return this._apply("letter")
                                }), p2 = this._apply("pos"), ["regex", [p1, p2], e.join(""), f.join("")]
                            }.call(this)
                        })
                    }.call(this)
                }, function() {
                    return this._apply("json")
                })
            },
            json: function() {
                var p1, bs, p2;
                return function() {
                    return p1 = this._apply("pos"), this._applyWithArgs("token", "{"), bs = this._applyWithArgs("listOf", "jsonBinding", ","), this._or(function() {
                        return this._applyWithArgs("token", ",")
                    }, function() {
                        return this._apply("empty")
                    }), this._applyWithArgs("token", "}"), p2 = this._apply("pos"), ["json", [p1, p2]].concat(bs)
                }.call(this)
            },
            jsonBinding: function() {
                var p1, n, v, p2;
                return this._or(function() {
                    return this._apply("jsonGetter")
                }, function() {
                    return this._apply("jsonSetter")
                }, function() {
                    return function() {
                        return p1 = this._apply("pos"), n = this._apply("jsonPropName"), this._applyWithArgs("token", ":"), v = this._apply("exprPart"), p2 = this._apply("pos"), ["binding", [p1, p2], n, v]
                    }.call(this)
                })
            },
            jsonGetter: function() {
                var p1, n, body, p2;
                return function() {
                    return this._apply("spaces"), p1 = this._apply("pos"), this._applyWithArgs("exactly", "g"), this._applyWithArgs("exactly", "e"), this._applyWithArgs("exactly", "t"), n = this._apply("jsonPropName"), this._applyWithArgs("token", "("), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), body = this._apply("srcElems"), this._applyWithArgs("token", "}"), p2 = this._apply("pos"), ["jsonGetter", [p1, p2], n, body]
                }.call(this)
            },
            jsonSetter: function() {
                var p1, n, arg, body, p2;
                return function() {
                    return this._apply("spaces"), p1 = this._apply("pos"), this._applyWithArgs("exactly", "s"), this._applyWithArgs("exactly", "e"), this._applyWithArgs("exactly", "t"), n = this._apply("jsonPropName"), this._applyWithArgs("token", "("), arg = this._applyWithArgs("token", "name"), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), body = this._apply("srcElems"), this._applyWithArgs("token", "}"), p2 = this._apply("pos"), ["jsonSetter", [p1, p2], n, body, arg]
                }.call(this)
            },
            jsonPropName: function() {
                return this._or(function() {
                    return this._applyWithArgs("token", "name")
                }, function() {
                    return this._applyWithArgs("token", "number")
                }, function() {
                    return this._applyWithArgs("token", "string")
                })
            },
            memberFragment: function() {
                var jb;
                return function() {
                    return this._apply("spaces"), jb = this._apply("jsonBinding"), this._or(function() {
                        return function() {
                            switch (this._apply("anything")) {
                                case ",":
                                    return ",";
                                default:
                                    throw fail
                            }
                        }.call(this)
                    }, function() {
                        return this._apply("empty")
                    }), this._apply("spaces"), this._apply("end"), jb
                }.call(this)
            },
            categoryFragment: function() {
                var p1, es, p2;
                return function() {
                    return this._apply("spaces"), p1 = this._apply("pos"), es = this._applyWithArgs("listOf", "exprPart", ","), p2 = this._apply("pos"), this._or(function() {
                        return this._applyWithArgs("token", ",")
                    }, function() {
                        return this._apply("empty")
                    }), this._apply("spaces"), this._apply("end"), ["arr", [p1, p2]].concat(es)
                }.call(this)
            },
            traitFragment: function() {
                var p1, es, p2;
                return function() {
                    return this._apply("spaces"), p1 = this._apply("pos"), this._applyWithArgs("token", "name"), this._applyWithArgs("token", "("), this._apply("spaces"), es = this._applyWithArgs("listOf", "exprPart", ","), this._apply("spaces"), this._applyWithArgs("token", ")"), this._apply("spaces"), this._apply("sc"), p2 = this._apply("pos"), this._apply("spaces"), this._apply("end"), ["arr", [p1, p2]].concat(es)
                }.call(this)
            },
            formal: function() {
                var p1, n, p2;
                return function() {
                    return this._apply("spaces"), p1 = this._apply("pos"), n = this._applyWithArgs("token", "name"), p2 = this._apply("pos"), ["get", [p1, p2], n]
                }.call(this)
            },
            funcRest: function() {
                var p1, args, body, p2;
                return function() {
                    return p1 = this._apply("pos"), this._applyWithArgs("token", "("), args = this._applyWithArgs("listOf", "formal", ","), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), body = this._apply("srcElems"), this._applyWithArgs("token", "}"), p2 = this._apply("pos"), ["func", [p1, p2], body].concat(args)
                }.call(this)
            },
            sc: function() {
                return this._or(function() {
                    return function() {
                        return this._apply("spacesNoNl"), this._or(function() {
                            return function() {
                                switch (this._apply("anything")) {
                                    case "\n":
                                        return "\n";
                                    default:
                                        throw fail
                                }
                            }.call(this)
                        }, function() {
                            return this._lookahead(function() {
                                return this._applyWithArgs("exactly", "}")
                            })
                        }, function() {
                            return this._apply("end")
                        })
                    }.call(this)
                }, function() {
                    return this._applyWithArgs("token", ";")
                })
            },
            binding: function() {
                var p1, n, p, v, p2;
                return function() {
                    return p1 = this._apply("pos"), n = this._applyWithArgs("token", "name"), v = this._or(function() {
                        return function() {
                            return this._applyWithArgs("token", "="), this._apply("exprPart")
                        }.call(this)
                    }, function() {
                        return function() {
                            return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                        }.call(this)
                    }), p2 = this._apply("pos"), ["var", [p1, p2], n, v]
                }.call(this)
            },
            bindingList: function() {
                var p1, bs, p2;
                return function() {
                    return p1 = this._apply("pos"), bs = this._applyWithArgs("listOf", "binding", ","), p2 = this._apply("pos"), ["begin", [p1, p2]].concat(bs)
                }.call(this)
            },
            block: function() {
                var ss;
                return function() {
                    return this._applyWithArgs("token", "{"), ss = this._apply("srcElems"), this._applyWithArgs("token", "}"), ss
                }.call(this)
            },
            stmt: function() {
                var p1, bs, p2, c, t, p, f, p2, c, s, p2, s, c, p2, p, i, p, c, p, u, s, p2, p3, n, p4, n, p4, v, e, s, p2, e, p3, c, cs, p4, p3, cs, p4, cs, p2, p2, p2, p2, e, p2, t, e, p, e, c, p, f, p2, p, e, p2, x, s, p2, e, p2;
                return this._or(function() {
                    return this._apply("block")
                }, function() {
                    return function() {
                        return this._apply("spaces"), p1 = this._apply("pos"), this._or(function() {
                            return function() {
                                return this._applyWithArgs("token", "var"), bs = this._apply("bindingList"), this._apply("sc"), p2 = this._apply("pos"), bs
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "if"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), t = this._apply("stmt"), f = this._or(function() {
                                    return function() {
                                        return this._applyWithArgs("token", "else"), this._apply("stmt")
                                    }.call(this)
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), this._or(function() {
                                    return this._apply("sc")
                                }, function() {
                                    return this._apply("empty")
                                }), p2 = this._apply("pos"), ["if", [p1, p2], c, t, f]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), p2 = this._apply("pos"), ["while", [p1, p2], c, s]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "do"), s = this._apply("stmt"), this._applyWithArgs("token", "while"), this._applyWithArgs("token", "("), c = this._apply("expr"), this._applyWithArgs("token", ")"), this._apply("sc"), p2 = this._apply("pos"), ["doWhile", [p1, p2], s, c]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), i = this._or(function() {
                                    return function() {
                                        return this._applyWithArgs("token", "var"), this._apply("bindingList")
                                    }.call(this)
                                }, function() {
                                    return this._apply("expr")
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), this._applyWithArgs("token", ";"), c = this._or(function() {
                                    return this._apply("expr")
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "true"]
                                    }.call(this)
                                }), this._applyWithArgs("token", ";"), u = this._or(function() {
                                    return this._apply("expr")
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), this._applyWithArgs("token", ")"), s = this._apply("stmt"), p2 = this._apply("pos"), ["for", [p1, p2], i, c, s, u]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "for"), this._applyWithArgs("token", "("), v = this._or(function() {
                                    return function() {
                                        return p3 = this._apply("pos"), this._applyWithArgs("token", "var"), n = this._applyWithArgs("token", "name"), p4 = this._apply("pos"), ["var", [p3, p4], n, ["get", [p3, p3], "undefined"]]
                                    }.call(this)
                                }, function() {
                                    return function() {
                                        return n = this._applyWithArgs("token", "name"), p4 = this._apply("pos"), ["get", [p3, p4], n]
                                    }.call(this)
                                }), this._applyWithArgs("token", "in"), e = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), p2 = this._apply("pos"), ["forIn", [p1, p2], v, e, s]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "switch"), this._applyWithArgs("token", "("), e = this._apply("expr"), this._applyWithArgs("token", ")"), this._applyWithArgs("token", "{"), cs = this._many(function() {
                                    return this._or(function() {
                                        return function() {
                                            return p3 = this._apply("pos"), this._applyWithArgs("token", "case"), c = this._apply("expr"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), p4 = this._apply("pos"), ["case", [p3, p4], c, cs]
                                        }.call(this)
                                    }, function() {
                                        return function() {
                                            return p3 = this._apply("pos"), this._applyWithArgs("token", "default"), this._applyWithArgs("token", ":"), cs = this._apply("srcElems"), p4 = this._apply("pos"), ["default", [p3, p4], cs]
                                        }.call(this)
                                    })
                                }), this._applyWithArgs("token", "}"), p2 = this._apply("pos"), ["switch", [p1, p2], e].concat(cs)
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "break"), this._apply("sc"), p2 = this._apply("pos"), ["break", [p1, p2]]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "debugger"), this._apply("sc"), p2 = this._apply("pos"), ["debugger", [p1, p2]]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "continue"), this._apply("sc"), p2 = this._apply("pos"), ["continue", [p1, p2]]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "throw"), this._apply("spacesNoNl"), e = this._apply("expr"), this._apply("sc"), p2 = this._apply("pos"), ["throw", [p1, p2], e]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "try"), t = this._apply("block"), c = this._or(function() {
                                    return function() {
                                        return this._applyWithArgs("token", "catch"), this._applyWithArgs("token", "("), e = this._apply("formal"), this._applyWithArgs("token", ")"), this._apply("block")
                                    }.call(this)
                                }, function() {
                                    return e = function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), f = this._or(function() {
                                    return function() {
                                        return this._applyWithArgs("token", "finally"), this._apply("block")
                                    }.call(this)
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), p2 = this._apply("pos"), ["try", [p1, p2], t, e, c, f]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "return"), e = this._or(function() {
                                    return this._apply("expr")
                                }, function() {
                                    return function() {
                                        return this._apply("empty"), p = this._apply("pos"), ["get", [p, p], "undefined"]
                                    }.call(this)
                                }), this._apply("sc"), p2 = this._apply("pos"), ["return", [p1, p2], e]
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", "with"), this._applyWithArgs("token", "("), x = this._apply("expr"), this._applyWithArgs("token", ")"), s = this._apply("stmt"), p2 = this._apply("pos"), ["with", [p1, p2], x, s]
                            }.call(this)
                        }, function() {
                            return function() {
                                return e = this._apply("expr"), this._apply("sc"), e
                            }.call(this)
                        }, function() {
                            return function() {
                                return this._applyWithArgs("token", ";"), p2 = this._apply("pos"), ["get", [p1, p2], "undefined"]
                            }.call(this)
                        })
                    }.call(this)
                })
            },
            functionDef: function() {
                var p1, n, f, p2;
                return function() {
                    return p1 = this._apply("pos"), this._applyWithArgs("token", "function"), n = this._applyWithArgs("token", "name"), f = this._apply("funcRest"), p2 = this._apply("pos"), ["var", [p1, p2], n, f]
                }.call(this)
            },
            functionDefFragment: function() {
                var f;
                return function() {
                    return f = this._apply("functionDef"), this._apply("spaces"), this._apply("end"), f
                }.call(this)
            },
            functionDefsFragment: function() {
                var p1, fs, p2;
                return function() {
                    return p1 = this._apply("pos"), fs = this._many(function() {
                        return this._apply("functionDef")
                    }), p2 = this._apply("pos"), this._apply("spaces"), this._apply("end"), ["arr", [p1, p2]].concat(fs)
                }.call(this)
            },
            srcElem: function() {
                return this._or(function() {
                    return this._apply("functionDef")
                }, function() {
                    return this._apply("stmt")
                })
            },
            srcElems: function() {
                var p1, ss, p2;
                return function() {
                    return p1 = this._apply("pos"), ss = this._many(function() {
                        return this._apply("srcElem")
                    }), p2 = this._apply("pos"), ["begin", [p1, p2]].concat(ss)
                }.call(this)
            },
            topLevel: function() {
                var r;
                return function() {
                    return r = this._apply("srcElems"), this._apply("spaces"), this._apply("end"), r
                }.call(this)
            }
        })
    }), module("users.timfelgentreff.jsinterpreter.Parser").requires("lively.Ometa", "users.timfelgentreff.jsinterpreter.generated.Translator", "users.timfelgentreff.jsinterpreter.generated.Nodes", "users.timfelgentreff.jsinterpreter.LivelyJSParser").toRun(function() {
        Object.extend(LivelyJSParser, {
            hexDigits: "0123456789abcdef",
            keywords: function() {
                for (var keywordWithIdx = {}, keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in", "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "ometa", "debugger"], idx = 0; idx < keywords.length; idx++) keywordWithIdx[keywords[idx]] = !0;
                return keywordWithIdx
            }(),
            _isKeyword: function(k) {
                return this.keywords[k] === !0
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter.Parser, {
            jsParser: LivelyJSParser,
            astTranslator: JSTranslator,
            basicParse: function(source, rule) {
                var errorHandler = function() {
                        throw Array.from(arguments)
                    },
                    intermediate = OMetaSupport.matchAllWithGrammar(this.jsParser, rule, source, errorHandler);
                if (!intermediate || Object.isString(intermediate)) throw [source, rule, "Could not parse JS source code", 0, intermediate];
                var ast = OMetaSupport.matchWithGrammar(this.astTranslator, "trans", intermediate);
                if (!ast || Object.isString(ast)) throw [source, rule, "Could not translate symbolic AST tree", 0, intermediate, ast];
                return ast.source = source, ast
            },
            parse: function(src, optRule) {
                return this.basicParse(src, optRule || "topLevel")
            }
        }), users.timfelgentreff.jsinterpreter.Node.addMethods("accessing", {
            setParent: function(parentNode) {
                return this._parent = parentNode
            },
            getParent: function() {
                return this._parent
            },
            hasParent: function() {
                return void 0 != this._parent
            },
            parentSequence: function() {
                return this.hasParent() && this.getParent().parentSequence()
            },
            parentFunction: function() {
                return this.hasParent() && this.getParent().parentFunction()
            },
            astIndex: function() {
                var parentFunc = this.parentFunction();
                if (!parentFunc) throw new Error("astIndex: cannot get parent fucntion of " + this);
                return parentFunc.linearlyListNodesWithoutNestedFunctions().indexOf(this)
            },
            nodeForAstIndex: function(idx) {
                return this.linearlyListNodesWithoutNestedFunctions()[idx]
            }
        }, "testing", {
            isASTNode: !0,
            isUndefined: function(expr) {
                return expr.isVariable && "undefined" === expr.name
            }
        }, "enumerating", {
            withAllChildNodesDo: function(func, parent, nameInParent, depth) {
                var node = this,
                    shouldContinue = func(node, parent, nameInParent, depth || 0);
                shouldContinue && this.doForAllChildNodes(function(childNode, nameInParent) {
                    childNode.withAllChildNodesDo(func, node, nameInParent, depth ? depth + 1 : 1)
                })
            },
            withAllChildNodesDoPostOrder: function(func, stopFunc, parent, nameInParent, depth) {
                var node = this,
                    shouldStop = stopFunc && stopFunc(node, parent, nameInParent, depth || 0);
                shouldStop || (this.doForAllChildNodes(function(childNode, nameInParent) {
                    childNode.withAllChildNodesDoPostOrder(func, stopFunc, node, nameInParent, depth ? depth + 1 : 1)
                }), func(node, parent, nameInParent, depth || 0))
            },
            doForAllChildNodes: function(func) {
                for (var name in this)
                    if (this.hasOwnProperty(name) && "_parent" != name) {
                        var value = this[name];
                        value.isASTNode ? func(value, name, null) : Object.isArray(value) && value.forEach(function(item, i) {
                            item.isASTNode && func(item, name, i)
                        })
                    }
            },
            nodesMatching: function(matchFunc) {
                var result = [];
                return this.withAllChildNodesDo(function(node, parent, nameInParent, depth) {
                    return matchFunc(node, parent, nameInParent, depth) && result.push(node), !0
                }), result
            },
            linearlyListNodes: function() {
                var nodes = [];
                return this.withAllChildNodesDoPostOrder(function(node) {
                    nodes.push(node)
                }), nodes
            },
            linearlyListNodesWithoutNestedFunctions: function() {
                var root = this,
                    nodes = [];
                return this.withAllChildNodesDoPostOrder(function(node) {
                    nodes.push(node)
                }, function(node) {
                    return node.isFunction && node !== root
                }), nodes
            },
            isAfter: function(other) {
                var that = this,
                    first = null;
                return this.parentFunction().body.withAllChildNodesDo(function(node) {
                    return first || (node === that && (first = that), node === other && (first = other)), !first
                }), first === other
            }
        }, "replacing", {
            replaceNodesMatching: function(testFunc, replacementNodeOrFunction) {
                var nodes = this.nodesMatching(testFunc);
                return nodes.forEach(function(node) {
                    var parent = node.getParent();
                    if (!parent) throw new Error("No parent for node in replaceNodesMatching " + node);
                    var replacementNode = "function" == typeof replacementNodeOrFunction ? replacementNodeOrFunction(node) : replacementNodeOrFunction;
                    parent.replaceChildNode(node, replacementNode)
                }), this
            },
            replaceWith: function(otherNode) {
                if (!this.hasParent()) throw new Error("Need parent node for replaceWith but cannot find it " + this);
                return this.getParent().replaceChildNode(this, otherNode), otherNode
            },
            replaceChildNode: function(childNode, newNode) {
                var slotName, idx;
                if (this.doForAllChildNodes(function(node, nameInParent, i) {
                        node === childNode && (slotName = nameInParent, idx = i)
                    }), void 0 === slotName) throw new Error("Cannot find childNode in me! (#replaceChildNode)");
                void 0 === idx || null === idx ? this[slotName] = newNode : this[slotName][idx] = newNode, newNode.setParent(this)
            }
        }, "evaluation", {
            eval: function() {
                var result, js;
                try {
                    js = this.asJS();
                    var src = "(" + js + ")";
                    result = eval(src)
                } catch (e) {
                    alert("Could not eval " + js + " because:\n" + e + "\n" + e.stack)
                }
                return result
            }
        }, "debugging", {
            error: function(msg) {
                throw new Error(msg)
            },
            indent: function(depth) {
                return Strings.indent("", " ", depth)
            },
            toString: function() {
                return this.constructor.name
            },
            printTree: function(postOrder) {
                var nodeStrings = [],
                    idx = 0,
                    enumFunc = postOrder ? "withAllChildNodesDoPostOrder" : "withAllChildNodesDo";
                return this[enumFunc](function(node, parent, nameInParent, depth) {
                    return nodeStrings.push(idx.toString() + " " + Strings.indent(node.constructor.name + "(" + nameInParent + ")", " ", depth)), idx++, !0
                }), nodeStrings.join("\n")
            },
            printConstructorCall: function() {
                for (var call = "new " + this.constructor.type + "(", argCalls = [], i = 0; i < arguments.length; i++) {
                    var arg = arguments[i],
                        argCall = "";
                    Object.isArray(arg) ? (argCall += "[", argCall += arg.collect(function(ea) {
                        return ea.isASTNode ? ea.printConstruction() : ea
                    }).join(","), argCall += "]") : argCall += arg.isASTNode ? arg.printConstruction() : arg, argCalls.push(argCall)
                }
                return call += argCalls.join(","), call += ")"
            }
        }, "stepping", {
            firstStatement: function() {
                return this
            },
            nextStatement: function() {
                var stmt = this.getParent().nextStatement(this);
                return stmt ? stmt.firstStatement() : null
            },
            isComposite: function() {
                return !1
            }
        }, "matching", {
            match: function(patternAst) {
                var matchedPlaceholder = !0;
                for (var key in patternAst) {
                    var result = this.matchVal(key, this[key], patternAst[key]);
                    result !== !0 && (matchedPlaceholder = result)
                }
                return matchedPlaceholder
            },
            matchVal: function(key, value, pattern) {
                if (pattern === users.timfelgentreff.jsinterpreter.Node.placeholder) return value;
                if (value == pattern) return !0;
                if (Object.isString(pattern)) {
                    if (value.toString() == pattern) return !0;
                    if (value.value == pattern) return !0;
                    if (value.name == pattern) return !0
                }
                if (Object.isArray(pattern) && Object.isArray(value)) {
                    for (var matchedPlaceholder = !0, i = 0; i < pattern.length; i++) {
                        for (var success = !1, lastError = null, j = 0; j < value.length; j++) try {
                            var res = this.matchVal(key, value[j], pattern[i]);
                            res !== !0 && (matchedPlaceholder = res), success = !0
                        } catch (e) {
                            lastError = e
                        }
                        if (!success) throw lastError
                    }
                    if (value.length !== pattern.length) throw {
                        key: key,
                        err: "count",
                        expected: pattern.length,
                        actual: value.length
                    };
                    return matchedPlaceholder
                }
                if (Object.isObject(pattern) && value.isASTNode) return value.match(pattern);
                throw {
                    key: key,
                    err: "missmatch",
                    expected: String(pattern),
                    actual: String(value)
                }
            }
        }), Object.subclass("users.timfelgentreff.jsinterpreter.SourceGenerator", "documentation", {
            usage: "gen = new users.timfelgentreff.jsinterpreter.SourceGenerator();\ngen.writeAndEvalTranslator();\ngen.evalAndWriteClasses();\nusers.timfelgentreff.jsinterpreter.Parser.astTranslator = JSTranslator;\nusers.timfelgentreff.jsinterpreter.Parser.jsParser = LivelyJSParser;",
            showUsage: function() {
                $world.addTextWindow({
                    content: this.usage,
                    title: "users.timfelgentreff.jsinterpreter.SourceGenerator usage"
                })
            }
        }, "settings", {
            customRules: function() {
                return ["trans = [:t apply(t):ans] -> ans,"]
            },
            customClasses: function() {
                return ["Object.subclass('" + this.rootNodeClassName + "')"]
            },
            translatorRules: function() {
                var names = this.constructor.categories["translator rules"],
                    result = {};
                return names.forEach(function(name) {
                    result[name] = this[name]
                }, this), result
            },
            modulePath: "users.timfelgentreff.jsinterpreter.",
            rootNodeClassName: "users.timfelgentreff.jsinterpreter.Node",
            visitorClassName: "users.timfelgentreff.jsinterpreter.Visitor"
        }, "translator rules", {
            begin: {
                className: "Sequence",
                rules: [":pos", "trans*:children", "end"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.children)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.children.join(","))
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        var indent = this.indent(depth || 0);
                        return depth = depth || -1, this.children.invoke("asJS", depth + 1).join(";\n" + indent)
                    }
                },
                insertion: {
                    insertBefore: function(newNode, existingNode) {
                        for (var i = 0; i < this.children.length && !(this.children[i].nodesMatching(function(node) {
                                return node === existingNode
                            }).length > 0); i++);
                        if (!this.children[i]) throw dbgOn(new Error("insertBefore: " + existingNode + " not in " + this));
                        return this.insertAt(newNode, i)
                    },
                    insertAt: function(newNode, idx) {
                        return this.children.pushAt(newNode, idx), newNode.setParent(this), newNode
                    }
                },
                accessing: {
                    parentSequence: function() {
                        return this
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.children.length > 0 ? this.children[0].firstStatement() : this
                    },
                    nextStatement: function($super, node) {
                        var idx = this.children.indexOf(node);
                        return idx >= 0 && idx < this.children.length - 1 ? this.children[idx + 1] : $super(this)
                    },
                    isComposite: function() {
                        return !0
                    }
                }
            },
            number: {
                className: "Number",
                rules: [":pos", ":value"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.pos, this.value)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.value)
                    }
                },
                conversion: {
                    asJS: function() {
                        return this.value
                    }
                }
            },
            string: {
                className: "String",
                rules: [":pos", ":value"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.value + '"')
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.value)
                    }
                },
                conversion: {
                    asJS: function() {
                        return '"' + this.value + '"'
                    }
                }
            },
            condExpr: {
                className: "Cond",
                rules: [":pos", "trans:condExpr", "trans:trueExpr", "trans:falseExpr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s?%s:%s)", this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("(%s) ? (%s) : (%s)", this.condExpr.asJS(depth), this.trueExpr.asJS(depth), this.falseExpr.asJS(depth))
                    }
                }
            },
            "if": {
                className: "If",
                rules: [":pos", "trans:condExpr", "trans:trueExpr", "trans:falseExpr"],
                initializing: {
                    initialize: function($super, pos, condExpr, trueExpr, falseExpr) {
                        this.pos = pos, this.condExpr = condExpr, this.trueExpr = trueExpr.isSequence || this.isUndefined(trueExpr) ? trueExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [trueExpr]), this.falseExpr = falseExpr.isSequence || this.isUndefined(falseExpr) ? falseExpr : new users.timfelgentreff.jsinterpreter.Sequence(trueExpr.pos, [falseExpr]), condExpr.setParent(this), this.trueExpr.setParent(this), this.falseExpr.setParent(this)
                    }
                },
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.condExpr, this.trueExpr, this.falseExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s?%s:%s)", this.constructor.name, this.condExpr, this.trueExpr, this.falseExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        var str = Strings.format("if (%s) {%s}", this.condExpr.asJS(depth), this.trueExpr.asJS(depth));
                        return this.isUndefined(this.falseExpr) || (str += " else {" + this.falseExpr.asJS(depth) + "}"), str
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.condExpr.firstStatement()
                    },
                    nextStatement: function($super, node) {
                        return node === this.condExpr ? this.trueExpr : $super(this)
                    },
                    isComposite: function() {
                        return !0
                    }
                }
            },
            "while": {
                className: "While",
                rules: [":pos", "trans:condExpr", "trans:body"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.condExpr, this.body)
                    },
                    toString: function() {
                        return Strings.format("%s(%s?%s)", this.constructor.name, this.condExpr, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("while (%s) {%s}", this.condExpr.asJS(depth), this.body.asJS(depth))
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.condExpr.firstStatement()
                    },
                    nextStatement: function($super, node) {
                        return node === this.condExpr ? this.body : node === this.body ? this.condExpr : $super(this)
                    },
                    isComposite: function() {
                        return !0
                    }
                }
            },
            doWhile: {
                className: "DoWhile",
                rules: [":pos", "trans:body", "trans:condExpr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.body, this.condExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s while%s)", this.constructor.name, this.body, this.condExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("do {%s} while (%s);", this.body.asJS(depth), this.condExpr.asJS(depth))
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.body.firstStatement()
                    },
                    nextStatement: function($super, node) {
                        return node === this.condExpr ? this.body : node === this.body ? this.condExpr : $super(this)
                    },
                    isComposite: function() {
                        return !0
                    }
                }
            },
            "for": {
                className: "For",
                rules: [":pos", "trans:init", "trans:condExpr", "trans:body", "trans:upd"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.init, this.condExpr, this.body, this.upd)
                    },
                    toString: function() {
                        return Strings.format("%s(%s;%s;%s do %s)", this.constructor.name, this.init, this.condExpr, this.upd, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("for (%s; %s; %s) {%s}", this.init.asJS(depth), this.condExpr.asJS(depth), this.upd.asJS(depth), this.body.asJS(depth))
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.init.firstStatement()
                    },
                    nextStatement: function($super, node) {
                        return node === this.init || node === this.upd ? this.condExpr : node === this.condExpr ? this.body : node === this.body ? this.upd : $super(this)
                    },
                    isComposite: function() {
                        return !0
                    }
                }
            },
            forIn: {
                className: "ForIn",
                rules: [":pos", "trans:name", "trans:obj", "trans:body"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.name, this.obj, this.body)
                    },
                    toString: function() {
                        return Strings.format("%s(%s in %s do %s)", this.constructor.name, this.name, this.obj, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("for (%s in %s) {%s}", this.name.asJS(depth), this.obj.asJS(depth), this.body.asJS(depth))
                    }
                }
            },
            set: {
                className: "Set",
                rules: [":pos", "trans:left", "trans:right"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.left, this.right)
                    },
                    toString: function() {
                        return Strings.format("%s(%s = %s)", this.constructor.name, this.left, this.right)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return this.left.asJS(depth) + " = " + this.right.asJS(depth)
                    }
                }
            },
            mset: {
                className: "ModifyingSet",
                rules: [":pos", "trans:left", ":name", "trans:right"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.left, '"' + this.name + '"', this.right)
                    },
                    toString: function() {
                        return Strings.format("%s(%s %s %s)", this.constructor.name, this.left, this.name, this.right)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return this.left.asJS(depth) + " " + this.name + "= " + this.right.asJS(depth)
                    }
                }
            },
            binop: {
                className: "BinaryOp",
                rules: [":pos", ":name", "trans:left", "trans:right"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.left, this.right)
                    },
                    toString: function() {
                        return Strings.format("%s(%s %s %s)", this.constructor.name, this.left, this.name, this.right)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "(" + this.left.asJS(depth) + ") " + this.name + " (" + this.right.asJS(depth) + ")"
                    }
                }
            },
            unop: {
                className: "UnaryOp",
                rules: [":pos", ":name", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s%s)", this.constructor.name, this.name, this.expr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "(" + this.name + this.expr.asJS(depth) + ")"
                    }
                }
            },
            preop: {
                className: "PreOp",
                rules: [":pos", ":name", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s%s)", this.constructor.name, this.name, this.expr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "(" + this.name + this.expr.asJS(depth) + ")"
                    }
                }
            },
            postop: {
                className: "PostOp",
                rules: [":pos", ":name", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s%s)", this.constructor.name, this.expr, this.name)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "(" + this.expr.asJS(depth) + this.name + ")"
                    }
                }
            },
            "this": {
                className: "This",
                rules: [":pos"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos)
                    },
                    toString: function() {
                        return this.constructor.name
                    }
                },
                conversion: {
                    asJS: function() {
                        return "this"
                    }
                }
            },
            get: {
                className: "Variable",
                rules: [":pos", ":name"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"')
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.name)
                    }
                },
                conversion: {
                    asJS: function() {
                        return this.name
                    }
                }
            },
            getp: {
                className: "GetSlot",
                rules: [":pos", "trans:slotName", "trans:obj"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.slotName, this.obj)
                    },
                    toString: function() {
                        return Strings.format("%s(%s[%s])", this.constructor.name, this.obj, this.slotName)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        var objJS = this.obj.asJS(depth);
                        return this.obj.isFunction && (objJS = "(" + objJS + ")"), objJS + "[" + this.slotName.asJS(depth) + "]"
                    }
                }
            },
            "break": {
                className: "Break",
                rules: [":pos", "trans:label"],
                initializing: {
                    initialize: function($super, pos, label) {
                        this.pos = pos, this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], ""), this.label.setParent(this)
                    }
                },
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.label)
                    }
                },
                conversion: {
                    asJS: function() {
                        return "break" + this.label.asJS()
                    }
                }
            },
            "debugger": {
                className: "Debugger",
                rules: [":pos"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos)
                    }
                },
                conversion: {
                    asJS: function() {
                        return "debugger"
                    }
                }
            },
            "continue": {
                className: "Continue",
                rules: [":pos", "trans:label"],
                initializing: {
                    initialize: function($super, pos, label) {
                        this.pos = pos, this.label = label || new users.timfelgentreff.jsinterpreter.Label([pos[1], pos[1]], ""), this.label.setParent(this)
                    }
                },
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.label)
                    }
                },
                conversion: {
                    asJS: function() {
                        return "continue" + this.label.asJS()
                    }
                }
            },
            arr: {
                className: "ArrayLiteral",
                rules: [":pos", "trans*:elements"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.elements)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.elements.join(","))
                    }
                },
                conversion: {
                    asJS: function() {
                        return "[" + this.elements.invoke("asJS").join(",") + "]"
                    }
                }
            },
            "return": {
                className: "Return",
                rules: [":pos", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.expr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "return " + this.expr.asJS(depth)
                    }
                }
            },
            "with": {
                className: "With",
                rules: [":pos", "trans:obj", "trans:body"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.obj, this.body)
                    },
                    toString: function() {
                        return Strings.format("%s(%s %s)", this.constructor.name, this.obj, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "with (" + this.obj.asJS(depth) + ") {" + this.body.asJS(depth) + "}"
                    }
                }
            },
            send: {
                className: "Send",
                rules: [":pos", "trans:property", "trans:recv", "trans*:args"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.property, this.recv, this.args)
                    },
                    toString: function() {
                        return Strings.format("%s(%s[%s](%s))", this.constructor.name, this.recv, this.property, this.args.join(","))
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        var recvJS = this.recv.asJS(depth);
                        return this.recv.isFunction && (recvJS = "(" + recvJS + ")"), Strings.format("%s[%s](%s)", recvJS, this.property.asJS(depth), this.args.invoke("asJS").join(","))
                    }
                },
                accessing: {
                    getName: function() {
                        return this.property
                    }
                }
            },
            call: {
                className: "Call",
                rules: [":pos", "trans:fn", "trans*:args"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.fn, this.args)
                    },
                    toString: function() {
                        return Strings.format("%s(%s(%s))", this.constructor.name, this.fn, this.args.join(","))
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("%s(%s)", this.fn.asJS(depth), this.args.invoke("asJS").join(","))
                    }
                },
                accessing: {
                    getName: function() {
                        return this.fn.name
                    }
                }
            },
            "new": {
                className: "New",
                rules: [":pos", "trans:clsExpr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.clsExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.clsExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "new " + this.clsExpr.asJS(depth)
                    }
                }
            },
            "var": {
                className: "VarDeclaration",
                rules: [":pos", ":name", "trans:val"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.val)
                    },
                    toString: function() {
                        return Strings.format("%s(%s = %s)", this.constructor.name, this.name, this.val)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("var %s = %s", this.name, this.val.asJS(depth))
                    }
                }
            },
            "throw": {
                className: "Throw",
                rules: [":pos", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.expr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "throw " + this.expr.asJS(depth)
                    }
                }
            },
            "try": {
                className: "TryCatchFinally",
                rules: [":pos", "trans:trySeq", "trans:err", "trans:catchSeq", "trans:finallySeq"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.trySeq, '"' + this.err.name + '"', this.catchSeq, this.finallySeq)
                    },
                    toString: function() {
                        return Strings.format("%s(%s %s %s)", this.constructor.name, this.trySeq, this.catchSeq, this.finallySeq)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        var baseIndent = this.indent(depth - 1),
                            indent = this.indent(depth),
                            str = "try {\n" + indent + this.trySeq.asJS(depth) + "\n" + baseIndent + "}";
                        return this.isUndefined(this.catchSeq) || (str += " catch(" + this.err.name + ") {\n" + indent + this.catchSeq.asJS(depth) + "\n" + baseIndent + "}"), this.isUndefined(this.finallySeq) || (str += " finally {\n" + indent + this.finallySeq.asJS(depth) + "\n" + baseIndent + "}"), str
                    }
                }
            },
            func: {
                className: "Function",
                rules: [":pos", "trans:body", "trans*:args"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.body, this.args.collect(function(ea) {
                            return '"' + ea.name + '"'
                        }))
                    },
                    toString: function() {
                        return Strings.format("%s(function %s(%s) %s)", this.constructor.name, this.name(), this.argNames().join(","), this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("function%s(%s) {\n%s\n}", this.name() ? " " + this.name() : "", this.argNames().join(","), this.indent(depth + 1) + this.body.asJS(depth + 1))
                    }
                },
                accessing: {
                    name: function() {
                        return this._parent && this._parent.isVarDeclaration ? this._parent.name : void 0
                    },
                    parentFunction: function() {
                        return this
                    },
                    argNames: function() {
                        return this.args.collect(function(a) {
                            return a.name
                        })
                    },
                    statements: function() {
                        return this.body.children
                    }
                },
                stepping: {
                    firstStatement: function() {
                        return this.body.firstStatement()
                    },
                    nextStatement: function() {
                        return null
                    },
                    isComposite: function() {
                        return !0
                    }
                },
                evaluation: {
                    eval: function() {
                        return new Function(this.argNames().join(","), this.body.asJS())
                    }
                }
            },
            json: {
                className: "ObjectLiteral",
                rules: [":pos", "trans*:properties"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.properties)
                    },
                    toString: function() {
                        return Strings.format("%s({%s})", this.constructor.name, this.properties.join(","))
                    }
                },
                conversion: {
                    asJS: function() {
                        return "{" + this.properties.invoke("asJS").join(",") + "}"
                    }
                }
            },
            binding: {
                className: "ObjProperty",
                rules: [":pos", ":name", "trans:property"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.property)
                    },
                    toString: function() {
                        return Strings.format("%s(%s: %s)", this.constructor.name, this.name, this.property)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('"%s": %s', this.name, this.property.asJS(depth))
                    }
                }
            },
            jsonGetter: {
                className: "ObjPropertyGet",
                rules: [":pos", ":name", "trans:body"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.body)
                    },
                    toString: function() {
                        return Strings.format("%s(%s() { %s })", this.constructor.name, this.name, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('get "%s"() { %s }', this.name, this.body.asJS(depth))
                    }
                }
            },
            jsonSetter: {
                className: "ObjPropertySet",
                rules: [":pos", ":name", "trans:body", ":arg"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.body, this.arg)
                    },
                    toString: function() {
                        return Strings.format("%s(%s(%s) { %s })", this.constructor.name, this.name, this.arg, this.body)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format('set "%s"(%s) { %s }', this.name, this.arg, this.body.asJS(depth))
                    }
                }
            },
            "switch": {
                className: "Switch",
                rules: [":pos", "trans:expr", "trans*:cases"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.expr, this.cases)
                    },
                    toString: function() {
                        return Strings.format("%s(%s %s)", this.constructor.name, this.expr, this.cases.join("\n"))
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return Strings.format("switch (%s) {%s}", this.expr.asJS(depth), this.cases.invoke("asJS").join("\n"))
                    }
                }
            },
            "case": {
                className: "Case",
                rules: [":pos", "trans:condExpr", "trans:thenExpr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.condExpr, this.thenExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s: %s)", this.constructor.name, this.condExpr, this.thenExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "case " + this.condExpr.asJS(depth) + ": " + this.thenExpr.asJS(depth)
                    }
                }
            },
            "default": {
                className: "Default",
                rules: [":pos", "trans:defaultExpr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.defaultExpr)
                    },
                    toString: function() {
                        return Strings.format("%s(default: %s)", this.constructor.name, this.defaultExpr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return "default: " + this.defaultExpr.asJS(depth)
                    }
                }
            },
            regex: {
                className: "Regex",
                rules: [":pos", ":exprString", ":flags"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, this.exprString, this.flags)
                    },
                    toString: function() {
                        return Strings.format("(/%s/%s)", this.exprString, this.flags)
                    }
                },
                conversion: {
                    asJS: function() {
                        return "/" + this.exprString + "/" + this.flags
                    }
                }
            },
            label: {
                className: "Label",
                rules: [":pos", ":name"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"')
                    },
                    toString: function() {
                        return Strings.format("%s(%s)", this.constructor.name, this.name)
                    }
                },
                conversion: {
                    asJS: function() {
                        return this.name
                    }
                }
            },
            labelDcl: {
                className: "LabelDeclaration",
                rules: [":pos", ":name", "trans:expr"],
                debugging: {
                    printConstruction: function() {
                        return this.printConstructorCall(this.pos, '"' + this.name + '"', this.expr)
                    },
                    toString: function() {
                        return Strings.format("%s(%s is %s)", this.constructor.name, this.name, this.expr)
                    }
                },
                conversion: {
                    asJS: function(depth) {
                        return this.name + ": " + this.expr.asJS(depth)
                    }
                }
            }
        }, "rule helper", {
            rulesReturningSomething: function(ruleSpec) {
                return ruleSpec.rules ? ruleSpec.rules.reject(function(ea) {
                    return ea.startsWith(":") || !ea.include(":")
                }) : []
            },
            forCollectionRulesDo: function(ruleSpec, func) {
                var rules = this.rulesReturningSomething(ruleSpec),
                    collectionRules = rules.select(function(ea) {
                        return ea.include("*:")
                    });
                return collectionRules.forEach(function(rule) {
                    var ruleParts = rule.split("*:");
                    func.apply(this, ruleParts)
                }, this), collectionRules
            },
            forSimpleRulesDo: function(ruleSpec, func) {
                var rules = this.rulesReturningSomething(ruleSpec),
                    collectionRules = rules.select(function(ea) {
                        return ea.include("*:")
                    }),
                    simpleRules = rules.without.apply(rules, collectionRules);
                return simpleRules.forEach(function(rule) {
                    var ruleParts = rule.split(":");
                    func.apply(this, ruleParts)
                }, this), simpleRules
            }
        }, "file handling", {
            writeToFile: function(fileName, content) {
                var baseURL = URL.codeBase.withFilename(this.modulePath.replace(/\./g, "/")),
                    url = baseURL.withFilename("generated/" + fileName);
                new WebResource(url).put(content)
            }
        }, "rule creation", {
            createRule: function(name, spec) {
                var ownRules = spec.rules || [],
                    argNames = this.argsFromRules(ownRules),
                    className = this.modulePath + spec.className,
                    ruleAppString = ownRules.length > 0 ? " " + ownRules.join(" ") + "\n" : "",
                    ruleStart = name + " =\n",
                    ruleReturn = Strings.format(" -> { new %s(%s) },", className, argNames.join(", "));
                return ruleStart + ruleAppString + ruleReturn
            },
            argsFromRules: function(rules) {
                return rules ? rules.select(function(ea) {
                    return ea.include(":")
                }).collect(function(ea) {
                    return ea.split(":").last()
                }) : []
            },
            createJSTranslatorSource: function() {
                var rules = this.customRules();
                Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    rules.push(this.createRule(name, ruleSpec))
                }, this);
                var head = "ometa JSTranslator <: Parser {\n",
                    body = rules.join("\n"),
                    end = "\n}";
                return body = body.substring(0, body.length - 1), head + body + end
            },
            writeAndEvalTranslator: function() {
                var source = this.createJSTranslatorSource(),
                    translated = OMetaSupport.translateToJs(source);
                eval(translated);
                var content = Strings.format("module('users.timfelgentreff.jsinterpreter.generated.Translator').requires('ometa.lively').toRun(function() {\n%s\n});", translated);
                this.writeToFile("Translator.ometa", source), this.writeToFile("Translator.js", content)
            }
        }, "class creation", {
            assignmentsFromArgs: function(argNames) {
                return argNames.collect(function(ea) {
                    return Strings.format("   this.%s = %s;", ea, ea)
                }).join("\n")
            },
            parentCallsFromRules: function(ruleSpec) {
                var parentCalls = [];
                return this.forCollectionRulesDo(ruleSpec, function(rule, ruleVarName) {
                    var str = Strings.format("    %s.forEach(function(node) { node.setParent(this) }, this);", ruleVarName);
                    parentCalls.push(str)
                }), this.forSimpleRulesDo(ruleSpec, function(rule, ruleVarName) {
                    var str = Strings.format("    %s.setParent(this);", ruleVarName);
                    parentCalls.push(str)
                }), parentCalls.join("\n")
            },
            createASTClass: function(ruleSpec) {
                var className = this.modulePath + ruleSpec.className,
                    superclassName = this.rootNodeClassName,
                    args = this.argsFromRules(ruleSpec.rules),
                    setParentCalls = this.parentCallsFromRules(ruleSpec),
                    assignments = this.assignmentsFromArgs(args),
                    categories = [];
                categories.push(Strings.format("\n'testing', {\n  %s: true,\n}", this.genTypeProperty(ruleSpec.className))), args.length > 0 && !Properties.own(ruleSpec).include("initializing") && categories.push(Strings.format("\n'initializing', {\n  initialize: function($super, %s) {\n%s\n%s\n  },\n}", args.join(", "), assignments, setParentCalls)), Properties.own(ruleSpec).without("className", "rules").forEach(function(catName) {
                    var src = "\n'" + catName + "', {\n",
                        category = ruleSpec[catName],
                        functionNames = Functions.own(category);
                    functionNames.forEach(function(name) {
                        src += Strings.format(" %s: %s,\n", name, category[name])
                    }), src += "}", categories.push(src)
                }), categories.push(this.visitingCategoryForNode(ruleSpec));
                var body = categories.join(","),
                    def = Strings.format("%s.subclass('%s',%s)", superclassName, className, body);
                return def
            },
            genTypeProperty: function(className) {
                return "is" + className
            },
            createASTClassSourcesFromRules: function() {
                var classDefs = this.customClasses();
                return Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    classDefs.push(this.createASTClass(ruleSpec))
                }, this), classDefs.join(";\n\n")
            },
            evalAndWriteClasses: function() {
                var src = this.createASTClassSourcesFromRules();
                src += ";\n\n", src += this.abstractVisitorClassSource(), eval(src);
                var baseName = "Nodes",
                    moduleName = this.modulePath + "generated." + baseName,
                    fileName = baseName + ".js",
                    content = Strings.format("module('%s').requires().toRun(function() {\n%s\n});", moduleName, src);
                this.writeToFile(fileName, content)
            }
        }, "visitor creation", {
            abstractVisitorClassSource: function() {
                var categories = [this.visitingCategoryForAbstractVisitor()];
                return Strings.format("Object.subclass('%s',%s)", this.visitorClassName, categories.join(",\n"))
            },
            visitingCategoryForAbstractVisitor: function() {
                var src = "\n'visiting', {\n";
                return src += " visit: function(node) { return node.accept(this) },\n", Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    src += Strings.format(" visit%s: function(node) {},\n", ruleSpec.className)
                }), src += "\n}"
            },
            doubleDispatchCategoryForVisitor: function() {
                var createVisitAndAcceptCalls = function(ruleSpec) {
                        var calls = [];
                        return calls.push("   his.visit(node);"), this.forCollectionRulesDo(ruleSpec, function(rule, ruleVarName) {
                            var str = Strings.format("    node.%s.forEach(function(ea) { this.visit(ea) }, this);", ruleVarName);
                            calls.push(str)
                        }), this.forSimpleRulesDo(ruleSpec, function(rule, ruleVarName) {
                            var str = Strings.format("    this.visit(node.%s);", ruleVarName);
                            calls.push(str)
                        }), calls.join("\n")
                    }.bind(this),
                    src = "\n'double dispatch', {\n";
                return Properties.forEachOwn(this.translatorRules(), function(name, ruleSpec) {
                    src += Strings.format(" accept%s: function(node) {\n%s\n  },\n", ruleSpec.className, createVisitAndAcceptCalls(ruleSpec))
                }), src += "\n}"
            },
            visitingCategoryForNode: function(ruleSpec) {
                return "\n'visiting', {\n    accept: function(visitor) {\n        return visitor.visit" + ruleSpec.className + "(this);\n    }\n }"
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter.Node, {
            placeholder: {}
        })
    }), module("users.timfelgentreff.jsinterpreter.Meta").requires("users.timfelgentreff.jsinterpreter.Parser").toRun(function() {
        Function.addMethods("meta programming interface", {
            toSource: function() {
                if (!this.source) {
                    var name = this.methodName || this.name || "anonymous";
                    this.source = this.toString().replace(/^function[^\(]*/, "function " + name)
                }
                return this.source
            },
            browse: function() {
                throw this.sourceModule && this.methodName && this.declaredClass && require("lively.ide.SystemCodeBrowser").toRun(function() {
                    return lively.ide.browse(this.declaredClass, this.methodName, this.sourceModule.name())
                }.bind(this)), new Error("Cannot browse anonymous function " + this)
            },
            updateSource: function(source) {
                var ast = users.timfelgentreff.jsinterpreter.Parser.parse(source, "functionDef"),
                    newFun = ast.val.eval();
                newFun.declaredClass = this.declaredClass, newFun.methodName = this.methodName, newFun.sourceModule = this.sourceModule, newFun.source = source, newFun.locallyChanged = !0, this.getClass().prototype[this.methodName] = newFun, lively.bindings.signal(this, "localSource", newFun), users.timfelgentreff.jsinterpreter.Meta.ChangeSet.getCurrent().addChange(newFun)
            },
            getClass: function() {
                return lively.Class.forName(this.declaredClass)
            }
        }), Object.subclass("users.timfelgentreff.jsinterpreter.Meta.ChangeSet", "initializing", {
            initialize: function() {
                this.changes = []
            }
        }, "managing", {
            addChange: function(fun) {
                this.changes.push(fun), lively.bindings.signal(this.constructor, "current", this)
            }
        }, "persistence", {
            commit: function() {
                throw new Error("not implemented yet")
            }
        }, "merging", {
            mergeWithCurrent: function() {
                throw new Error("not implemented yet")
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter.Meta.ChangeSet, {
            current: null,
            getCurrent: function() {
                return this.current || (this.current = new this), this.current
            }
        })
    }), module("users.timfelgentreff.jsinterpreter.Rewriting").requires("users.timfelgentreff.jsinterpreter.Parser").toRun(function() {
        Object.extend(users.timfelgentreff.jsinterpreter, {
            oldEval: eval
        }), Object.extend(users.timfelgentreff.jsinterpreter.Rewriting, {
            table: []
        }), users.timfelgentreff.jsinterpreter.Visitor.subclass("users.timfelgentreff.jsinterpreter.Rewriting.Transformation", "helping", {
            visitNodes: function(nodes) {
                for (var result = [], i = 0; i < nodes.length; i++) {
                    var res = this.visit(nodes[i]);
                    res && result.push(res)
                }
                return result
            }
        }, "visiting", {
            visitSequence: function(node) {
                return new users.timfelgentreff.jsinterpreter.Sequence(node.pos, this.visitNodes(node.children))
            },
            visitNumber: function(node) {
                return new users.timfelgentreff.jsinterpreter.Number(node.pos, node.value)
            },
            visitString: function(node) {
                return new users.timfelgentreff.jsinterpreter.String(node.pos, node.value)
            },
            visitCond: function(node) {
                return new users.timfelgentreff.jsinterpreter.Cond(node.pos, this.visit(node.condExpr), this.visit(node.trueExpr), this.visit(node.falseExpr))
            },
            visitIf: function(node) {
                return new users.timfelgentreff.jsinterpreter.If(node.pos, this.visit(node.condExpr), this.visit(node.trueExpr), this.visit(node.falseExpr))
            },
            visitWhile: function(node) {
                return new users.timfelgentreff.jsinterpreter.While(node.pos, this.visit(node.condExpr), this.visit(node.body))
            },
            visitDoWhile: function(node) {
                return new users.timfelgentreff.jsinterpreter.DoWhile(node.pos, this.visit(node.body), this.visit(node.condExpr))
            },
            visitFor: function(node) {
                return new users.timfelgentreff.jsinterpreter.For(node.pos, this.visit(node.init), this.visit(node.condExpr), this.visit(node.body), this.visit(node.upd))
            },
            visitForIn: function(node) {
                return new users.timfelgentreff.jsinterpreter.ForIn(node.pos, this.visit(node.name), this.visit(node.obj), this.visit(node.body))
            },
            visitSet: function(node) {
                return new users.timfelgentreff.jsinterpreter.Set(node.pos, this.visit(node.left), this.visit(node.right))
            },
            visitModifyingSet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ModifyingSet(node.pos, this.visit(node.left), node.name, this.visit(node.right))
            },
            visitBinaryOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.BinaryOp(node.pos, node.name, this.visit(node.left), this.visit(node.right))
            },
            visitUnaryOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.UnaryOp(node.pos, node.name, this.visit(node.expr))
            },
            visitPreOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.PreOp(node.pos, node.name, this.visit(node.expr))
            },
            visitPostOp: function(node) {
                return new users.timfelgentreff.jsinterpreter.PostOp(node.pos, node.name, this.visit(node.expr))
            },
            visitThis: function(node) {
                return new users.timfelgentreff.jsinterpreter.This(node.pos)
            },
            visitVariable: function(node) {
                return new users.timfelgentreff.jsinterpreter.Variable(node.pos, node.name)
            },
            visitGetSlot: function(node) {
                return new users.timfelgentreff.jsinterpreter.GetSlot(node.pos, this.visit(node.slotName), this.visit(node.obj))
            },
            visitBreak: function(node) {
                return new users.timfelgentreff.jsinterpreter.Break(node.pos)
            },
            visitDebugger: function(node) {
                return new users.timfelgentreff.jsinterpreter.Debugger(node.pos)
            },
            visitContinue: function(node) {
                return new users.timfelgentreff.jsinterpreter.Continue(node.pos)
            },
            visitArrayLiteral: function(node) {
                return new users.timfelgentreff.jsinterpreter.ArrayLiteral(node.pos, this.visitNodes(node.elements))
            },
            visitReturn: function(node) {
                return new users.timfelgentreff.jsinterpreter.Return(node.pos, this.visit(node.expr))
            },
            visitWith: function() {
                throw new Error("with statement not supported")
            },
            visitSend: function(node) {
                return new users.timfelgentreff.jsinterpreter.Send(node.pos, this.visit(node.property), this.visit(node.recv), this.visitNodes(node.args))
            },
            visitCall: function(node) {
                return new users.timfelgentreff.jsinterpreter.Call(node.pos, this.visit(node.fn), this.visitNodes(node.args))
            },
            visitNew: function(node) {
                return new users.timfelgentreff.jsinterpreter.New(node.pos, this.visit(node.clsExpr))
            },
            visitVarDeclaration: function(node) {
                return new users.timfelgentreff.jsinterpreter.VarDeclaration(node.pos, node.name, this.visit(node.val))
            },
            visitThrow: function(node) {
                return new users.timfelgentreff.jsinterpreter.Throw(node.pos, this.visit(node.expr))
            },
            visitTryCatchFinally: function(node) {
                return new users.timfelgentreff.jsinterpreter.TryCatchFinally(node.pos, this.visit(node.trySeq), node.err, this.visit(node.catchSeq), this.visit(node.finallySeq))
            },
            visitFunction: function(node) {
                return new users.timfelgentreff.jsinterpreter.Function(node.pos, this.visit(node.body), this.visitNodes(node.args))
            },
            visitObjectLiteral: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral(node.pos, this.visitNodes(node.properties))
            },
            visitObjProperty: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjProperty(node.pos, node.name, this.visit(node.property))
            },
            visitSwitch: function(node) {
                return new users.timfelgentreff.jsinterpreter.Switch(node.pos, this.visit(node.expr), this.visitNodes(node.cases))
            },
            visitCase: function(node) {
                return new users.timfelgentreff.jsinterpreter.Case(node.pos, this.visit(node.condExpr), this.visit(node.thenExpr))
            },
            visitDefault: function(node) {
                return new users.timfelgentreff.jsinterpreter.Case(node.pos, this.visit(node.defaultExpr))
            },
            visitRegex: function(node) {
                return new users.timfelgentreff.jsinterpreter.Regex(node.pos, node.exprString, node.flags)
            },
            visitObjPropertyGet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjPropertyGet(node.pos, node.name, this.visit(node.body))
            },
            visitObjPropertySet: function(node) {
                return new users.timfelgentreff.jsinterpreter.ObjPropertySet(node.pos, node.name, this.visit(node.body), node.arg)
            }
        }), users.timfelgentreff.jsinterpreter.Rewriting.Transformation.subclass("users.timfelgentreff.jsinterpreter.Rewriting.RemoveDebugger", "visiting", {
            visitDebugger: function() {
                return void 0
            }
        }), users.timfelgentreff.jsinterpreter.Rewriting.Transformation.subclass("users.timfelgentreff.jsinterpreter.Rewriting.Rewriter", "initializing", {
            initialize: function($super) {
                $super(), this.scopes = []
            }
        }, "scoping", {
            enterScope: function() {
                this.scopes.push([])
            },
            registerVar: function(name) {
                0 != this.scopes.length && this.scopes.last().push(name)
            },
            referenceVar: function(name) {
                for (var i = this.scopes.length - 1; i >= 0; i--)
                    if (this.scopes[i].include(name)) return i;
                return void 0
            },
            exitScope: function() {
                this.scopes.pop()
            }
        }, "helping", {
            computationFrame: function() {
                return new users.timfelgentreff.jsinterpreter.Variable([0, 0], "_")
            },
            localFrame: function(i) {
                return new users.timfelgentreff.jsinterpreter.Variable([0, 0], "_" + i)
            },
            frame: function(i) {
                return 0 > i ? new users.timfelgentreff.jsinterpreter.Variable([0, 0], "Global") : new users.timfelgentreff.jsinterpreter.Variable([0, 0], "__" + i)
            },
            storeComputationResult: function(node) {
                if (0 == this.scopes.length) return node;
                var name = new users.timfelgentreff.jsinterpreter.String(node.pos, node.position()),
                    target = new users.timfelgentreff.jsinterpreter.GetSlot(node.pos, name, this.computationFrame());
                return new users.timfelgentreff.jsinterpreter.Set(node.pos, target, node)
            },
            registerArguments: function(func) {
                for (var args = [], i = 0; i < func.args.length; i++) {
                    var arg = func.args[i];
                    this.registerVar(arg.name), args.push(new users.timfelgentreff.jsinterpreter.Variable(arg.pos, arg.name))
                }
                return args
            },
            registerLocals: function(func) {
                var that = this;
                func.body.withAllChildNodesDo(function(node) {
                    return node.isFunction ? !1 : (node.isVarDeclaration && that.registerVar(node.name), !0)
                })
            }
        }, "rewriting", {
            wrapVar: function(pos, name) {
                var scope = this.referenceVar(name);
                return void 0 === scope ? new users.timfelgentreff.jsinterpreter.Variable(pos, name) : new users.timfelgentreff.jsinterpreter.GetSlot(pos, new users.timfelgentreff.jsinterpreter.String(pos, name), this.localFrame(scope))
            },
            rewriteVarDeclaration: function(pos, name, expr) {
                return new users.timfelgentreff.jsinterpreter.Set(pos, this.wrapVar(pos, name), expr)
            },
            emptyObj: function() {
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral([0, 0], [])
            },
            argsInitObj: function(args) {
                for (var properties = [], i = 0; i < args.length; i++) {
                    var arg = args[i].name,
                        argVal = new users.timfelgentreff.jsinterpreter.Variable([0, 0], arg);
                    properties.push(new users.timfelgentreff.jsinterpreter.ObjProperty([0, 0], arg, argVal))
                }
                return new users.timfelgentreff.jsinterpreter.ObjectLiteral([0, 0], properties)
            },
            addPreamble: function(astIdx, body, args) {
                var p = body.pos,
                    level = this.scopes.length,
                    initComputationFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "_", this.emptyObj()),
                    initLocalFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "_" + level, this.argsInitObj(args)),
                    frame = new users.timfelgentreff.jsinterpreter.ArrayLiteral(p, [this.computationFrame(), this.localFrame(level), new users.timfelgentreff.jsinterpreter.Number(p, astIdx), this.frame(level - 1)]),
                    initFrame = new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "__" + level, frame);
                return new users.timfelgentreff.jsinterpreter.Sequence(p, [initComputationFrame, initLocalFrame, initFrame, body])
            },
            catchExceptions: function(astIdx, body) {
                var p = body.pos,
                    level = this.scopes.length,
                    throwStmt = new users.timfelgentreff.jsinterpreter.Throw(p, new users.timfelgentreff.jsinterpreter.Variable(p, "ex")),
                    shiftStmt = new users.timfelgentreff.jsinterpreter.Send(p, new users.timfelgentreff.jsinterpreter.String(p, "shiftFrame"), new users.timfelgentreff.jsinterpreter.Variable(p, "ex"), [new users.timfelgentreff.jsinterpreter.This(p), new users.timfelgentreff.jsinterpreter.Variable(p, "__" + level)]),
                    isUnwind = new users.timfelgentreff.jsinterpreter.GetSlot(p, new users.timfelgentreff.jsinterpreter.String(p, "isUnwindException"), new users.timfelgentreff.jsinterpreter.Variable(p, "e")),
                    classExpr = new users.timfelgentreff.jsinterpreter.GetSlot(p, new users.timfelgentreff.jsinterpreter.String(p, "UnwindExecption"), new users.timfelgentreff.jsinterpreter.GetSlot(p, new users.timfelgentreff.jsinterpreter.String(p, "Rewriting"), new users.timfelgentreff.jsinterpreter.GetSlot(p, new users.timfelgentreff.jsinterpreter.String(p, "ast"), new users.timfelgentreff.jsinterpreter.Variable(p, "lively")))),
                    newUnwind = new users.timfelgentreff.jsinterpreter.New(p, new users.timfelgentreff.jsinterpreter.Call(p, classExpr, [new users.timfelgentreff.jsinterpreter.Variable(p, "e")])),
                    cond = new users.timfelgentreff.jsinterpreter.Cond(p, isUnwind, new users.timfelgentreff.jsinterpreter.Variable(p, "e"), newUnwind),
                    catchSeq = new users.timfelgentreff.jsinterpreter.Sequence(p, [new users.timfelgentreff.jsinterpreter.VarDeclaration(p, "ex", cond), shiftStmt, throwStmt]),
                    noop = new users.timfelgentreff.jsinterpreter.Variable(body.pos, "undefined"),
                    error = new users.timfelgentreff.jsinterpreter.Variable(body.pos, "e");
                return new users.timfelgentreff.jsinterpreter.TryCatchFinally(body.pos, body, error, catchSeq, noop)
            },
            wrapFunctionBody: function(astIdx, body, args) {
                return this.catchExceptions(astIdx, this.addPreamble(astIdx, body, args))
            },
            wrapClosure: function(idx, node) {
                var fn = new users.timfelgentreff.jsinterpreter.Variable(node.pos, "__createClosure"),
                    scope = this.frame(this.scopes.length - 1),
                    astIdx = new users.timfelgentreff.jsinterpreter.Number([0, 0], idx);
                return new users.timfelgentreff.jsinterpreter.Call(node.pos, fn, [astIdx, scope, node])
            }
        }, "visiting", {
            visitVarDeclaration: function(node) {
                return this.registerVar(node.name.value), this.storeComputationResult(this.rewriteVarDeclaration(node.pos, node.name, this.visit(node.val)))
            },
            visitVariable: function(node) {
                return this.wrapVar(node.pos, node.name)
            },
            visitDebugger: function(node) {
                var ret = new users.timfelgentreff.jsinterpreter.Return(node.pos, new users.timfelgentreff.jsinterpreter.String(node.pos, "Debuggger")),
                    returnDebugger = new users.timfelgentreff.jsinterpreter.Function(node.pos, new users.timfelgentreff.jsinterpreter.Sequence(node.pos, [ret]), []),
                    ast = this.storeComputationResult(returnDebugger),
                    toString = new users.timfelgentreff.jsinterpreter.ObjProperty(node.pos, "toString", ast);
                return new users.timfelgentreff.jsinterpreter.Throw(node.pos, new users.timfelgentreff.jsinterpreter.ObjectLiteral(node.pos, [toString]))
            },
            visitSet: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitCall: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitSend: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitModifyingSet: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitPreOp: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitPostOp: function($super, node) {
                return this.storeComputationResult($super(node))
            },
            visitNew: function(node) {
                var clsExpr = this.visit(node.clsExpr);
                return clsExpr.isSet && (clsExpr = clsExpr.right), this.storeComputationResult(new users.timfelgentreff.jsinterpreter.New(node.pos, clsExpr))
            },
            visitFunction: function($super, node) {
                this.enterScope();
                var args = this.registerArguments(node);
                this.registerLocals(node);
                var rewritten = new users.timfelgentreff.jsinterpreter.Function(node.pos, this.visit(node.body), args);
                this.exitScope(), users.timfelgentreff.jsinterpreter.Rewriting.table.push(node);
                var idx = users.timfelgentreff.jsinterpreter.Rewriting.table.length - 1;
                return rewritten.body = this.wrapFunctionBody(idx, rewritten.body, rewritten.args), this.storeComputationResult(this.wrapClosure(idx, rewritten))
            }
        }), Object.subclass("users.timfelgentreff.jsinterpreter.Rewriting.UnwindExecption", "settings", {
            isUnwindException: !0
        }, "initializing", {
            initialize: function(error) {
                this.error = error
            }
        }, "printing", {
            toString: function() {
                return this.error.toString()
            }
        }, "frames", {
            shiftFrame: function(thiz, frame) {
                var computationFrame = frame[0],
                    localFrame = frame[1];
                localFrame["this"] = thiz;
                var astIndex = frame[2],
                    scope = frame[3],
                    stackFrame = [computationFrame, localFrame, astIndex, Global, scope];
                return this.top ? (this.last[3] = stackFrame, this.last = stackFrame, void 0) : (this.top = this.last = stackFrame, void 0)
            }
        }), Object.extend(Global, {
            __createClosure: function(idx, scope, f) {
                return f._cachedAst = users.timfelgentreff.jsinterpreter.Rewriting.table[idx], f._cachedScope = scope, f
            },
            eval2: function(src) {
                var ast = users.timfelgentreff.jsinterpreter.Parser.parse(src, "topLevel"),
                    wrapped = new users.timfelgentreff.jsinterpreter.Function([0, 0], ast, []);
                wrapped.source = src;
                var rewriter = new users.timfelgentreff.jsinterpreter.Rewriting.Rewriter,
                    rewrittenAst = rewriter.visit(wrapped);
                return users.timfelgentreff.jsinterpreter.oldEval(rewrittenAst.asJS())()
            }
        }), Object.extend(JSLoader, {
            loadJs2: function(url, onLoadCb, loadSync, okToUseCache, cacheQuery) {
                var exactUrl = url;
                exactUrl.indexOf("!svn") <= 0 && !okToUseCache && (exactUrl = this.makeUncached(exactUrl, cacheQuery)), $.ajax(exactUrl, {
                    success: users.timfelgentreff.jsinterpreter.Rewriting.loadJS.bind(users.timfelgentreff.jsinterpreter.Rewriting, onLoadCb)
                })
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter.Rewriting, {
            loadJS: function(cb, src) {
                src || (src = cb, cb = null), eval(src), cb && cb()
            }
        })
    }), module("users.timfelgentreff.jsinterpreter.Interpreter").requires("users.timfelgentreff.jsinterpreter.Parser", "users.timfelgentreff.jsinterpreter.Meta", "users.timfelgentreff.jsinterpreter.Rewriting").toRun(function() {
        Object.subclass("users.timfelgentreff.jsinterpreter.Interpreter.Frame", "initialization", {
            initialize: function(func, mapping) {
                this.func = func, this.mapping = mapping || {}, this.returnTriggered = !1, this.breakTriggered = !1, this.continueTriggered = !1, this.findSetterMode = !1, this.breakAtCalls = !1, this.pc = null, this.bp = null, this.values = {}
            },
            newScope: function(mapping) {
                var newFrame = new users.timfelgentreff.jsinterpreter.Interpreter.Frame(mapping);
                return newFrame.setContainingScope(this), newFrame
            },
            breakAtFirstStatement: function() {
                this.bp = this.func.ast().firstStatement()
            }
        }, "accessing", {
            setContainingScope: function(frame) {
                return this.containingScope = frame
            },
            getContainingScope: function() {
                return this.containingScope
            },
            getCaller: function() {
                return this.caller
            },
            setCaller: function(caller) {
                caller && (this.caller = caller, caller.callee = this, caller.breakAtCalls && this.breakAtFirstStatement())
            },
            setThis: function(thisObj) {
                return this.addToMapping("this", thisObj), thisObj
            },
            getThis: function() {
                return this.mapping["this"] ? this.mapping["this"] : Global
            },
            setArguments: function(argValues) {
                for (var argNames = this.func.ast().argNames(), i = 0; i < argNames.length; i++) this.addToMapping(argNames[i], argValues[i]);
                return this.arguments = argValues
            },
            getArguments: function() {
                return this.arguments
            },
            getFuncName: function() {
                return this.func ? this.func.getOriginal().qualifiedMethodName() : "frame has no function!"
            },
            getFuncSource: function() {
                return this.func ? this.func.getOriginal().toSource() : "frame has no function!"
            },
            findFrame: function(name) {
                if (this.mapping.hasOwnProperty(name)) return {
                    val: this.mapping[name],
                    frame: this
                };
                if (this.mapping === Global) throw new ReferenceError(name + " is not defined");
                var mapping = this.func.getVarMapping();
                if (mapping && mapping.hasOwnProperty(name)) return {
                    val: mapping[name],
                    frame: this
                };
                var containingScope = this.getContainingScope();
                return containingScope ? containingScope.findFrame(name) : null
            },
            lookup: function(name) {
                if ("undefined" === name) return void 0;
                if ("null" === name) return null;
                if ("true" === name) return !0;
                if ("false" === name) return !1;
                if ("NaN" === name) return 0 / 0;
                if ("arguments" === name) return this.getArguments();
                var frame = this.findFrame(name);
                return frame ? frame.val : void 0
            },
            addToMapping: function(name, value) {
                return this.mapping[name] = value
            },
            addAllToMapping: function(otherMapping) {
                for (var name in otherMapping) otherMapping.hasOwnProperty(name) && (this.mapping[name] = otherMapping[name])
            },
            triggerReturn: function() {
                this.returnTriggered = !0
            },
            triggerBreak: function() {
                this.breakTriggered = !0
            },
            stopBreak: function() {
                this.breakTriggered = !1
            },
            triggerContinue: function() {
                this.continueTriggered = !0
            },
            stopContinue: function() {
                this.continueTriggered = !1
            }
        }, "accessing for UI", {
            listItemsForIntrospection: function() {
                var items = Properties.forEachOwn(this.mapping, function(name, value) {
                    return {
                        isListItem: !0,
                        string: name + ": " + String(value).truncate(50),
                        value: value
                    }
                });
                return this.containingScope && (items.push({
                    isListItem: !0,
                    string: "[[containing scope]]"
                }), items.pushAll(this.containingScope.listItemsForIntrospection())), items
            }
        }, "program counter", {
            halt: function() {
                if (this.unbreak(), users.timfelgentreff.jsinterpreter.halt(this)) throw {
                    isUnwindException: !0,
                    topFrame: this,
                    toString: function() {
                        return "Debugger"
                    }
                }
            },
            haltAtNextStatement: function() {
                if (this.pc === this.func.ast()) {
                    var caller = this.getCaller();
                    caller && caller.isResuming() && caller.haltAtNextStatement()
                } else {
                    var nextStmt = this.pc.nextStatement();
                    this.bp = nextStmt ? nextStmt : this.func.ast()
                }
            },
            stepToNextStatement: function(breakAtCalls) {
                return this.haltAtNextStatement(), this.resume(breakAtCalls)
            },
            hasNextStatement: function() {
                return null != this.pc.nextStatement()
            },
            restart: function() {
                this.initialize(this.func, this.mapping), this.breakAtFirstStatement(), this.resume()
            }
        }, "resuming", {
            isResuming: function() {
                return null !== this.pc || null !== this.bp
            },
            resumesNow: function() {
                this.pc = null
            },
            isBreakingAt: function(node) {
                return null === this.bp ? !1 : this.bp === node ? !0 : this.bp == node.nextStatement() ? !1 : node.isAfter(this.bp)
            },
            findPC: function() {
                if (!Object.isEmpty(this.values)) {
                    var last = Object.keys(this.values).max(function(k) {
                            var fromTo = k.split("-");
                            return +fromTo[1] << 23 - +fromTo[0]
                        }),
                        node = this.func.ast().nodesMatching(function(node) {
                            return last == node.position()
                        })[0];
                    if (node.isDebugger) return this.pc = node;
                    var pc = null,
                        foundNode = !1;
                    this.func.ast().withAllChildNodesDoPostOrder(function(n) {
                        if (foundNode) {
                            if (n.isCall || n.isSend || n.isSet || n.isModifyingSet || n.isPreOp || n.isPostOp) return pc = n, !1
                        } else n === node && (foundNode = !0);
                        return !0
                    }), this.pc = pc || this.func.ast()
                }
            },
            setPC: function(node) {
                this.pc = node.isFunction ? node : node.firstStatement(), this.isBreakingAt(node) && this.halt()
            },
            getValue: function(node) {
                var value = this.values[node.position()];
                return value ? value : this.setPC(node)
            },
            putValue: function(node, value) {
                return this.values[node.position()] = {
                    val: value
                }
            },
            removeValue: function(node) {
                var that = this;
                node.withAllChildNodesDo(function(child) {
                    return delete that.values[child.position()], !0
                })
            },
            resume: function(breakAtCalls) {
                this.breakAtCalls = breakAtCalls ? !0 : !1;
                var result = this.func.ast().resume(this);
                return this.getCaller() && this.getCaller().isResuming() && this.getCaller().putValue(this.getCaller().pc, result), this.setPC(this.func.ast()), this.getCaller() && this.getCaller().isResuming() ? this.getCaller().resume(breakAtCalls) : result
            },
            unbreak: function() {
                this.bp = null, this.getCaller() && this.getCaller().unbreak()
            }
        }, "debugging", {
            toString: function() {
                var mappings = [];
                for (var name in this.mapping) this.mapping.hasOwnProperty(name) && mappings.push(name + ": " + this.mapping[name]);
                var mappingString = "{" + mappings.join(",") + "}";
                return "Frame(" + mappingString + ")"
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter.Interpreter.Frame, {
            create: function(func, mapping) {
                return new users.timfelgentreff.jsinterpreter.Interpreter.Frame(func, mapping || {})
            },
            global: function() {
                return this.create(null, Global)
            },
            fromTraceNode: function(trace) {
                var frame;
                return trace.frame ? frame = trace.frame : (frame = users.timfelgentreff.jsinterpreter.Interpreter.Frame.create(trace.method), frame.setThis(trace.itsThis), frame.setArguments(trace.args)), trace.caller && !trace.caller.isRoot && frame.setCaller(users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromTraceNode(trace.caller)), frame
            },
            fromScope: function(scope, callstack) {
                if (scope === Global) return users.timfelgentreff.jsinterpreter.Interpreter.Frame.global();
                var ast = users.timfelgentreff.jsinterpreter.Rewriting.table[scope[2]],
                    frame = new users.timfelgentreff.jsinterpreter.Interpreter.Frame(ast.asFunction(), scope[1]),
                    parent = users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(scope[3], callstack);
                return callstack ? (frame.values = scope[0], frame.findPC(), scope[3] !== Global && frame.setCaller(parent), scope[4] !== Global && frame.setContainingScope(users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(scope[4]))) : frame.setContainingScope(parent), frame
            }
        }), users.timfelgentreff.jsinterpreter.Visitor.subclass("users.timfelgentreff.jsinterpreter.InterpreterVisitor", "interface", {
            run: function(node, optMapping) {
                return this.runWithFrame(node, users.timfelgentreff.jsinterpreter.Interpreter.Frame.create(null, optMapping))
            },
            runWithFrame: function(node, frame) {
                return this.currentFrame = frame, this.visit(node)
            }
        }, "invoking", {
            isNative: function(func) {
                return this._nativeFuncRegex || (this._nativeFuncRegex = /\{\s+\[native\scode\]\s+\}$/), this._nativeFuncRegex.test(func.toString())
            },
            shouldInterpret: function(frame, func) {
                return this.isNative(func) ? !1 : func.hasOwnProperty("forInterpretation") || frame.breakAtCalls || func.containsDebugger()
            },
            invoke: function(node, recv, func, argValues) {
                var isNew = node._parent && node._parent.isNew;
                if (this.currentFrame.setPC(node), recv && Object.isFunction(recv) && func === Function.prototype.apply && (func = recv, recv = argValues.shift(), argValues = argValues[0]), this.shouldInterpret(this.currentFrame, func) && (func = func.forInterpretation()), isNew) {
                    if (this.isNative(func)) return new func;
                    recv = this.newObject(func)
                }
                var result = func.apply(recv, argValues);
                return isNew ? recv : result
            },
            newObject: function(func) {
                function constructor() {}
                var proto = func.prototype;
                constructor.prototype = proto;
                var newObj = new constructor;
                return newObj.constructor = func, newObj
            }
        }, "visiting", {
            visit: function(node) {
                var value = this.currentFrame.getValue(node);
                return value || (value = this.currentFrame.putValue(node, node.accept(this))), value.val
            },
            visitSequence: function(node) {
                for (var result, frame = this.currentFrame, i = 0; i < node.children.length; i++)
                    if (result = this.visit(node.children[i]), frame.returnTriggered || frame.breakTriggered || frame.continueTriggered) return result;
                return result
            },
            visitNumber: function(node) {
                return node.value
            },
            visitString: function(node) {
                return node.value
            },
            visitCond: function(node) {
                var condVal = (this.currentFrame, this.visit(node.condExpr));
                return condVal ? this.visit(node.trueExpr) : this.visit(node.falseExpr)
            },
            visitIf: function(node) {
                return this.visitCond(node)
            },
            visitWhile: function(node) {
                for (var result, frame = this.currentFrame; this.visit(node.condExpr);) {
                    if (result = this.visit(node.body), frame.continueTriggered && frame.stopContinue(), frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    }
                    if (frame.returnTriggered) return result;
                    frame.removeValue(node.condExpr), frame.removeValue(node.body)
                }
                return result
            },
            visitDoWhile: function(node) {
                var result, condResult, frame = this.currentFrame;
                do {
                    if (frame.removeValue(node.condExpr), result = this.visit(node.body), frame.continueTriggered && frame.stopContinue(), frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    }
                    if (frame.returnTriggered) return result;
                    condResult = this.visit(node.condExpr), frame.removeValue(node.body)
                } while (condResult);
                return result
            },
            visitFor: function(node) {
                var result, frame = this.currentFrame;
                for (this.visit(node.init); this.visit(node.condExpr);) {
                    if (result = this.visit(node.body), frame.continueTriggered && frame.stopContinue(), frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    }
                    if (frame.returnTriggered) return result;
                    this.visit(node.upd), frame.removeValue(node.condExpr), frame.removeValue(node.body), frame.removeValue(node.upd)
                }
                return result
            },
            visitForIn: function(node) {
                var result, frame = this.currentFrame,
                    varPart = node.name,
                    obj = this.visit(node.obj);
                varPart.isVarDeclaration && (varPart.val.name = varPart.name);
                for (var name in obj) {
                    if (frame.addToMapping(varPart.name, name), result = this.visit(node.body), frame.continueTriggered && frame.stopContinue(), frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    }
                    if (frame.returnTriggered) return result;
                    frame.removeValue(node.body)
                }
                return result
            },
            visitSet: function(node) {
                var frame = this.currentFrame;
                return node.left.set(this.visit(node.right), frame, this)
            },
            visitModifyingSet: function(node) {
                var newValue, frame = this.currentFrame,
                    op = node.name + "=",
                    oldValue = this.visit(node.left);
                switch (op) {
                    case "+=":
                        newValue = oldValue + this.visit(node.right);
                        break;
                    case "-=":
                        newValue = oldValue - this.visit(node.right);
                        break;
                    case "*=":
                        newValue = oldValue * this.visit(node.right);
                        break;
                    case "/=":
                        newValue = oldValue / this.visit(node.right);
                        break;
                    case ">>=":
                        newValue = oldValue >>= this.visit(node.right);
                        break;
                    case "<<=":
                        newValue = oldValue <<= this.visit(node.right);
                        break;
                    case ">>>=":
                        newValue = oldValue >>> this.visit(node.right);
                        break;
                    case "&=":
                        newValue = oldValue & this.visit(node.right);
                        break;
                    case "|=":
                        newValue = oldValue | this.visit(node.right);
                        break;
                    case "&=":
                        newValue = oldValue & this.visit(node.right);
                        break;
                    case "^=":
                        newValue = oldValue ^ this.visit(node.right);
                        break;
                    case "||=":
                        newValue = oldValue || this.visit(node.right);
                        break;
                    case "&&=":
                        newValue = oldValue && this.visit(node.right);
                        break;
                    default:
                        throw new Error("Modifying set has unknown operation " + op)
                }
                return node.left.set(newValue, frame, this)
            },
            visitBinaryOp: function(node) {
                var leftVal = (this.currentFrame, this.visit(node.left));
                switch (node.name) {
                    case "||":
                        return leftVal || this.visit(node.right);
                    case "&&":
                        return leftVal && this.visit(node.right)
                }
                var rightVal = this.visit(node.right);
                switch (node.name) {
                    case "+":
                        return leftVal + rightVal;
                    case "-":
                        return leftVal - rightVal;
                    case "*":
                        return leftVal * rightVal;
                    case "/":
                        return leftVal / rightVal;
                    case "%":
                        return leftVal % rightVal;
                    case "<":
                        return rightVal > leftVal;
                    case "<=":
                        return rightVal >= leftVal;
                    case ">":
                        return leftVal > rightVal;
                    case ">=":
                        return leftVal >= rightVal;
                    case "==":
                        return leftVal == rightVal;
                    case "===":
                        return leftVal === rightVal;
                    case "!=":
                        return leftVal != rightVal;
                    case "!==":
                        return leftVal !== rightVal;
                    case "&":
                        return leftVal & rightVal;
                    case "|":
                        return leftVal | rightVal;
                    case "^":
                        return leftVal ^ rightVal;
                    case ">>":
                        return leftVal >> rightVal;
                    case "<<":
                        return leftVal << rightVal;
                    case ">>>":
                        return leftVal >>> rightVal;
                    case "in":
                        return leftVal in rightVal;
                    case "instanceof":
                        return leftVal instanceof rightVal;
                    default:
                        throw new Error("No semantics for binary op " + node.name)
                }
            },
            visitUnaryOp: function(node) {
                var val = (this.currentFrame, this.visit(node.expr));
                switch (node.name) {
                    case "-":
                        return -val;
                    case "!":
                        return !val;
                    case "~":
                        return ~val;
                    case "typeof":
                        return typeof val;
                    default:
                        throw new Error("No semantics for unary op " + node.name)
                }
            },
            visitPreOp: function(node) {
                var frame = this.currentFrame,
                    setExpr = node.expr;
                if (!setExpr.isVariable && !setExpr.isGetSlot) throw new Error("Invalid expr in pre op " + setExpr);
                var newValue, value = this.visit(setExpr);
                switch (node.name) {
                    case "++":
                        newValue = value + 1;
                        break;
                    case "--":
                        newValue = value - 1;
                        break;
                    default:
                        throw new Error("No semantics for pre op " + node.name)
                }
                return setExpr.set(newValue, frame, this), newValue
            },
            visitPostOp: function(node) {
                var frame = this.currentFrame,
                    setExpr = node.expr;
                if (!setExpr.isVariable && !setExpr.isGetSlot) throw dbgOn(new Error("Invalid expr in post op " + setExpr));
                var newValue, value = this.visit(setExpr);
                switch (node.name) {
                    case "++":
                        newValue = value + 1;
                        break;
                    case "--":
                        newValue = value - 1;
                        break;
                    default:
                        throw new Error("No semantics for post op " + node.name)
                }
                return setExpr.set(newValue, frame, this), value
            },
            visitThis: function() {
                return this.currentFrame.getThis()
            },
            visitVariable: function(node) {
                return this.currentFrame.lookup(node.name)
            },
            visitGetSlot: function(node) {
                var obj = this.visit(node.obj),
                    name = this.visit(node.slotName),
                    value = obj[name];
                return value
            },
            visitBreak: function() {
                this.currentFrame.triggerBreak()
            },
            visitContinue: function() {
                this.currentFrame.triggerContinue()
            },
            visitDebugger: function($super, node) {
                this.currentFrame.putValue(node, 1), this.currentFrame.halt(node, !0)
            },
            visitArrayLiteral: function(node) {
                for (var result = new Array(node.elements.length), i = 0; i < node.elements.length; i++) result[i] = this.visit(node.elements[i]);
                return result
            },
            visitReturn: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.expr);
                return frame.triggerReturn(), val
            },
            visitWith: function() {
                throw new Error("with statement not yet supported")
            },
            visitSend: function(node) {
                var recv = this.visit(node.recv),
                    property = this.visit(node.property),
                    argValues = node.args.collect(function(ea) {
                        return this.visit(ea)
                    }, this);
                return this.invoke(node, recv, recv[property], argValues)
            },
            visitCall: function(node) {
                var func = this.visit(node.fn),
                    argValues = node.args.collect(function(ea) {
                        return this.visit(ea)
                    }, this);
                return this.invoke(node, void 0, func, argValues)
            },
            visitNew: function(node) {
                return this.visit(node.clsExpr)
            },
            visitVarDeclaration: function(node) {
                var frame = this.currentFrame,
                    val = this.visit(node.val);
                return frame.addToMapping(node.name, val), val
            },
            visitThrow: function(node) {
                var exceptionObj = (this.currentFrame, this.visit(node.expr));
                throw exceptionObj
            },
            visitTryCatchFinally: function(node) {
                var result, frame = this.currentFrame;
                try {
                    result = this.visit(node.trySeq)
                } catch (e) {
                    frame.addToMapping(node.err.name, e), result = this.visit(node.catchSeq)
                } finally {
                    node.finallySeq.isVariable && "undefined" == node.finallySeq.name || (result = this.visit(node.finallySeq))
                }
                return result
            },
            visitFunction: function(node) {
                var frame = this.currentFrame;
                return Object.isString(node.name) && frame.addToMapping(node.name, node), node.prototype || (node.prototype = {}), node.lexicalScope = frame, node.asFunction()
            },
            visitObjectLiteral: function(node) {
                for (var obj = (this.currentFrame, {}), i = 0; i < node.properties.length; i++) {
                    var name = node.properties[i].name,
                        prop = this.visit(node.properties[i].property);
                    obj[name] = prop
                }
                return obj
            },
            visitObjProperty: function() {
                throw new Error("?????")
            },
            visitSwitch: function(node) {
                for (var result, frame = this.currentFrame, val = this.visit(node.expr), caseMatched = !1, i = 0; i < node.cases.length; i++)
                    if (node.cases[i].prevCaseMatched = caseMatched, node.cases[i].switchValue = val, result = this.visit(node.cases[i]), caseMatched = void 0 !== result, frame.breakTriggered) {
                        frame.stopBreak();
                        break
                    }
                return result
            },
            visitCase: function(node) {
                return node.prevCaseMatched || node.switchValue == this.visit(node.condExpr) ? this.visit(node.thenExpr) : void 0
            },
            visitDefault: function(node) {
                return node.prevCaseMatched ? void 0 : this.visit(node.defaultExpr)
            },
            visitRegex: function(node) {
                return new RegExp(node.exprString, node.flags)
            }
        }), users.timfelgentreff.jsinterpreter.Node.addMethods("interpretation", {
            position: function() {
                return this.pos[0] + "-" + this.pos[1]
            },
            startInterpretation: function(optMapping) {
                var interpreter = new users.timfelgentreff.jsinterpreter.InterpreterVisitor;
                return interpreter.run(this, optMapping)
            },
            toSource: function() {
                return this.toString()
            },
            parentSource: function() {
                return this.source ? this.source : this.hasParent() ? this.getParent().parentSource() : this.toSource()
            }
        }), users.timfelgentreff.jsinterpreter.Variable.addMethods("interpretation", {
            set: function(value, frame) {
                var search = frame.findFrame(this.name),
                    scope = search ? search.frame : users.timfelgentreff.jsinterpreter.Interpreter.Frame.global();
                return scope.addToMapping(this.name, value)
            }
        }), users.timfelgentreff.jsinterpreter.GetSlot.addMethods("interpretation", {
            set: function(value, frame, interpreter) {
                var obj = interpreter.visit(this.obj),
                    name = interpreter.visit(this.slotName);
                return obj[name] = value
            }
        }), users.timfelgentreff.jsinterpreter.Function.addMethods("interpretation", {
            position: function() {
                return this.pos[0] + "-" + this.pos[1]
            },
            basicApply: function(frame) {
                var interpreter = new users.timfelgentreff.jsinterpreter.InterpreterVisitor;
                try {
                    return users.timfelgentreff.jsinterpreter.Interpreter.Frame.top = frame, interpreter.runWithFrame(this.body, frame)
                } finally {
                    users.timfelgentreff.jsinterpreter.Interpreter.Frame.top = null
                }
            },
            apply: function(thisObj, argValues, startHalted) {
                var calledFunction = this.asFunction(),
                    mapping = Object.extend({}, calledFunction.getVarMapping()),
                    argNames = this.argNames();
                mapping.$super && "$super" == argNames[0] && argValues.unshift(mapping.$super);
                var scope = this.lexicalScope ? this.lexicalScope : users.timfelgentreff.jsinterpreter.Interpreter.Frame.global(),
                    newFrame = scope.newScope(calledFunction, mapping);
                return void 0 !== thisObj && newFrame.setThis(thisObj), newFrame.setArguments(argValues), newFrame.setCaller(users.timfelgentreff.jsinterpreter.Interpreter.Frame.top), startHalted && newFrame.breakAtFirstStatement(), this.basicApply(newFrame)
            },
            asFunction: function(optFunc) {
                function fn() {
                    return that.apply(this, Array.from(arguments))
                }
                if (this._chachedFunction) return this._chachedFunction;
                var that = this;
                return fn.methodName = this.name(), fn.forInterpretation = function() {
                    return fn
                }, fn.ast = function() {
                    return that
                }, fn.startHalted = function() {
                    return function() {
                        return that.apply(this, Array.from(arguments), !0)
                    }
                }, fn.evaluatedSource = function() {
                    return that.parentSource()
                }, optFunc && (fn.source = optFunc.toSource(), fn.varMapping = optFunc.getVarMapping(), fn.prototype = optFunc.prototype, optFunc.declaredClass && (fn.declaredClass = optFunc.declaredClass), optFunc.methodName && (fn.methodName = optFunc.methodName), optFunc.sourceModule && (fn.sourceModule = optFunc.sourceModule), optFunc.declaredObject && (fn.declaredObject = optFunc.declaredObject), optFunc.name && (fn.methodName = optFunc.name)), this._chachedFunction = fn
            }
        }, "continued interpretation", {
            resume: function(frame) {
                return this.basicApply(frame)
            }
        }), Object.extend(users.timfelgentreff.jsinterpreter, {
            halt: function() {
                return !1
            },
            doWithHalt: function(func, halt) {
                var oldHalt = users.timfelgentreff.jsinterpreter.halt;
                users.timfelgentreff.jsinterpreter.halt = halt || Functions.True;
                try {
                    func()
                } finally {
                    users.timfelgentreff.jsinterpreter.halt = oldHalt
                }
            }
        }), users.timfelgentreff.jsinterpreter.Visitor.subclass("users.timfelgentreff.jsinterpreter.ContainsDebuggerVisitor", "visiting", {
            visitSequence: function(node) {
                for (var i = 0; i < node.children.length; i++)
                    if (this.visit(node.children[i])) return !0;
                return !1
            },
            visitNumber: function() {
                return !1
            },
            visitString: function() {
                return !1
            },
            visitCond: function(node) {
                return this.visit(node.condExpr) || this.visit(node.trueExpr) || this.visit(node.falseExpr)
            },
            visitIf: function(node) {
                return this.visitCond(node)
            },
            visitWhile: function(node) {
                return this.visit(node.condExpr) || this.visit(node.body)
            },
            visitDoWhile: function(node) {
                return this.visit(node.body) || this.visit(node.condExpr)
            },
            visitFor: function(node) {
                return this.visit(node.init) || this.visit(node.condExpr) || this.visit(node.body) || this.visit(node.upd)
            },
            visitForIn: function(node) {
                return this.visit(node.obj) || this.visit(node.body)
            },
            visitSet: function(node) {
                return this.visit(node.left) || this.visit(node.right)
            },
            visitModifyingSet: function(node) {
                return this.visit(node.left) || this.visit(node.right)
            },
            visitBinaryOp: function(node) {
                return this.visit(node.left) || this.visit(node.right)
            },
            visitUnaryOp: function(node) {
                return this.visit(node.expr)
            },
            visitPreOp: function(node) {
                return this.visit(node.expr)
            },
            visitPostOp: function(node) {
                return this.visit(node.expr)
            },
            visitThis: function() {
                return !1
            },
            visitVariable: function() {
                return !1
            },
            visitGetSlot: function() {
                return !1
            },
            visitBreak: function() {
                return !1
            },
            visitDebugger: function() {
                return !0
            },
            visitContinue: function() {
                return !1
            },
            visitArrayLiteral: function(node) {
                for (var i = 0; i < node.elements.length; i++)
                    if (this.visit(node.elements[i])) return !0;
                return !1
            },
            visitReturn: function(node) {
                return this.visit(node.expr)
            },
            visitWith: function() {
                throw new Error("with statement not yet supported")
            },
            visitSend: function(node) {
                if (this.visit(node.recv)) return !0;
                for (var i = 0; i < node.args.length; i++)
                    if (this.visit(node.args[i])) return !0;
                return !1
            },
            visitCall: function(node) {
                if (this.visit(node.fn)) return !0;
                for (var i = 0; i < node.args.length; i++)
                    if (this.visit(node.args[i])) return !0;
                return !1
            },
            visitNew: function(node) {
                return this.visit(node.clsExpr)
            },
            visitVarDeclaration: function(node) {
                return this.visit(node.val)
            },
            visitThrow: function(node) {
                return this.visit(node.expr)
            },
            visitTryCatchFinally: function(node) {
                return this.visit(node.trySeq) || this.visit(node.catchSeq) || this.visit(node.finallySeq)
            },
            visitFunction: function(node) {
                return this.visit(node.body)
            },
            visitObjectLiteral: function(node) {
                for (var i = 0; i < node.properties.length; i++)
                    if (this.visit(node.properties[i].property)) return !0;
                return !1
            },
            visitObjProperty: function() {
                return !1
            },
            visitSwitch: function(node) {
                if (this.visit(node.expr)) return !0;
                for (var i = 0; i < node.cases.length; i++)
                    if (this.visit(node.cases[i])) return !0;
                return !1
            },
            visitCase: function(node) {
                return this.visit(node.condExpr) || this.visit(node.thenExpr)
            },
            visitDefault: function(node) {
                return this.visit(node.defaultExpr)
            },
            visitRegex: function() {
                return !1
            }
        }), Function.addMethods("ast", {
            evaluatedSource: function() {
                return this.toSource()
            },
            ast: function() {
                if (this._cachedAst) return this._cachedAst;
                var parseResult = users.timfelgentreff.jsinterpreter.Parser.parse(this.toSource(), "topLevel");
                return !parseResult || Object.isString(parseResult) ? parseResult : (parseResult = parseResult.children[0], this._cachedAst = parseResult.isVarDeclaration && parseResult.val.isFunction ? parseResult.val : parseResult)
            }
        }, "debugging", {
            forInterpretation: function() {
                var funcAst = this.ast();
                return !funcAst.lexicalScope && this._cachedScope && (funcAst.lexicalScope = users.timfelgentreff.jsinterpreter.Interpreter.Frame.fromScope(this._cachedScope)), funcAst.asFunction(this)
            },
            containsDebugger: function() {
                return (new users.timfelgentreff.jsinterpreter.ContainsDebuggerVisitor).visit(this.ast())
            }
        })
    }), module("users.timfelgentreff.babelsberg.core_ext").requires().toRun(function() {
        Function.addMethods({
            varMap: function(obj) {
                return this.varMapping = obj, this
            },
            recursionGuard: function(obj, key) {
                if (!obj[key]) try {
                    obj[key] = !0, this()
                } finally {
                    obj[key] = !1
                }
            }
        }), Object.subclass("Guard", {
            initialize: function() {
                return this.counter = 0, this.lastCall = {}, this.cachedResult, this
            },
            call: function(id, func) {
                return this.counter !== this.lastCall[id] && (this.cachedResult = func(), this.lastCall[id] = this.counter), this.cachedResult
            },
            tick: function(arg) {
                arg ? this.counter = arg : this.counter++
            }
        }), Object.extend(Strings, {
            safeToString: function(obj) {
                var str, toS = Object.prototype.toString;
                try {
                    obj.toString && (str = obj.toString())
                } catch (e) {
                    str = toS.apply(obj)
                }
                return str
            }
        })
    }), module("users.timfelgentreff.babelsberg.constraintinterpreter").requires("users.timfelgentreff.jsinterpreter.Interpreter", "cop.Layers", "users.timfelgentreff.babelsberg.cassowary_ext", "users.timfelgentreff.babelsberg.deltablue_ext", "users.timfelgentreff.babelsberg.csp_ext", "users.timfelgentreff.babelsberg.core_ext", "users.timfelgentreff.babelsberg.src_transform", "users.timfelgentreff.babelsberg.babelsberg-lively", "users.timfelgentreff.sutherland.relax_bbb").toRun(function() {
        Object.subclass("Babelsberg", {
            initialize: function() {
                this.defaultSolvers = [], this.callbacks = []
            },
            isConstraintObject: !0,
            unconstrain: function(obj, accessor) {
                if (obj) {
                    var cvar = ConstrainedVariable.findConstraintVariableFor(obj, accessor);
                    if (cvar) {
                        var cGetter = obj.__lookupGetter__(accessor),
                            cSetter = obj.__lookupSetter__(accessor);
                        if (cGetter || cSetter) {
                            if (!cGetter.isConstraintAccessor || !cSetter.isConstraintAccessor) throw "too many accessors - unconstrain only works for the very simple case now";
                            ConstrainedVariable.deleteConstraintVariableFor(obj, accessor);
                            var newName = cvar.newIvarname,
                                existingSetter = obj.__lookupSetter__(newName),
                                existingGetter = obj.__lookupGetter__(newName);
                            existingGetter && obj.__defineGetter__(accessor, existingGetter), existingSetter && obj.__defineSetter__(accessor, existingSetter), existingSetter && existingGetter || delete obj[accessor], obj[accessor] = obj[newName], delete obj[newName];
                            var child = obj[accessor];
                            bbb.unconstrainAll(child)
                        }
                    }
                }
            },
            unconstrainAll: function(obj) {
                obj && obj instanceof Object && Object.keys(obj).each(function(property) {
                    var cvar = ConstrainedVariable.findConstraintVariableFor(obj, property);
                    if (cvar) {
                        var cGetter = obj.__lookupGetter__(property),
                            cSetter = obj.__lookupSetter__(property);
                        (cGetter || cSetter) && cGetter.isConstraintAccessor && cSetter.isConstraintAccessor && bbb.unconstrain(obj, property)
                    }
                })
            },
            edit: function(obj, accessors) {
                var extVars = {},
                    cVars = {},
                    solvers = [],
                    callback = function(newObj) {
                        if (newObj) {
                            var newEditConstants = newObj;
                            Object.isArray(newObj) || (newEditConstants = accessors.map(function(accessor) {
                                return newObj[accessor]
                            })), solvers.invoke("resolveArray", newEditConstants), accessors.each(function(a) {
                                cVars[a].suggestValue(cVars[a].externalValue)
                            })
                        } else {
                            for (var prop in extVars) extVars[prop].each(function(evar) {
                                evar.finishEdit()
                            });
                            solvers.invoke("endEdit")
                        }
                    };
                return accessors.each(function(accessor) {
                    var cvar = ConstrainedVariable.findConstraintVariableFor(obj, accessor);
                    if (!cvar) throw "Cannot edit " + obj + '["' + accessor + "\"], because it isn't constrained";
                    var evars = Properties.values(cvar._externalVariables);
                    if (evars.compact().length < evars.length) throw "Cannot edit " + obj + '["' + accessor + '"], because it is in a recalculate relation';
                    var hasEditSolver = cvar.solvers.any(function(s) {
                        return !Object.isFunction(s.beginEdit)
                    });
                    if (hasEditSolver) throw "Cannot edit " + obj + '["' + accessor + '"], because it is in a no-edit solver';
                    cVars[accessor] = cvar, extVars[accessor] = evars, solvers = solvers.concat(cvar.solvers).uniq(), evars.each(function(evar) {
                        evar.prepareEdit()
                    })
                }), solvers.invoke("beginEdit"), callback
            },
            readonly: function(obj) {
                return obj.isConstraintObject ? obj.setReadonly(!0) : Constraint.current && Constraint.current.solver && Properties.own(obj).each(function(ea) {
                    var cvar = ConstrainedVariable.newConstraintVariableFor(obj, ea);
                    cvar.addToConstraint(Constraint.current), cvar.ensureExternalVariableFor(Constraint.current.solver), cvar.isSolveable() && bbb.readonly(cvar.externalVariables(Constraint.current.solver))
                }), obj
            },
            always: function(opts, func) {
                var constraint = null,
                    solvers = this.chooseSolvers(opts.solver),
                    errors = [];
                return func.allowTests = opts.allowTests === !0, func.allowUnsolvableOperations = opts.allowUnsolvableOperations === !0, func.debugging = opts.debugging, func.onError = opts.onError, solvers.some(function(solver) {
                    try {
                        constraint = solver.always(opts, func)
                    } catch (e) {
                        return errors.push(e), !1
                    }
                    try {
                        opts.postponeEnabling || constraint.enable()
                    } catch (e) {
                        return errors.push(e), constraint.disable(), constraint = null, !1
                    }
                    return !0
                }), constraint || ("function" == typeof opts.onError ? bbb.addCallback(opts.onError, opts.onError.constraint, errors) : bbb.addCallback(function(e) {
                    throw e = e || new Error("No solver available!"), e.errors = Array.from(arguments), e
                }, null, errors)), bbb.processCallbacks(), constraint
            },
            stay: function(opts, func) {
                func.allowTests = opts.allowTests === !0, func.allowUnsolvableOperations = opts.allowUnsolvableOperations === !0, func.debugging = opts.debugging, func.onError = opts.onError, func.varMapping = opts.ctx;
                var solver = opts.solver || this.defaultSolver,
                    c = new Constraint(func, solver);
                return c.constraintvariables.each(function(cv) {
                    try {
                        cv.externalVariables(solver).stay(opts.priority)
                    } catch (e) {
                        console.log("Warning: could not add stay to " + cv.ivarname)
                    }
                }.bind(this)), !0
            },
            once: function(opts, func) {
                var constraint = this.always(opts, func);
                return constraint.disable(), constraint
            },
            chooseSolvers: function(optSolver) {
                return optSolver ? [optSolver] : this.defaultSolver ? [this.defaultSolver] : this.defaultSolvers.length > 0 ? this.defaultSolvers : []
            },
            addCallback: function(func, context, args) {
                this.callbacks.push({
                    func: func,
                    context: context,
                    args: args || []
                })
            },
            processCallbacks: function() {
                (function() {
                    for (; bbb.callbacks.length > 0;) {
                        var cb = bbb.callbacks.shift();
                        cb.func.apply(cb.context, cb.args)
                    }
                }).recursionGuard(bbb, "isProcessingCallbacks")
            }
        }), Object.extend(Global, {
            bbb: new Babelsberg
        }), users.timfelgentreff.jsinterpreter.Send.addMethods({get args() {
                return this._$args || []
            },
            set args(value) {
                this._$args = value
            }
        }), cop.create("ConstraintConstructionLayer").refineObject(users.timfelgentreff.jsinterpreter, {get InterpreterVisitor() {
                return ConstraintInterpreterVisitor
            }
        }).refineClass(users.timfelgentreff.jsinterpreter.Send, {
            asFunction: function(optFunc) {
                var initializer = optFunc.prototype.initialize.ast().asFunction();
                return initializer.original = optFunc, initializer
            }
        }).refineClass(users.timfelgentreff.jsinterpreter.GetSlot, {
            set: function(value, frame, interpreter) {
                var obj = interpreter.visit(this.obj),
                    name = interpreter.visit(this.slotName);
                return obj === Global || obj instanceof lively.Module ? obj[name] = value : (obj && obj.isConstraintObject && (obj = this.getConstraintObjectValue(obj)), obj[name] = value, cvar = ConstrainedVariable.newConstraintVariableFor(obj, name), Constraint.current && (cvar.ensureExternalVariableFor(Constraint.current.solver), cvar.addToConstraint(Constraint.current), cvar.isSolveable() && Constraint.current.addPrimitiveConstraint(cvar.externalVariable.cnEquals(value))), void 0)
            }
        }), Object.subclass("Constraint", {
            initialize: function(predicate, solver) {
                var constraintObject;
                this._enabled = !1, this._predicate = predicate, "function" == typeof predicate.onError && (this.onError = predicate.onError, this.onError.constraint = this), this.constraintobjects = [], this.constraintvariables = [], this.solver = solver;
                try {
                    Constraint.current = this, constraintObject = cop.withLayers([ConstraintConstructionLayer], function() {
                        return predicate.forInterpretation().apply(void 0, [])
                    })
                } finally {
                    Constraint.current = null
                }
                this.addPrimitiveConstraint(constraintObject)
            },
            addPrimitiveConstraint: function(obj) {
                "undefined" == typeof obj || this.constraintobjects.include(obj) || (obj.enable || this.haltIfDebugging(), this.constraintobjects.push(obj))
            },
            addConstraintVariable: function(v) {
                v && !this.constraintvariables.include(v) && this.constraintvariables.push(v)
            },
            get predicate() {
                return this._predicate
            },
            get allowUnsolvableOperations() {
                return this.haltIfDebugging(), !!this.predicate.allowUnsolvableOperations
            },
            haltIfDebugging: function() {
                this.predicate.debugging
            },
            get allowTests() {
                return this.haltIfDebugging(), !!this.predicate.allowTests
            },
            get priority() {
                return this._priority
            },
            set priority(value) {
                var enabled = this._enabled;
                enabled && this.disable(), this._priority = value, enabled && this.enable()
            },
            get value() {
                return this.constraintobjects.last()
            },
            enable: function() {
                if (!this._enabled) {
                    if (Constraint.enabledConstraintsGuard.tick(), this.constraintobjects.each(function(ea) {
                            this.enableConstraintObject(ea)
                        }.bind(this)), 0 === this.constraintobjects.length) throw new Error("BUG: No constraintobjects were created.");
                    this._enabled = !0, this.solver.solve(), this.constraintvariables.each(function(ea) {
                        var value = ea.getValue();
                        value != this.storedValue && (ea.updateDownstreamExternalVariables(value), ea.solveForConnectedVariables(value))
                    })
                }
            },
            enableConstraintObject: function(obj, optPriority) {
                if (obj === !0) {
                    if (!this.allowTests) throw new Error("Constraint expression returned true, but was not marked as test. If you expected this to be solveable, check that there are no operations in this that cannot be solved by the selected solver (e.g. Cassowary does not support `<', only `<='). Otherwise, if you think this is ok, you must pass `allowTests: true' as option to the constraint.");
                    this.isTest = !0
                } else if (obj === !1) {
                    if (!this.allowFailing) throw new Error("Constraint expression returned false, no solver available to fix it")
                } else {
                    if (!obj.enable) {
                        var e = new Error("Constraint expression returned an object that does not respond to #enable");
                        throw e.obj = obj, e.constraint = this, e
                    }
                    obj.solver = this.solver, obj.enable(optPriority || this._priority)
                }
            },
            disable: function() {
                this._enabled && (Constraint.enabledConstraintsGuard.tick(), this.constraintobjects.each(function(ea) {
                    try {
                        ea.disable()
                    } catch (e) {}
                }), this._enabled = !1)
            },
            recalculate: function() {
                if (this._enabled) {
                    this.isTest && !this.solver;
                    var assignments, enabled = this._enabled,
                        cvars = this.constraintvariables,
                        self = this;
                    if (enabled && this.disable(), this.initialize(this.predicate, this.solver), cvars.select(function(ea) {
                            return !this.constraintvariables.include(ea) && ea.isSolveable()
                        }.bind(this)).each(function(ea) {
                            return ea.externalVariable.removeStay()
                        }), enabled) {
                        assignments = this.constraintvariables.select(function(ea) {
                            return !cvars.include(ea) && ea.isSolveable()
                        }).collect(function(ea) {
                            return ea.externalVariable.cnIdentical(ea.getValue())
                        }), assignments.each(function(ea) {
                            try {
                                self.enableConstraintObject(ea)
                            } catch (_) {
                                self.enableConstraintObject(ea, self.solver.strength.strong)
                            }
                        });
                        try {
                            this.enable()
                        } catch (_) {
                            this._enabled = !0, this.disable(), assignments.invoke("disable"), assignments.invoke("enable", this.solver.strength && this.solver.strength.strong), this.enable()
                        } finally {
                            assignments.invoke("disable")
                        }
                    }
                }
            }
        }), Object.extend(Constraint, {set current(p) {
                return this._previous || (this._previous = []), null === p ? (this._current = this._previous.length > 0 ? this._previous.pop() : null, void 0) : (this._current && this._previous.push(this._current), this._current = p, void 0)
            },
            get current() {
                return this._current
            },
            enabledConstraintsGuard: new Guard
        }), Object.subclass("ConstrainedVariable", {
            initialize: function(obj, ivarname, optParentCVar) {
                this.__uuid__ = Strings.newUUID(), this.obj = obj, this.ivarname = ivarname, this.newIvarname = "$1$1" + ivarname, this.parentConstrainedVariable = optParentCVar, this._constraints = [], this._externalVariables = {}, this._isSolveable = !1, this._definingSolver = null;
                var solver = (obj[ivarname], this.currentSolver);
                dbgOn(!solver), this.ensureExternalVariableFor(solver), this.wrapProperties(obj, solver)
            },
            wrapProperties: function(obj, solver) {
                var existingSetter = obj.__lookupSetter__(this.ivarname),
                    existingGetter = obj.__lookupGetter__(this.ivarname);
                existingGetter && !existingGetter.isConstraintAccessor && obj.__defineGetter__(this.newIvarname, existingGetter), existingSetter && !existingSetter.isConstraintAccessor && obj.__defineSetter__(this.newIvarname, existingSetter), existingGetter || existingSetter || !this.obj.hasOwnProperty(this.ivarname) || this.setValue(obj[this.ivarname]);
                try {
                    obj.__defineGetter__(this.ivarname, function() {
                        return this.getValue()
                    }.bind(this))
                } catch (e) {}
                var newGetter = obj.__lookupGetter__(this.ivarname);
                if (!newGetter) return this.externalVariables(solver, null), void 0;
                obj.__defineSetter__(this.ivarname, function(newValue) {
                    return this.suggestValue(newValue, "source")
                }.bind(this));
                var newSetter = obj.__lookupSetter__(this.ivarname);
                newSetter && (newSetter.isConstraintAccessor = !0), newGetter && (newGetter.isConstraintAccessor = !0)
            },
            ensureExternalVariableFor: function(solver) {
                var eVar = this.externalVariables(solver),
                    value = this.obj[this.ivarname];
                eVar || null === eVar || this.externalVariables(solver, solver.constraintVariableFor(value, this.ivarname, this))
            },
            get currentSolver() {
                return Constraint.current ? Constraint.current.solver : null
            },
            suggestValue: function(value, source, force) {
                if (ConstrainedVariable.$$callingSetters) return value;
                if (force || value !== this.storedValue) {
                    var callSetters = !ConstrainedVariable.$$optionalSetters,
                        oldValue = this.storedValue,
                        solver = this.definingSolver;
                    ConstrainedVariable.$$optionalSetters = ConstrainedVariable.$$optionalSetters || [];
                    try {
                        this.solveForPrimarySolver(value, oldValue, solver, source, force), this.solveForConnectedVariables(value, oldValue, solver, source, force), this.findAndOptionallyCallSetters(callSetters)
                    } catch (e) {
                        if (this.getValue() !== oldValue) throw "solving failed, but variable changed to " + this.getValue() + " from " + oldValue;
                        this.addErrorCallback(e)
                    } finally {
                        this.ensureClearSetters(callSetters), solver && source && this.bumpSolverWeight(solver, "down")
                    }
                    bbb.processCallbacks()
                }
                return value
            },
            solveForPrimarySolver: function(value, priorValue, solver, source) {
                this.isSolveable() && function() {
                    var wasReadonly = !1,
                        eVar = this.definingExternalVariable;
                    try {
                        solver && source && this.bumpSolverWeight(solver, "up"), wasReadonly = eVar.isReadonly(), eVar.setReadonly(!1), eVar.suggestValue(value)
                    } finally {
                        eVar.setReadonly(wasReadonly)
                    }
                }.bind(this).recursionGuard(ConstrainedVariable.isSuggestingValue, this.__uuid__)
            },
            bumpSolverWeight: function(solver, direction) {
                "up" == direction ? solver.weight += 987654321 : solver.weight -= 987654321, this.findTransitiveConnectedVariables().each(function(cvar) {
                    cvar.setDownstreamReadonly("up" == direction)
                })
            },
            solveForConnectedVariables: function(value, priorValue, solver, source, force) {
                (force || value !== this.storedValue) && function() {
                    try {
                        this.updateDownstreamVariables(value, solver), this.updateConnectedVariables(value, solver)
                    } catch (e) {
                        throw source && (this.$$isStoring = !1, this.suggestValue(priorValue, source, "force")), e
                    }
                }.bind(this).recursionGuard(this, "$$isStoring")
            },
            findAndOptionallyCallSetters: function(callSetters) {
                if (this.isSolveable()) {
                    var getterSetterPair = this.findOptionalSetter();
                    getterSetterPair && ConstrainedVariable.$$optionalSetters.push(getterSetterPair)
                }
                callSetters && this.callSetters.recursionGuard(ConstrainedVariable, "$$callingSetters")
            },
            addErrorCallback: function(e) {
                var catchingConstraint = this._constraints.find(function(constraint) {
                    return "function" == typeof constraint.onError
                });
                if (!catchingConstraint) throw e;
                bbb.addCallback(catchingConstraint.onError, catchingConstraint, [e])
            },
            callSetters: function() {
                var recvs = [],
                    setters = [];
                ConstrainedVariable.$$optionalSetters.each(function(ea) {
                    var recvIdx = recvs.indexOf(ea.recv);
                    if (-1 === recvIdx && (recvIdx = recvs.length, recvs.push(ea.recv)), setters[recvIdx] = setters[recvIdx] || [], -1 === setters[recvIdx].indexOf(ea.setter)) {
                        setters[recvIdx].push(ea.setter);
                        try {
                            ea.recv[ea.setter](ea.recv[ea.getter]())
                        } catch (e) {
                            alert(e)
                        }
                    }
                })
            },
            findOptionalSetter: function() {
                return this.setterObj ? this.setterObj : (this.setter ? this.setterObj = {
                    recv: this.recv,
                    getter: this.getter,
                    setter: this.setter
                } : this.parentConstrainedVariable && (this.setterObj = this.parentConstrainedVariable.findOptionalSetter()), this.setterObj)
            },
            ensureClearSetters: function(callSetters) {
                callSetters && (ConstrainedVariable.$$optionalSetters = null)
            },
            get getter() {
                return this.$getter
            },
            get recv() {
                return this.$recv
            },
            set getter(value) {
                if (this.$getter = value, this.recv) {
                    var setter = value.replace("get", "set");
                    Object.isFunction(this.recv[setter]) && (this.setter = setter)
                }
            },
            set recv(value) {
                if (this.$recv = value, this.getter) {
                    var setter = this.getter.replace("get", "set");
                    Object.isFunction(value[setter]) && (this.setter = setter)
                }
            },
            setDownstreamReadonly: function(bool) {
                if (bool && !this.$$downstreamReadonlyVars) {
                    var defVar = this.definingExternalVariable;
                    this.$$downstreamReadonlyVars = [], this.eachExternalVariableDo(function(eVar) {
                        eVar !== defVar && (eVar.isReadonly() || (eVar.setReadonly(!0), this.$$downstreamReadonlyVars.push(eVar)))
                    }.bind(this))
                } else !bool && this.$$downstreamReadonlyVars && (this.$$downstreamReadonlyVars.each(function(eVar) {
                    eVar.setReadonly(!1)
                }.bind(this)), this.$$downstreamReadonlyVars = null)
            },
            findTransitiveConnectedVariables: function(ary) {
                return Constraint.enabledConstraintsGuard.call(this.__uuid__, function() {
                    return this._findTransitiveConnectedVariables(ary || [])
                }.bind(this))
            },
            _findTransitiveConnectedVariables: function(ary) {
                return -1 === ary.indexOf(this) ? (ary.push(this), this._constraints.each(function(c) {
                    return c.constraintvariables.each(function(cvar) {
                        cvar.findTransitiveConnectedVariables(ary)
                    })
                }), ary) : void 0
            },
            updateConnectedVariables: function() {
                this._constraints.collect(function(c) {
                    return c.constraintvariables
                }).flatten().uniq().each(function(cvar) {
                    cvar.suggestValue(cvar.getValue())
                })
            },
            updateDownstreamVariables: function(value) {
                this.updateDownstreamExternalVariables(value), this.updateDownstreamUnsolvableVariables(value)
            },
            updateDownstreamExternalVariables: function(value) {
                var defVar = this.definingExternalVariable;
                this.eachExternalVariableDo(function(ea) {
                    if (ea !== defVar) {
                        var wasReadonly = ea.isReadonly();
                        ea.setReadonly(!1), ea.suggestValue(value), ea.setReadonly(wasReadonly)
                    }
                })
            },
            updateDownstreamUnsolvableVariables: function(value) {
                this.isValueClass() ? this.updateValueClassParts(value) : this.recalculateDownstreamConstraints(value)
            },
            recalculateDownstreamConstraints: function(value) {
                this.setValue(value), this._constraints.each(function(c) {
                    var eVar = this.externalVariables(c.solver);
                    eVar || c.recalculate()
                }.bind(this))
            },
            updateValueClassParts: function(value) {
                (function() {
                    for (key in this.storedValue[ConstrainedVariable.AttrName]) {
                        var cvar = this.storedValue[ConstrainedVariable.AttrName][key];
                        cvar.suggestValue(value[key])
                    }
                }).bind(this).recursionGuard(this, "$$valueClassUpdate")
            },
            addToConstraint: function(constraint) {
                this._constraints.include(constraint) || this._constraints.push(constraint), constraint.addConstraintVariable(this)
            },
            get definingSolver() {
                return Constraint.current || this._hasMultipleSolvers ? (this._definingSolver = null, this._searchDefiningSolver()) : this._definingSolver ? this._definingSolver : this._definingSolver = this._searchDefiningSolver()
            },
            _searchDefiningSolver: function() {
                var solver = {
                    weight: -1e3,
                    fake: !0
                };
                return this.eachExternalVariableDo(function(eVar) {
                    if (eVar) {
                        solver.fake || (this._hasMultipleSolvers = !0);
                        var s = eVar.__solver__;
                        s.weight > solver.weight && (solver = s)
                    }
                }.bind(this)), solver
            },
            get solvers() {
                var solvers = [];
                return this.eachExternalVariableDo(function(eVar) {
                    if (eVar) {
                        var s = eVar.__solver__;
                        solvers.push(s)
                    }
                }), solvers.uniq()
            },
            get definingExternalVariable() {
                return this.externalVariables(this.definingSolver)
            },
            isSolveable: function() {
                return Constraint.current ? !!this.externalVariable : this._isSolveable
            },
            _resetIsSolveable: function() {
                this._isSolveable = !!this.definingExternalVariable
            },
            isValueClass: function() {
                return !this.isSolveable() && this.storedValue instanceof lively.Point
            },
            get storedValue() {
                return this.obj[this.newIvarname]
            },
            get externalValue() {
                return this.pvtGetExternalValue(this.externalVariable)
            },
            pvtGetExternalValue: function(evar) {
                return "function" == typeof evar.value ? evar.value() : evar.value
            },
            setValue: function(value) {
                this.obj[this.newIvarname] = value
            },
            eachExternalVariableDo: function(func) {
                func.bind(this);
                for (var key in this._externalVariables) {
                    var eVar = this._externalVariables[key];
                    eVar && func(eVar)
                }
            },
            getValue: function() {
                return this.isSolveable() ? this.externalValue : this.storedValue
            },
            get externalVariable() {
                return this.currentSolver ? this.externalVariables(this.currentSolver) : this.definingExternalVariable
            },
            externalVariables: function(solver, value) {
                if (solver.__uuid__ || (solver.__uuid__ = Strings.newUUID()), 1 === arguments.length) return this._externalVariables[solver.__uuid__];
                if (value) {
                    if (value.__solver__ = value.__solver__ || solver, value.__cvar__ && value.__cvar__ !== this) throw "Inconsistent external variable. This should not happen!";
                    value.__cvar__ = this
                }
                this._externalVariables[solver.__uuid__] = value || null, this._resetIsSolveable()
            }
        }), users.timfelgentreff.jsinterpreter.InterpreterVisitor.subclass("ConstraintInterpreterVisitor", {
            binaryExpressionMap: {
                "+": ["plus", "plus"],
                "-": ["minus"],
                "*": ["times", "times"],
                "/": ["divide"],
                "%": ["modulo"],
                "==": ["cnEquals", "cnEquals"],
                "===": ["cnIdentical", "cnIdentical"],
                "<=": ["cnLeq", "cnGeq"],
                ">=": ["cnGeq", "cnLeq"],
                "<": ["cnLess", "cnGreater"],
                ">": ["cnGreater", "cnLess"],
                "||": ["cnOr", "cnOr"],
                "!=": ["cnNeq", "cnNeq"],
                "!==": ["cnNotIdentical", "cnNotIdentical"]
            },
            alternativeExpressionsMapTo: {
                "+": "-",
                "<=": "<",
                ">=": ">",
                "==": "==="
            },
            get alternativeExpressionsMap() {
                var map = {};
                return Properties.own(this.alternativeExpressionsMapTo).each(function(ea) {
                    map[this.alternativeExpressionsMapTo[ea]] = ea, map[ea] = this.alternativeExpressionsMapTo[ea]
                }.bind(this)), map
            },
            getConstraintObjectValue: function(o) {
                if (void 0 === o || !o.isConstraintObject) return o;
                var value = o.value;
                return "function" == typeof value ? value.apply(o) : value
            },
            errorIfUnsolvable: function(op, l, r, res) {
                if ("undefined" == typeof res && (res = r, r = void 0), !(l.isConstraintObject || r && r.isConstraintObject) || Constraint.current.allowUnsolvableOperations) return "function" == typeof res ? res() : res;
                var alternative, msg = "`" + op + "' not allowed on " + l;
                if (void 0 !== r) {
                    msg = "Binary op " + msg + " and " + r;
                    var altOp = this.alternativeExpressionsMap[op];
                    altOp && (l[this.binaryExpressionMap[altOp][0]] || r[this.binaryExpressionMap[altOp][1]]) && (alternative = altOp)
                }
                throw !alternative && Constraint.current.solver.alternativeOperationFor && (alternative = Constraint.current.solver.alternativeOperationFor(op)), msg += ". If you want to allow this, pass `allowUnsolvableOperations'to the constraint.", alternative && (msg += " You can also rewrite the code to use " + alternative + " instead."), new Error(msg)
            },
            visitVariable: function($super, node) {
                return $super(node)
            },
            visitCond: function($super, node) {
                var condVal = (this.currentFrame, this.visit(node.condExpr));
                if (condVal && condVal.isConstraintObject) {
                    var self = this;
                    condVal = this.getConstraintObjectValue(condVal), condVal || (condVal = cop.withoutLayers([ConstraintConstructionLayer], function() {
                        return self.visit(node.condExpr)
                    }))
                }
                return condVal ? this.visit(node.trueExpr) : this.visit(node.falseExpr)
            },
            visitUnaryOp: function($super, node) {
                var val = (this.currentFrame, this.visit(node.expr)),
                    rVal = this.getConstraintObjectValue(val),
                    msg = "Unary op `" + node.name + "'";
                switch (node.name) {
                    case "-":
                        return val && val.isConstraintObject && val.times ? val.times(-1) : this.errorIfUnsolvable(msg, val, -rVal);
                    case "!":
                        return val && val.isConstraintObject && val.not ? val.not() : !val;
                    case "~":
                        return this.errorIfUnsolvable(msg, val, ~rVal);
                    case "typeof":
                        return this.errorIfUnsolvable(msg, val, typeof rVal);
                    default:
                        throw new Error("No semantics for unary op " + node.name)
                }
            },
            invoke: function($super, node, recv, func, argValues) {
                if (!(func || recv && recv.isConstraintObject)) {
                    var error = "No such method: " + recv + "." + (node.property && node.property.value);
                    throw alert(error), new Error(error)
                }
                if (!recv || !recv.isConstraintObject) return func === Date ? new func : recv === Math ? func === Math.sqrt && argValues[0].pow || argValues[0].sqrt ? argValues[0].pow ? this.invoke(node, argValues[0], argValues[0].pow, [.5]) : this.invoke(node, argValues[0], argValues[0].sqrt, []) : func === Math.pow && argValues[0].pow ? this.invoke(node, argValues[0], argValues[0].pow, [argValues[1]]) : func === Math.sin && argValues[0].sin ? this.invoke(node, argValues[0], argValues[0].sin, []) : func === Math.cos && argValues[0].cos ? this.invoke(node, argValues[0], argValues[0].cos, []) : $super(node, recv, func, argValues.map(this.getConstraintObjectValue)) : cop.withLayers([ConstraintConstructionLayer], function() {
                    return $super(node, recv, func, argValues)
                });
                if (!func) return this.errorIfUnsolvable(node.property && node.property.value, recv, function() {
                    var value = this.getConstraintObjectValue(recv),
                        prop = this.visit(node.property);
                    return this.invoke(node, value, value[prop], argValues)
                }.bind(this));
                var forInterpretation = func.forInterpretation;
                func.forInterpretation = void 0;
                var prevNode = bbb.currentNode,
                    prevInterp = bbb.currentInterpreter;
                bbb.currentInterpreter = this, bbb.currentNode = node;
                try {
                    return cop.withoutLayers([ConstraintConstructionLayer], function() {
                        return $super(node, recv, func, argValues)
                    })
                } catch (e) {
                    return this.errorIfUnsolvable(node.property && node.property.value, recv, function() {
                        var value = this.getConstraintObjectValue(recv),
                            prop = this.visit(node.property);
                        return this.invoke(node, value, value[prop], argValues)
                    }.bind(this))
                } finally {
                    func.forInterpretation = forInterpretation, bbb.currentInterpreter = prevInterp, bbb.currentNode = prevNode
                }
            },
            visitBinaryOp: function($super, node) {
                var prevNode = bbb.currentNode,
                    prevInterp = bbb.currentInterpreter;
                bbb.currentInterpreter = this, bbb.currentNode = node;
                try {
                    return this.pvtVisitBinaryOp($super, node)
                } finally {
                    bbb.currentInterpreter = prevInterp, bbb.currentNode = prevNode
                }
            },
            pvtVisitBinaryOp: function(mySuper, node) {
                var op = node.name,
                    leftVal = this.visit(node.left),
                    rightVal = this.visit(node.right);
                void 0 === leftVal && (leftVal = 0), void 0 === rightVal && (rightVal = 0);
                var rLeftVal = leftVal && leftVal.isConstraintObject ? this.getConstraintObjectValue(leftVal) : leftVal,
                    rRightVal = rightVal && rightVal.isConstraintObject ? this.getConstraintObjectValue(rightVal) : rightVal;
                switch (node.name) {
                    case "&&":
                        if (!leftVal) return leftVal;
                        if (leftVal === !0 || leftVal.isConstraintObject) {
                            if ("function" == typeof leftVal.cnAnd) return leftVal.cnAnd(rightVal);
                            Constraint.current.addPrimitiveConstraint(leftVal)
                        } else Constraint.current.haltIfDebugging();
                        return rightVal;
                    case "-":
                        if (rightVal.isConstraintObject && rightVal.plus && Object.isNumber(leftVal)) return rightVal.plus(-leftVal);
                    case "in":
                        if ("-" != node.name) {
                            if (leftVal.isConstraintObject && leftVal.cnIn) return leftVal.cnIn(rightVal);
                            if (this.$finiteDomainProperty) {
                                var lV = this.$finiteDomainProperty;
                                if (delete this.$finiteDomainProperty, lV.cnIn) return lV.cnIn(rightVal)
                            }
                        }
                    default:
                        var method = this.binaryExpressionMap[node.name];
                        return method ? leftVal && leftVal.isConstraintObject && "function" == typeof leftVal[method[0]] ? leftVal[method[0]](rightVal) : rightVal && rightVal.isConstraintObject && "function" == typeof rightVal[method[1]] ? rightVal[method[1]](leftVal) : this.errorIfUnsolvable(op, leftVal, rightVal, eval("rLeftVal " + node.name + " rRightVal")) : this.errorIfUnsolvable(op, leftVal, rightVal, mySuper(node))
                }
            },
            visitGetSlot: function($super, node) {
                if (-1 === cop.currentLayers().indexOf(ConstraintConstructionLayer)) return $super(node);
                var cvar, obj = this.visit(node.obj),
                    name = this.visit(node.slotName),
                    cobj = obj ? obj[ConstrainedVariable.ThisAttrName] : void 0;
                if (obj === Global || obj instanceof lively.Module) return obj[name];
                if (name && name.isConstraintObject && (name = this.getConstraintObjectValue(name)), obj && obj.isConstraintObject) {
                    if (obj["cn" + name]) return obj["cn" + name];
                    "is" === name ? this.$finiteDomainProperty = obj : (cobj = obj.__cvar__, obj = this.getConstraintObjectValue(obj))
                }
                if (cvar = ConstrainedVariable.newConstraintVariableFor(obj, name, cobj), Constraint.current && (cvar.ensureExternalVariableFor(Constraint.current.solver), cvar.addToConstraint(Constraint.current)), cvar && cvar.isSolveable()) return cvar.externalVariable;
                var retval = obj[name];
                if (!retval || !retval.isConstraintObject) {
                    var objStr = Strings.safeToString(obj),
                        retStr = Strings.safeToString(retval);
                    console.log(Constraint.current.solver.constructor.name + " cannot reason about the variable " + objStr + "[" + name + "], a " + retStr + " of type " + ("object" == typeof retval ? retval.constructor.name : typeof retval)), Constraint.current.haltIfDebugging()
                }
                if (retval) switch (typeof retval) {
                    case "object":
                    case "function":
                        retval[ConstrainedVariable.ThisAttrName] = cvar;
                        break;
                    case "number":
                        new Number(retval)[ConstrainedVariable.ThisAttrName] = cvar;
                        break;
                    case "string":
                        new String(retval)[ConstrainedVariable.ThisAttrName] = cvar;
                        break;
                    case "boolean":
                        break;
                    default:
                        throw "Error - we cannot store the constrained var attribute on " + retval + " of type " + typeof retval
                }
                return retval
            },
            visitReturn: function($super, node) {
                var retVal = $super(node);
                if (retVal) {
                    var cvar = retVal[ConstrainedVariable.ThisAttrName];
                    if (retVal.isConstraintObject && (cvar = retVal.__cvar__), cvar) {
                        var parentFunc = node.parentFunction();
                        parentFunc && (cvar.getter = parentFunc.name(), cvar.recv = this.currentFrame.mapping["this"])
                    }
                }
                return retVal
            },
            shouldInterpret: function(frame, func) {
                if (func.sourceModule === Global.users.timfelgentreff.babelsberg.constraintinterpreter) return !1;
                if ("Babelsberg" === func.declaredClass) return !1;
                var nativeClass = lively.Class.isClass(func) && void 0 === func.superclass;
                return !(this.isNative(func) || nativeClass) && "function" == typeof func.forInterpretation
            },
            getCurrentScope: function() {
                for (var scope = {}, frame = this.currentFrame; frame;) {
                    if (frame.mapping === Global) return scope;
                    for (var key in frame.mapping) scope[key] = frame.mapping[key];
                    var mapping = frame.func.getVarMapping();
                    if (mapping)
                        for (var key in mapping) scope[key] = mapping[key];
                    frame = frame.getContainingScope()
                }
                return scope
            },
            newObject: function($super, func) {
                return func.original ? $super(func.original) : $super(func)
            }
        }), ConstrainedVariable.AttrName = "__constrainedVariables__", ConstrainedVariable.ThisAttrName = "__lastConstrainedVariableForThis__", Object.extend(ConstrainedVariable, {
            findConstraintVariableFor: function(obj, ivarname) {
                var l = obj[ConstrainedVariable.AttrName];
                return l && l[ivarname] ? l[ivarname] : null
            },
            newConstraintVariableFor: function(obj, ivarname, cobj) {
                var cvar = this.findConstraintVariableFor(obj, ivarname);
                return cvar || (cvar = new ConstrainedVariable(obj, ivarname, cobj), obj[ConstrainedVariable.AttrName] = obj[ConstrainedVariable.AttrName] || {}, obj[ConstrainedVariable.AttrName][ivarname] = cvar), cvar
            },
            deleteConstraintVariableFor: function(obj, ivarname) {
                var l = obj[ConstrainedVariable.AttrName];
                l && l[ivarname] && delete l[ivarname]
            },
            isSuggestingValue: {}
        }), Object.subclass("PrimitiveCObjectRegistry", {}), Object.extend(PrimitiveCObjectRegistry, {
            registry: {},
            set: function(obj, cobj) {
                PrimitiveCObjectRegistry.registry[obj] = cobj
            },
            get: function(obj) {
                return PrimitiveCObjectRegistry.registry[obj]
            }
        }), Number.prototype.__defineGetter__(ConstrainedVariable.ThisAttrName, function() {
            return PrimitiveCObjectRegistry.get(this + 0)
        }), Number.prototype.__defineGetter__(ConstrainedVariable.AttrName, function() {
            return {}
        }), Number.prototype.__defineSetter__(ConstrainedVariable.ThisAttrName, function(v) {
            PrimitiveCObjectRegistry.set(this + 0, v)
        }), String.prototype.__defineGetter__(ConstrainedVariable.ThisAttrName, function() {
            return PrimitiveCObjectRegistry.get(this + "")
        }), String.prototype.__defineGetter__(ConstrainedVariable.AttrName, function() {
            return {}
        }), String.prototype.__defineSetter__(ConstrainedVariable.ThisAttrName, function(v) {
            PrimitiveCObjectRegistry.set(this + "", v)
        })
    }),
    function(exports, global) {
        function array_to_hash(a) {
            for (var ret = Object.create(null), i = 0; i < a.length; ++i) ret[a[i]] = !0;
            return ret
        }

        function slice(a, start) {
            return Array.prototype.slice.call(a, start || 0)
        }

        function characters(str) {
            return str.split("")
        }

        function member(name, array) {
            for (var i = array.length; --i >= 0;)
                if (array[i] == name) return !0;
            return !1
        }

        function find_if(func, array) {
            for (var i = 0, n = array.length; n > i; ++i)
                if (func(array[i])) return array[i]
        }

        function repeat_string(str, i) {
            if (0 >= i) return "";
            if (1 == i) return str;
            var d = repeat_string(str, i >> 1);
            return d += d, 1 & i && (d += str), d
        }

        function DefaultsError(msg, defs) {
            this.msg = msg, this.defs = defs
        }

        function defaults(args, defs, croak) {
            args === !0 && (args = {});
            var ret = args || {};
            if (croak)
                for (var i in ret)
                    if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i)) throw new DefaultsError("`" + i + "` is not a supported option", defs);
            for (var i in defs) defs.hasOwnProperty(i) && (ret[i] = args && args.hasOwnProperty(i) ? args[i] : defs[i]);
            return ret
        }

        function merge(obj, ext) {
            for (var i in ext) ext.hasOwnProperty(i) && (obj[i] = ext[i]);
            return obj
        }

        function noop() {}

        function push_uniq(array, el) {
            array.indexOf(el) < 0 && array.push(el)
        }

        function string_template(text, props) {
            return text.replace(/\{(.+?)\}/g, function(str, p) {
                return props[p]
            })
        }

        function remove(array, el) {
            for (var i = array.length; --i >= 0;) array[i] === el && array.splice(i, 1)
        }

        function mergeSort(array, cmp) {
            function merge(a, b) {
                for (var r = [], ai = 0, bi = 0, i = 0; ai < a.length && bi < b.length;) r[i++] = cmp(a[ai], b[bi]) <= 0 ? a[ai++] : b[bi++];
                return ai < a.length && r.push.apply(r, a.slice(ai)), bi < b.length && r.push.apply(r, b.slice(bi)), r
            }

            function _ms(a) {
                if (a.length <= 1) return a;
                var m = Math.floor(a.length / 2),
                    left = a.slice(0, m),
                    right = a.slice(m);
                return left = _ms(left), right = _ms(right), merge(left, right)
            }
            return array.length < 2 ? array.slice() : _ms(array)
        }

        function set_difference(a, b) {
            return a.filter(function(el) {
                return b.indexOf(el) < 0
            })
        }

        function set_intersection(a, b) {
            return a.filter(function(el) {
                return b.indexOf(el) >= 0
            })
        }

        function makePredicate(words) {
            function compareTo(arr) {
                if (1 == arr.length) return f += "return str === " + JSON.stringify(arr[0]) + ";";
                f += "switch(str){";
                for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
                f += "return true}return false;"
            }
            words instanceof Array || (words = words.split(" "));
            var f = "",
                cats = [];
            out: for (var i = 0; i < words.length; ++i) {
                for (var j = 0; j < cats.length; ++j)
                    if (cats[j][0].length == words[i].length) {
                        cats[j].push(words[i]);
                        continue out
                    }
                cats.push([words[i]])
            }
            if (cats.length > 3) {
                cats.sort(function(a, b) {
                    return b.length - a.length
                }), f += "switch(str.length){";
                for (var i = 0; i < cats.length; ++i) {
                    var cat = cats[i];
                    f += "case " + cat[0].length + ":", compareTo(cat)
                }
                f += "}"
            } else compareTo(words);
            return new Function("str", f)
        }

        function all(array, predicate) {
            for (var i = array.length; --i >= 0;)
                if (!predicate(array[i])) return !1;
            return !0
        }

        function Dictionary() {
            this._values = Object.create(null), this._size = 0
        }

        function DEFNODE(type, props, methods, base) {
            arguments.length < 4 && (base = AST_Node), props = props ? props.split(/\s+/) : [];
            var self_props = props;
            base && base.PROPS && (props = props.concat(base.PROPS));
            for (var code = "return function AST_" + type + "(props){ if (props) { ", i = props.length; --i >= 0;) code += "this." + props[i] + " = props." + props[i] + ";";
            var proto = base && new base;
            (proto && proto.initialize || methods && methods.initialize) && (code += "this.initialize();"), code += "}}";
            var ctor = new Function(code)();
            if (proto && (ctor.prototype = proto, ctor.BASE = base), base && base.SUBCLASSES.push(ctor), ctor.prototype.CTOR = ctor, ctor.PROPS = props || null, ctor.SELF_PROPS = self_props, ctor.SUBCLASSES = [], type && (ctor.prototype.TYPE = ctor.TYPE = type), methods)
                for (i in methods) methods.hasOwnProperty(i) && (/^\$/.test(i) ? ctor[i.substr(1)] = methods[i] : ctor.prototype[i] = methods[i]);
            return ctor.DEFMETHOD = function(name, method) {
                this.prototype[name] = method
            }, ctor
        }

        function walk_body(node, visitor) {
            node.body instanceof AST_Statement ? node.body._walk(visitor) : node.body.forEach(function(stat) {
                stat._walk(visitor)
            })
        }

        function TreeWalker(callback) {
            this.visit = callback, this.stack = []
        }

        function is_letter(code) {
            return code >= 97 && 122 >= code || code >= 65 && 90 >= code || code >= 170 && UNICODE.letter.test(String.fromCharCode(code))
        }

        function is_digit(code) {
            return code >= 48 && 57 >= code
        }

        function is_alphanumeric_char(code) {
            return is_digit(code) || is_letter(code)
        }

        function is_unicode_combining_mark(ch) {
            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch)
        }

        function is_unicode_connector_punctuation(ch) {
            return UNICODE.connector_punctuation.test(ch)
        }

        function is_identifier(name) {
            return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name)
        }

        function is_identifier_start(code) {
            return 36 == code || 95 == code || is_letter(code)
        }

        function is_identifier_char(ch) {
            var code = ch.charCodeAt(0);
            return is_identifier_start(code) || is_digit(code) || 8204 == code || 8205 == code || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch)
        }

        function is_identifier_string(str) {
            var i = str.length;
            if (0 == i) return !1;
            if (!is_identifier_start(str.charCodeAt(0))) return !1;
            for (; --i >= 0;)
                if (!is_identifier_char(str.charAt(i))) return !1;
            return !0
        }

        function parse_js_number(num) {
            return RE_HEX_NUMBER.test(num) ? parseInt(num.substr(2), 16) : RE_OCT_NUMBER.test(num) ? parseInt(num.substr(1), 8) : RE_DEC_NUMBER.test(num) ? parseFloat(num) : void 0
        }

        function JS_Parse_Error(message, line, col, pos) {
            this.message = message, this.line = line, this.col = col, this.pos = pos, this.stack = (new Error).stack
        }

        function js_error(message, filename, line, col, pos) {
            throw new JS_Parse_Error(message, line, col, pos)
        }

        function is_token(token, type, val) {
            return token.type == type && (null == val || token.value == val)
        }

        function tokenizer($TEXT, filename, html5_comments) {
            function peek() {
                return S.text.charAt(S.pos)
            }

            function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos++);
                if (signal_eof && !ch) throw EX_EOF;
                return "\n" == ch ? (S.newline_before = S.newline_before || !in_string, ++S.line, S.col = 0) : ++S.col, ch
            }

            function forward(i) {
                for (; i-- > 0;) next()
            }

            function looking_at(str) {
                return S.text.substr(S.pos, str.length) == str
            }

            function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && -1 == pos) throw EX_EOF;
                return pos
            }

            function start_token() {
                S.tokline = S.line, S.tokcol = S.col, S.tokpos = S.pos
            }

            function token(type, value, is_comment) {
                S.regex_allowed = "operator" == type && !UNARY_POSTFIX(value) || "keyword" == type && KEYWORDS_BEFORE_EXPRESSION(value) || "punc" == type && PUNC_BEFORE_EXPRESSION(value), prev_was_dot = "punc" == type && "." == value;
                var ret = {
                    type: type,
                    value: value,
                    line: S.tokline,
                    col: S.tokcol,
                    pos: S.tokpos,
                    endpos: S.pos,
                    nlb: S.newline_before,
                    file: filename
                };
                if (!is_comment) {
                    ret.comments_before = S.comments_before, S.comments_before = [];
                    for (var i = 0, len = ret.comments_before.length; len > i; i++) ret.nlb = ret.nlb || ret.comments_before[i].nlb
                }
                return S.newline_before = !1, new AST_Token(ret)
            }

            function skip_whitespace() {
                for (; WHITESPACE_CHARS(peek());) next()
            }

            function read_while(pred) {
                for (var ch, ret = "", i = 0;
                    (ch = peek()) && pred(ch, i++);) ret += next();
                return ret
            }

            function parse_error(err) {
                js_error(err, filename, S.tokline, S.tokcol, S.tokpos)
            }

            function read_num(prefix) {
                var has_e = !1,
                    after_e = !1,
                    has_x = !1,
                    has_dot = "." == prefix,
                    num = read_while(function(ch, i) {
                        var code = ch.charCodeAt(0);
                        switch (code) {
                            case 120:
                            case 88:
                                return has_x ? !1 : has_x = !0;
                            case 101:
                            case 69:
                                return has_x ? !0 : has_e ? !1 : has_e = after_e = !0;
                            case 45:
                                return after_e || 0 == i && !prefix;
                            case 43:
                                return after_e;
                            case after_e = !1, 46:
                                return has_dot || has_x || has_e ? !1 : has_dot = !0
                        }
                        return is_alphanumeric_char(code)
                    });
                prefix && (num = prefix + num);
                var valid = parse_js_number(num);
                return isNaN(valid) ? (parse_error("Invalid syntax: " + num), void 0) : token("num", valid)
            }

            function read_escaped_char(in_string) {
                var ch = next(!0, in_string);
                switch (ch.charCodeAt(0)) {
                    case 110:
                        return "\n";
                    case 114:
                        return "\r";
                    case 116:
                        return "  ";
                    case 98:
                        return "\b";
                    case 118:
                        return "";
                    case 102:
                        return "\f";
                    case 48:
                        return "\x00";
                    case 120:
                        return String.fromCharCode(hex_bytes(2));
                    case 117:
                        return String.fromCharCode(hex_bytes(4));
                    case 10:
                        return "";
                    default:
                        return ch
                }
            }

            function hex_bytes(n) {
                for (var num = 0; n > 0; --n) {
                    var digit = parseInt(next(!0), 16);
                    isNaN(digit) && parse_error("Invalid hex-character pattern in string"), num = num << 4 | digit
                }
                return num
            }

            function skip_line_comment(type) {
                var ret, regex_allowed = S.regex_allowed,
                    i = find("\n");
                return -1 == i ? (ret = S.text.substr(S.pos), S.pos = S.text.length) : (ret = S.text.substring(S.pos, i), S.pos = i), S.comments_before.push(token(type, ret, !0)), S.regex_allowed = regex_allowed, next_token()
            }

            function read_name() {
                for (var ch, hex, backslash = !1, name = "", escaped = !1; null != (ch = peek());)
                    if (backslash) "u" != ch && parse_error("Expecting UnicodeEscapeSequence -- uXXXX"), ch = read_escaped_char(), is_identifier_char(ch) || parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier"), name += ch, backslash = !1;
                    else if ("\\" == ch) escaped = backslash = !0, next();
                else {
                    if (!is_identifier_char(ch)) break;
                    name += next()
                }
                return KEYWORDS(name) && escaped && (hex = name.charCodeAt(0).toString(16).toUpperCase(), name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1)), name
            }

            function read_operator(prefix) {
                function grow(op) {
                    if (!peek()) return op;
                    var bigger = op + peek();
                    return OPERATORS(bigger) ? (next(), grow(bigger)) : op
                }
                return token("operator", grow(prefix || next()))
            }

            function handle_slash() {
                switch (next(), peek()) {
                    case "/":
                        return next(), skip_line_comment("comment1");
                    case "*":
                        return next(), skip_multiline_comment()
                }
                return S.regex_allowed ? read_regexp("") : read_operator("/")
            }

            function handle_dot() {
                return next(), is_digit(peek().charCodeAt(0)) ? read_num(".") : token("punc", ".")
            }

            function read_word() {
                var word = read_name();
                return prev_was_dot ? token("name", word) : KEYWORDS_ATOM(word) ? token("atom", word) : KEYWORDS(word) ? OPERATORS(word) ? token("operator", word) : token("keyword", word) : token("name", word)
            }

            function with_eof_error(eof_error, cont) {
                return function(x) {
                    try {
                        return cont(x)
                    } catch (ex) {
                        if (ex !== EX_EOF) throw ex;
                        parse_error(eof_error)
                    }
                }
            }

            function next_token(force_regexp) {
                if (null != force_regexp) return read_regexp(force_regexp);
                if (skip_whitespace(), start_token(), html5_comments) {
                    if (looking_at("<!--")) return forward(4), skip_line_comment("comment3");
                    if (looking_at("-->") && S.newline_before) return forward(3), skip_line_comment("comment4")
                }
                var ch = peek();
                if (!ch) return token("eof");
                var code = ch.charCodeAt(0);
                switch (code) {
                    case 34:
                    case 39:
                        return read_string();
                    case 46:
                        return handle_dot();
                    case 47:
                        return handle_slash()
                }
                return is_digit(code) ? read_num() : PUNC_CHARS(ch) ? token("punc", next()) : OPERATOR_CHARS(ch) ? read_operator() : 92 == code || is_identifier_start(code) ? read_word() : (parse_error("Unexpected character '" + ch + "'"), void 0)
            }
            var S = {
                    text: $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
                    filename: filename,
                    pos: 0,
                    tokpos: 0,
                    line: 1,
                    tokline: 0,
                    col: 0,
                    tokcol: 0,
                    newline_before: !1,
                    regex_allowed: !1,
                    comments_before: []
                },
                prev_was_dot = !1,
                read_string = with_eof_error("Unterminated string constant", function() {
                    for (var quote = next(), ret = "";;) {
                        var ch = next(!0);
                        if ("\\" == ch) {
                            var octal_len = 0,
                                first = null;
                            ch = read_while(function(ch) {
                                if (ch >= "0" && "7" >= ch) {
                                    if (!first) return first = ch, ++octal_len;
                                    if ("3" >= first && 2 >= octal_len) return ++octal_len;
                                    if (first >= "4" && 1 >= octal_len) return ++octal_len
                                }
                                return !1
                            }), ch = octal_len > 0 ? String.fromCharCode(parseInt(ch, 8)) : read_escaped_char(!0)
                        } else if (ch == quote) break;
                        ret += ch
                    }
                    return token("string", ret)
                }),
                skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
                    var regex_allowed = S.regex_allowed,
                        i = find("*/", !0),
                        text = S.text.substring(S.pos, i),
                        a = text.split("\n"),
                        n = a.length;
                    S.pos = i + 2, S.line += n - 1, n > 1 ? S.col = a[n - 1].length : S.col += a[n - 1].length, S.col += 2;
                    var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
                    return S.comments_before.push(token("comment2", text, !0)), S.regex_allowed = regex_allowed, S.newline_before = nlb, next_token()
                }),
                read_regexp = with_eof_error("Unterminated regular expression", function(regexp) {
                    for (var ch, prev_backslash = !1, in_class = !1; ch = next(!0);)
                        if (prev_backslash) regexp += "\\" + ch, prev_backslash = !1;
                        else if ("[" == ch) in_class = !0, regexp += ch;
                    else if ("]" == ch && in_class) in_class = !1, regexp += ch;
                    else {
                        if ("/" == ch && !in_class) break;
                        "\\" == ch ? prev_backslash = !0 : regexp += ch
                    }
                    var mods = read_name();
                    return token("regexp", new RegExp(regexp, mods))
                });
            return next_token.context = function(nc) {
                return nc && (S = nc), S
            }, next_token
        }

        function parse($TEXT, options) {
            function is(type, value) {
                return is_token(S.token, type, value)
            }

            function peek() {
                return S.peeked || (S.peeked = S.input())
            }

            function next() {
                return S.prev = S.token, S.peeked ? (S.token = S.peeked, S.peeked = null) : S.token = S.input(), S.in_directives = S.in_directives && ("string" == S.token.type || is("punc", ";")), S.token
            }

            function prev() {
                return S.prev
            }

            function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                js_error(msg, ctx.filename, null != line ? line : ctx.tokline, null != col ? col : ctx.tokcol, null != pos ? pos : ctx.tokpos)
            }

            function token_error(token, msg) {
                croak(msg, token.line, token.col)
            }

            function unexpected(token) {
                null == token && (token = S.token), token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")")
            }

            function expect_token(type, val) {
                return is(type, val) ? next() : (token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "», expected " + type + " «" + val + "»"), void 0)
            }

            function expect(punc) {
                return expect_token("punc", punc)
            }

            function can_insert_semicolon() {
                return !options.strict && (S.token.nlb || is("eof") || is("punc", "}"))
            }

            function semicolon() {
                is("punc", ";") ? next() : can_insert_semicolon() || unexpected()
            }

            function parenthesised() {
                expect("(");
                var exp = expression(!0);
                return expect(")"), exp
            }

            function embed_tokens(parser) {
                return function() {
                    var start = S.token,
                        expr = parser(),
                        end = prev();
                    return expr.start = start, expr.end = end, expr
                }
            }

            function handle_regexp() {
                (is("operator", "/") || is("operator", "/=")) && (S.peeked = null, S.token = S.input(S.token.value.substr(1)))
            }

            function labeled_statement() {
                var label = as_symbol(AST_Label);
                find_if(function(l) {
                    return l.name == label.name
                }, S.labels) && croak("Label " + label.name + " defined twice"), expect(":"), S.labels.push(label);
                var stat = statement();
                return S.labels.pop(), stat instanceof AST_IterationStatement || label.references.forEach(function(ref) {
                    ref instanceof AST_Continue && (ref = ref.label.start, croak("Continue label `" + label.name + "` refers to non-IterationStatement.", ref.line, ref.col, ref.pos))
                }), new AST_LabeledStatement({
                    body: stat,
                    label: label
                })
            }

            function simple_statement(tmp) {
                return new AST_SimpleStatement({
                    body: (tmp = expression(!0), semicolon(), tmp)
                })
            }

            function break_cont(type) {
                var ldef, label = null;
                can_insert_semicolon() || (label = as_symbol(AST_LabelRef, !0)), null != label ? (ldef = find_if(function(l) {
                    return l.name == label.name
                }, S.labels), ldef || croak("Undefined label " + label.name), label.thedef = ldef) : 0 == S.in_loop && croak(type.TYPE + " not inside a loop or switch"), semicolon();
                var stat = new type({
                    label: label
                });
                return ldef && ldef.references.push(stat), stat
            }

            function for_() {
                expect("(");
                var init = null;
                return !is("punc", ";") && (init = is("keyword", "var") ? (next(), var_(!0)) : expression(!0, !0), is("operator", "in")) ? (init instanceof AST_Var && init.definitions.length > 1 && croak("Only one variable declaration allowed in for..in loop"), next(), for_in(init)) : regular_for(init)
            }

            function regular_for(init) {
                expect(";");
                var test = is("punc", ";") ? null : expression(!0);
                expect(";");
                var step = is("punc", ")") ? null : expression(!0);
                return expect(")"), new AST_For({
                    init: init,
                    condition: test,
                    step: step,
                    body: in_loop(statement)
                })
            }

            function for_in(init) {
                var lhs = init instanceof AST_Var ? init.definitions[0].name : null,
                    obj = expression(!0);
                return expect(")"), new AST_ForIn({
                    init: init,
                    name: lhs,
                    object: obj,
                    body: in_loop(statement)
                })
            }

            function if_() {
                var cond = parenthesised(),
                    body = statement(),
                    belse = null;
                return is("keyword", "else") && (next(), belse = statement()), new AST_If({
                    condition: cond,
                    body: body,
                    alternative: belse
                })
            }

            function block_() {
                expect("{");
                for (var a = []; !is("punc", "}");) is("eof") && unexpected(), a.push(statement());
                return next(), a
            }

            function switch_body_() {
                expect("{");
                for (var tmp, a = [], cur = null, branch = null; !is("punc", "}");) is("eof") && unexpected(), is("keyword", "case") ? (branch && (branch.end = prev()), cur = [], branch = new AST_Case({
                    start: (tmp = S.token, next(), tmp),
                    expression: expression(!0),
                    body: cur
                }), a.push(branch), expect(":")) : is("keyword", "default") ? (branch && (branch.end = prev()), cur = [], branch = new AST_Default({
                    start: (tmp = S.token, next(), expect(":"), tmp),
                    body: cur
                }), a.push(branch)) : (cur || unexpected(), cur.push(statement()));
                return branch && (branch.end = prev()), next(), a
            }

            function try_() {
                var body = block_(),
                    bcatch = null,
                    bfinally = null;
                if (is("keyword", "catch")) {
                    var start = S.token;
                    next(), expect("(");
                    var name = as_symbol(AST_SymbolCatch);
                    expect(")"), bcatch = new AST_Catch({
                        start: start,
                        argname: name,
                        body: block_(),
                        end: prev()
                    })
                }
                if (is("keyword", "finally")) {
                    var start = S.token;
                    next(), bfinally = new AST_Finally({
                        start: start,
                        body: block_(),
                        end: prev()
                    })
                }
                return bcatch || bfinally || croak("Missing catch/finally blocks"), new AST_Try({
                    body: body,
                    bcatch: bcatch,
                    bfinally: bfinally
                })
            }

            function vardefs(no_in, in_const) {
                for (var a = []; a.push(new AST_VarDef({
                        start: S.token,
                        name: as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                        value: is("operator", "=") ? (next(), expression(!1, no_in)) : null,
                        end: prev()
                    })), is("punc", ",");) next();
                return a
            }

            function as_atom_node() {
                var ret, tok = S.token;
                switch (tok.type) {
                    case "name":
                        return as_symbol(AST_SymbolRef);
                    case "num":
                        ret = new AST_Number({
                            start: tok,
                            end: tok,
                            value: tok.value
                        });
                        break;
                    case "string":
                        ret = new AST_String({
                            start: tok,
                            end: tok,
                            value: tok.value
                        });
                        break;
                    case "regexp":
                        ret = new AST_RegExp({
                            start: tok,
                            end: tok,
                            value: tok.value
                        });
                        break;
                    case "atom":
                        switch (tok.value) {
                            case "false":
                                ret = new AST_False({
                                    start: tok,
                                    end: tok
                                });
                                break;
                            case "true":
                                ret = new AST_True({
                                    start: tok,
                                    end: tok
                                });
                                break;
                            case "null":
                                ret = new AST_Null({
                                    start: tok,
                                    end: tok
                                })
                        }
                }
                return next(), ret
            }

            function expr_list(closing, allow_trailing_comma, allow_empty) {
                for (var first = !0, a = []; !is("punc", closing) && (first ? first = !1 : expect(","), !allow_trailing_comma || !is("punc", closing));) is("punc", ",") && allow_empty ? a.push(new AST_Hole({
                    start: S.token,
                    end: S.token
                })) : a.push(expression(!1));
                return next(), a
            }

            function as_property_name() {
                var tmp = S.token;
                switch (next(), tmp.type) {
                    case "num":
                    case "string":
                    case "name":
                    case "operator":
                    case "keyword":
                    case "atom":
                        return tmp.value;
                    default:
                        unexpected()
                }
            }

            function as_name() {
                var tmp = S.token;
                switch (next(), tmp.type) {
                    case "name":
                    case "operator":
                    case "keyword":
                    case "atom":
                        return tmp.value;
                    default:
                        unexpected()
                }
            }

            function as_symbol(type, noerror) {
                if (!is("name")) return noerror || croak("Name expected"), null;
                var name = S.token.value,
                    sym = new("this" == name ? AST_This : type)({
                        name: String(S.token.value),
                        start: S.token,
                        end: S.token
                    });
                return next(), sym
            }

            function make_unary(ctor, op, expr) {
                return "++" != op && "--" != op || is_assignable(expr) || croak("Invalid use of " + op + " operator"), new ctor({
                    operator: op,
                    expression: expr
                })
            }

            function expr_ops(no_in) {
                return expr_op(maybe_unary(!0), 0, no_in)
            }

            function is_assignable(expr) {
                return options.strict ? expr instanceof AST_This ? !1 : expr instanceof AST_PropAccess || expr instanceof AST_Symbol : !0
            }

            function in_loop(cont) {
                ++S.in_loop;
                var ret = cont();
                return --S.in_loop, ret
            }
            options = defaults(options, {
                strict: !1,
                filename: null,
                toplevel: null,
                expression: !1,
                html5_comments: !0
            });
            var S = {
                input: "string" == typeof $TEXT ? tokenizer($TEXT, options.filename, options.html5_comments) : $TEXT,
                token: null,
                prev: null,
                peeked: null,
                in_function: 0,
                in_directives: !0,
                in_loop: 0,
                labels: []
            };
            S.token = next();
            var statement = embed_tokens(function() {
                    var tmp;
                    switch (handle_regexp(), S.token.type) {
                        case "string":
                            var dir = S.in_directives,
                                stat = simple_statement();
                            return dir && stat.body instanceof AST_String && !is("punc", ",") ? new AST_Directive({
                                value: stat.body.value
                            }) : stat;
                        case "num":
                        case "regexp":
                        case "operator":
                        case "atom":
                            return simple_statement();
                        case "name":
                            return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();
                        case "punc":
                            switch (S.token.value) {
                                case "{":
                                    return new AST_BlockStatement({
                                        start: S.token,
                                        body: block_(),
                                        end: prev()
                                    });
                                case "[":
                                case "(":
                                    return simple_statement();
                                case ";":
                                    return next(), new AST_EmptyStatement;
                                default:
                                    unexpected()
                            }
                        case "keyword":
                            switch (tmp = S.token.value, next(), tmp) {
                                case "break":
                                    return break_cont(AST_Break);
                                case "continue":
                                    return break_cont(AST_Continue);
                                case "debugger":
                                    return semicolon(), new AST_Debugger;
                                case "do":
                                    return new AST_Do({
                                        body: in_loop(statement),
                                        condition: (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), tmp)
                                    });
                                case "while":
                                    return new AST_While({
                                        condition: parenthesised(),
                                        body: in_loop(statement)
                                    });
                                case "for":
                                    return for_();
                                case "function":
                                    return function_(!0);
                                case "if":
                                    return if_();
                                case "return":
                                    return 0 == S.in_function && croak("'return' outside of function"), new AST_Return({
                                        value: is("punc", ";") ? (next(), null) : can_insert_semicolon() ? null : (tmp = expression(!0), semicolon(), tmp)
                                    });
                                case "switch":
                                    return new AST_Switch({
                                        expression: parenthesised(),
                                        body: in_loop(switch_body_)
                                    });
                                case "throw":
                                    return S.token.nlb && croak("Illegal newline after 'throw'"), new AST_Throw({
                                        value: (tmp = expression(!0), semicolon(), tmp)
                                    });
                                case "try":
                                    return try_();
                                case "var":
                                    return tmp = var_(), semicolon(), tmp;
                                case "const":
                                    return tmp = const_(), semicolon(), tmp;
                                case "with":
                                    return new AST_With({
                                        expression: parenthesised(),
                                        body: statement()
                                    });
                                default:
                                    unexpected()
                            }
                    }
                }),
                function_ = function(in_statement, ctor) {
                    var is_accessor = ctor === AST_Accessor,
                        name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : is_accessor ? AST_SymbolAccessor : AST_SymbolLambda) : is_accessor && (is("string") || is("num")) ? as_atom_node() : null;
                    return in_statement && !name && unexpected(), expect("("), ctor || (ctor = in_statement ? AST_Defun : AST_Function), new ctor({
                        name: name,
                        argnames: function(first, a) {
                            for (; !is("punc", ")");) first ? first = !1 : expect(","), a.push(as_symbol(AST_SymbolFunarg));
                            return next(), a
                        }(!0, []),
                        body: function(loop, labels) {
                            ++S.in_function, S.in_directives = !0, S.in_loop = 0, S.labels = [];
                            var a = block_();
                            return --S.in_function, S.in_loop = loop, S.labels = labels, a
                        }(S.in_loop, S.labels)
                    })
                },
                var_ = function(no_in) {
                    return new AST_Var({
                        start: prev(),
                        definitions: vardefs(no_in, !1),
                        end: prev()
                    })
                },
                const_ = function() {
                    return new AST_Const({
                        start: prev(),
                        definitions: vardefs(!1, !0),
                        end: prev()
                    })
                },
                new_ = function() {
                    var start = S.token;
                    expect_token("operator", "new");
                    var args, newexp = expr_atom(!1);
                    return is("punc", "(") ? (next(), args = expr_list(")")) : args = [], subscripts(new AST_New({
                        start: start,
                        expression: newexp,
                        args: args,
                        end: prev()
                    }), !0)
                },
                expr_atom = function(allow_calls) {
                    if (is("operator", "new")) return new_();
                    var start = S.token;
                    if (is("punc")) {
                        switch (start.value) {
                            case "(":
                                next();
                                var ex = expression(!0);
                                return ex.start = start, ex.end = S.token, expect(")"), subscripts(ex, allow_calls);
                            case "[":
                                return subscripts(array_(), allow_calls);
                            case "{":
                                return subscripts(object_(), allow_calls)
                        }
                        unexpected()
                    }
                    if (is("keyword", "function")) {
                        next();
                        var func = function_(!1);
                        return func.start = start, func.end = prev(), subscripts(func, allow_calls)
                    }
                    return ATOMIC_START_TOKEN[S.token.type] ? subscripts(as_atom_node(), allow_calls) : (unexpected(), void 0)
                },
                array_ = embed_tokens(function() {
                    return expect("["), new AST_Array({
                        elements: expr_list("]", !options.strict, !0)
                    })
                }),
                object_ = embed_tokens(function() {
                    expect("{");
                    for (var first = !0, a = []; !is("punc", "}") && (first ? first = !1 : expect(","), options.strict || !is("punc", "}"));) {
                        var start = S.token,
                            type = start.type,
                            name = as_property_name();
                        if ("name" == type && !is("punc", ":")) {
                            if ("get" == name) {
                                a.push(new AST_ObjectGetter({
                                    start: start,
                                    key: name,
                                    value: function_(!1, AST_Accessor),
                                    end: prev()
                                }));
                                continue
                            }
                            if ("set" == name) {
                                a.push(new AST_ObjectSetter({
                                    start: start,
                                    key: name,
                                    value: function_(!1, AST_Accessor),
                                    end: prev()
                                }));
                                continue
                            }
                        }
                        expect(":"), a.push(new AST_ObjectKeyVal({
                            start: start,
                            key: name,
                            value: expression(!1),
                            end: prev()
                        }))
                    }
                    return next(), new AST_Object({
                        properties: a
                    })
                }),
                subscripts = function(expr, allow_calls) {
                    var start = expr.start;
                    if (is("punc", ".")) return next(), subscripts(new AST_Dot({
                        start: start,
                        expression: expr,
                        property: as_name(),
                        end: prev()
                    }), allow_calls);
                    if (is("punc", "[")) {
                        next();
                        var prop = expression(!0);
                        return expect("]"), subscripts(new AST_Sub({
                            start: start,
                            expression: expr,
                            property: prop,
                            end: prev()
                        }), allow_calls)
                    }
                    return allow_calls && is("punc", "(") ? (next(), subscripts(new AST_Call({
                        start: start,
                        expression: expr,
                        args: expr_list(")"),
                        end: prev()
                    }), !0)) : expr
                },
                maybe_unary = function(allow_calls) {
                    var start = S.token;
                    if (is("operator") && UNARY_PREFIX(start.value)) {
                        next(), handle_regexp();
                        var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
                        return ex.start = start, ex.end = prev(), ex
                    }
                    for (var val = expr_atom(allow_calls); is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb;) val = make_unary(AST_UnaryPostfix, S.token.value, val), val.start = start, val.end = S.token, next();
                    return val
                },
                expr_op = function(left, min_prec, no_in) {
                    var op = is("operator") ? S.token.value : null;
                    "in" == op && no_in && (op = null);
                    var prec = null != op ? PRECEDENCE[op] : null;
                    if (null != prec && prec > min_prec) {
                        next();
                        var right = expr_op(maybe_unary(!0), prec, no_in);
                        return expr_op(new AST_Binary({
                            start: left.start,
                            left: left,
                            operator: op,
                            right: right,
                            end: right.end
                        }), min_prec, no_in)
                    }
                    return left
                },
                maybe_conditional = function(no_in) {
                    var start = S.token,
                        expr = expr_ops(no_in);
                    if (is("operator", "?")) {
                        next();
                        var yes = expression(!1);
                        return expect(":"), new AST_Conditional({
                            start: start,
                            condition: expr,
                            consequent: yes,
                            alternative: expression(!1, no_in),
                            end: peek()
                        })
                    }
                    return expr
                },
                maybe_assign = function(no_in) {
                    var start = S.token,
                        left = maybe_conditional(no_in),
                        val = S.token.value;
                    if (is("operator") && ASSIGNMENT(val)) {
                        if (is_assignable(left)) return next(), new AST_Assign({
                            start: start,
                            left: left,
                            operator: val,
                            right: maybe_assign(no_in),
                            end: prev()
                        });
                        croak("Invalid assignment")
                    }
                    return left
                },
                expression = function(commas, no_in) {
                    var start = S.token,
                        expr = maybe_assign(no_in);
                    return commas && is("punc", ",") ? (next(), new AST_Seq({
                        start: start,
                        car: expr,
                        cdr: expression(!0, no_in),
                        end: peek()
                    })) : expr
                };
            return options.expression ? expression(!0) : function() {
                for (var start = S.token, body = []; !is("eof");) body.push(statement());
                var end = prev(),
                    toplevel = options.toplevel;
                return toplevel ? (toplevel.body = toplevel.body.concat(body), toplevel.end = end) : toplevel = new AST_Toplevel({
                    start: start,
                    body: body,
                    end: end
                }), toplevel
            }()
        }

        function TreeTransformer(before, after) {
            TreeWalker.call(this), this.before = before, this.after = after
        }

        function SymbolDef(scope, index, orig) {
            this.name = orig.name, this.orig = [orig], this.scope = scope, this.references = [], this.global = !1, this.mangled_name = null, this.undeclared = !1, this.constant = !1, this.index = index
        }

        function OutputStream(options) {
            function to_ascii(str, identifier) {
                return str.replace(/[\u0080-\uffff]/g, function(ch) {
                    var code = ch.charCodeAt(0).toString(16);
                    if (code.length <= 2 && !identifier) {
                        for (; code.length < 2;) code = "0" + code;
                        return "\\x" + code
                    }
                    for (; code.length < 4;) code = "0" + code;
                    return "\\u" + code
                })
            }

            function make_string(str) {
                var dq = 0,
                    sq = 0;
                return str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s) {
                    switch (s) {
                        case "\\":
                            return "\\\\";
                        case "\b":
                            return "\\b";
                        case "\f":
                            return "\\f";
                        case "\n":
                            return "\\n";
                        case "\r":
                            return "\\r";
                        case "\u2028":
                            return "\\u2028";
                        case "\u2029":
                            return "\\u2029";
                        case '"':
                            return ++dq, '"';
                        case "'":
                            return ++sq, "'";
                        case "\x00":
                            return "\\x00"
                    }
                    return s
                }), options.ascii_only && (str = to_ascii(str)), dq > sq ? "'" + str.replace(/\x27/g, "\\'") + "'" : '"' + str.replace(/\x22/g, '\\"') + '"'
            }

            function encode_string(str) {
                var ret = make_string(str);
                return options.inline_script && (ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1")), ret
            }

            function make_name(name) {
                return name = name.toString(), options.ascii_only && (name = to_ascii(name, !0)), name
            }

            function make_indent(back) {
                return repeat_string(" ", options.indent_start + indentation - back * options.indent_level)
            }

            function last_char() {
                return last.charAt(last.length - 1)
            }

            function maybe_newline() {
                options.max_line_len && current_col > options.max_line_len && print("\n")
            }

            function print(str) {
                str = String(str);
                var ch = str.charAt(0);
                if (might_need_semicolon && (ch && !(";}".indexOf(ch) < 0) || /[;]$/.test(last) || (options.semicolons || requireSemicolonChars(ch) ? (OUTPUT += ";", current_col++, current_pos++) : (OUTPUT += "\n", current_pos++, current_line++, current_col = 0), options.beautify || (might_need_space = !1)), might_need_semicolon = !1, maybe_newline()), !options.beautify && options.preserve_line && stack[stack.length - 1])
                    for (var target_line = stack[stack.length - 1].start.line; target_line > current_line;) OUTPUT += "\n", current_pos++, current_line++, current_col = 0, might_need_space = !1;
                if (might_need_space) {
                    var prev = last_char();
                    (is_identifier_char(prev) && (is_identifier_char(ch) || "\\" == ch) || /^[\+\-\/]$/.test(ch) && ch == prev) && (OUTPUT += " ", current_col++, current_pos++), might_need_space = !1
                }
                var a = str.split(/\r?\n/),
                    n = a.length - 1;
                current_line += n, 0 == n ? current_col += a[n].length : current_col = a[n].length, current_pos += str.length, last = str, OUTPUT += str
            }

            function force_semicolon() {
                might_need_semicolon = !1, print(";")
            }

            function next_indent() {
                return indentation + options.indent_level
            }

            function with_block(cont) {
                var ret;
                return print("{"), newline(), with_indent(next_indent(), function() {
                    ret = cont()
                }), indent(), print("}"), ret
            }

            function with_parens(cont) {
                print("(");
                var ret = cont();
                return print(")"), ret
            }

            function with_square(cont) {
                print("[");
                var ret = cont();
                return print("]"), ret
            }

            function comma() {
                print(","), space()
            }

            function colon() {
                print(":"), options.space_colon && space()
            }

            function get() {
                return OUTPUT
            }
            options = defaults(options, {
                indent_start: 0,
                indent_level: 4,
                quote_keys: !1,
                space_colon: !0,
                ascii_only: !1,
                inline_script: !1,
                width: 80,
                max_line_len: 32e3,
                beautify: !1,
                source_map: null,
                bracketize: !1,
                semicolons: !0,
                comments: !1,
                preserve_line: !1,
                screw_ie8: !1
            }, !0);
            var indentation = 0,
                current_col = 0,
                current_line = 1,
                current_pos = 0,
                OUTPUT = "",
                might_need_space = !1,
                might_need_semicolon = !1,
                last = null,
                requireSemicolonChars = makePredicate("( [ + * / - , ."),
                space = options.beautify ? function() {
                    print(" ")
                } : function() {
                    might_need_space = !0
                },
                indent = options.beautify ? function(half) {
                    options.beautify && print(make_indent(half ? .5 : 0))
                } : noop,
                with_indent = options.beautify ? function(col, cont) {
                    col === !0 && (col = next_indent());
                    var save_indentation = indentation;
                    indentation = col;
                    var ret = cont();
                    return indentation = save_indentation, ret
                } : function(col, cont) {
                    return cont()
                },
                newline = options.beautify ? function() {
                    print("\n")
                } : noop,
                semicolon = options.beautify ? function() {
                    print(";")
                } : function() {
                    might_need_semicolon = !0
                },
                add_mapping = options.source_map ? function(token, name) {
                    try {
                        token && options.source_map.add(token.file || "?", current_line, current_col, token.line, token.col, name || "name" != token.type ? name : token.value)
                    } catch (ex) {
                        AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                            file: token.file,
                            line: token.line,
                            col: token.col,
                            cline: current_line,
                            ccol: current_col,
                            name: name || ""
                        })
                    }
                } : noop,
                stack = [];
            return {
                get: get,
                toString: get,
                indent: indent,
                indentation: function() {
                    return indentation
                },
                current_width: function() {
                    return current_col - indentation
                },
                should_break: function() {
                    return options.width && this.current_width() >= options.width
                },
                newline: newline,
                print: print,
                space: space,
                comma: comma,
                colon: colon,
                last: function() {
                    return last
                },
                semicolon: semicolon,
                force_semicolon: force_semicolon,
                to_ascii: to_ascii,
                print_name: function(name) {
                    print(make_name(name))
                },
                print_string: function(str) {
                    print(encode_string(str))
                },
                next_indent: next_indent,
                with_indent: with_indent,
                with_block: with_block,
                with_parens: with_parens,
                with_square: with_square,
                add_mapping: add_mapping,
                option: function(opt) {
                    return options[opt]
                },
                line: function() {
                    return current_line
                },
                col: function() {
                    return current_col
                },
                pos: function() {
                    return current_pos
                },
                push_node: function(node) {
                    stack.push(node)
                },
                pop_node: function() {
                    return stack.pop()
                },
                stack: function() {
                    return stack
                },
                parent: function(n) {
                    return stack[stack.length - 2 - (n || 0)]
                }
            }
        }

        function Compressor(options, false_by_default) {
            return this instanceof Compressor ? (TreeTransformer.call(this, this.before, this.after), this.options = defaults(options, {
                sequences: !false_by_default,
                properties: !false_by_default,
                dead_code: !false_by_default,
                drop_debugger: !false_by_default,
                unsafe: !1,
                unsafe_comps: !1,
                conditionals: !false_by_default,
                comparisons: !false_by_default,
                evaluate: !false_by_default,
                booleans: !false_by_default,
                loops: !false_by_default,
                unused: !false_by_default,
                hoist_funs: !false_by_default,
                hoist_vars: !1,
                if_return: !false_by_default,
                join_vars: !false_by_default,
                cascade: !false_by_default,
                side_effects: !false_by_default,
                pure_getters: !1,
                pure_funcs: null,
                negate_iife: !false_by_default,
                screw_ie8: !1,
                warnings: !0,
                global_defs: {}
            }, !0), void 0) : new Compressor(options, false_by_default)
        }

        function SourceMap(options) {
            function add(source, gen_line, gen_col, orig_line, orig_col, name) {
                if (orig_map) {
                    var info = orig_map.originalPositionFor({
                        line: orig_line,
                        column: orig_col
                    });
                    source = info.source, orig_line = info.line, orig_col = info.column, name = info.name
                }
                generator.addMapping({
                    generated: {
                        line: gen_line,
                        column: gen_col
                    },
                    original: {
                        line: orig_line,
                        column: orig_col
                    },
                    source: source,
                    name: name
                })
            }
            options = defaults(options, {
                file: null,
                root: null,
                orig: null
            });
            var generator = new MOZ_SourceMap.SourceMapGenerator({
                    file: options.file,
                    sourceRoot: options.root
                }),
                orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
            return {
                add: add,
                get: function() {
                    return generator
                },
                toString: function() {
                    return generator.toString()
                }
            }
        }
        global.UglifyJS = exports;
        var MAP = function() {
            function MAP(a, f, backwards) {
                function doit() {
                    var val = f(a[i], i),
                        is_last = val instanceof Last;
                    return is_last && (val = val.v), val instanceof AtTop ? (val = val.v, val instanceof Splice ? top.push.apply(top, backwards ? val.v.slice().reverse() : val.v) : top.push(val)) : val !== skip && (val instanceof Splice ? ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v) : ret.push(val)), is_last
                }
                var i, ret = [],
                    top = [];
                if (a instanceof Array)
                    if (backwards) {
                        for (i = a.length; --i >= 0 && !doit(););
                        ret.reverse(), top.reverse()
                    } else
                        for (i = 0; i < a.length && !doit(); ++i);
                else
                    for (i in a)
                        if (a.hasOwnProperty(i) && doit()) break; return top.concat(ret)
            }

            function AtTop(val) {
                this.v = val
            }

            function Splice(val) {
                this.v = val
            }

            function Last(val) {
                this.v = val
            }
            MAP.at_top = function(val) {
                return new AtTop(val)
            }, MAP.splice = function(val) {
                return new Splice(val)
            }, MAP.last = function(val) {
                return new Last(val)
            };
            var skip = MAP.skip = {};
            return MAP
        }();
        Dictionary.prototype = {
            set: function(key, val) {
                return this.has(key) || ++this._size, this._values["$" + key] = val, this
            },
            add: function(key, val) {
                return this.has(key) ? this.get(key).push(val) : this.set(key, [val]), this
            },
            get: function(key) {
                return this._values["$" + key]
            },
            del: function(key) {
                return this.has(key) && (--this._size, delete this._values["$" + key]), this
            },
            has: function(key) {
                return "$" + key in this._values
            },
            each: function(f) {
                for (var i in this._values) f(this._values[i], i.substr(1))
            },
            size: function() {
                return this._size
            },
            map: function(f) {
                var ret = [];
                for (var i in this._values) ret.push(f(this._values[i], i.substr(1)));
                return ret
            }
        };
        var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, null),
            AST_Node = DEFNODE("Node", "start end", {
                clone: function() {
                    return new this.CTOR(this)
                },
                $documentation: "Base class of all AST nodes",
                $propdoc: {
                    start: "[AST_Token] The first token of this node",
                    end: "[AST_Token] The last token of this node"
                },
                _walk: function(visitor) {
                    return visitor._visit(this)
                },
                walk: function(visitor) {
                    return this._walk(visitor)
                }
            }, null);
        AST_Node.warn_function = null, AST_Node.warn = function(txt, props) {
            AST_Node.warn_function && AST_Node.warn_function(string_template(txt, props))
        };
        var AST_Statement = DEFNODE("Statement", null, {
                $documentation: "Base class of all statements"
            }),
            AST_Debugger = DEFNODE("Debugger", null, {
                $documentation: "Represents a debugger statement"
            }, AST_Statement),
            AST_Directive = DEFNODE("Directive", "value scope", {
                $documentation: 'Represents a directive, like "use strict";',
                $propdoc: {
                    value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
                    scope: "[AST_Scope/S] The scope that this directive affects"
                }
            }, AST_Statement),
            AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
                $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
                $propdoc: {
                    body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.body._walk(visitor)
                    })
                }
            }, AST_Statement),
            AST_Block = DEFNODE("Block", "body", {
                $documentation: "A body of statements (usually bracketed)",
                $propdoc: {
                    body: "[AST_Statement*] an array of statements"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        walk_body(this, visitor)
                    })
                }
            }, AST_Statement),
            AST_BlockStatement = DEFNODE("BlockStatement", null, {
                $documentation: "A block statement"
            }, AST_Block),
            AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
                $documentation: "The empty statement (empty block or simply a semicolon)",
                _walk: function(visitor) {
                    return visitor._visit(this)
                }
            }, AST_Statement),
            AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
                $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
                $propdoc: {
                    body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.body._walk(visitor)
                    })
                }
            }, AST_Statement),
            AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
                $documentation: "Statement with a label",
                $propdoc: {
                    label: "[AST_Label] a label definition"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.label._walk(visitor), this.body._walk(visitor)
                    })
                }
            }, AST_StatementWithBody),
            AST_IterationStatement = DEFNODE("IterationStatement", null, {
                $documentation: "Internal class.  All loops inherit from it."
            }, AST_StatementWithBody),
            AST_DWLoop = DEFNODE("DWLoop", "condition", {
                $documentation: "Base class for do/while statements",
                $propdoc: {
                    condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.condition._walk(visitor), this.body._walk(visitor)
                    })
                }
            }, AST_IterationStatement),
            AST_Do = DEFNODE("Do", null, {
                $documentation: "A `do` statement"
            }, AST_DWLoop),
            AST_While = DEFNODE("While", null, {
                $documentation: "A `while` statement"
            }, AST_DWLoop),
            AST_For = DEFNODE("For", "init condition step", {
                $documentation: "A `for` statement",
                $propdoc: {
                    init: "[AST_Node?] the `for` initialization code, or null if empty",
                    condition: "[AST_Node?] the `for` termination clause, or null if empty",
                    step: "[AST_Node?] the `for` update clause, or null if empty"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.init && this.init._walk(visitor), this.condition && this.condition._walk(visitor), this.step && this.step._walk(visitor), this.body._walk(visitor)
                    })
                }
            }, AST_IterationStatement),
            AST_ForIn = DEFNODE("ForIn", "init name object", {
                $documentation: "A `for ... in` statement",
                $propdoc: {
                    init: "[AST_Node] the `for/in` initialization code",
                    name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
                    object: "[AST_Node] the object that we're looping through"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.init._walk(visitor), this.object._walk(visitor), this.body._walk(visitor)
                    })
                }
            }, AST_IterationStatement),
            AST_With = DEFNODE("With", "expression", {
                $documentation: "A `with` statement",
                $propdoc: {
                    expression: "[AST_Node] the `with` expression"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor), this.body._walk(visitor)
                    })
                }
            }, AST_StatementWithBody),
            AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
                $documentation: "Base class for all statements introducing a lexical scope",
                $propdoc: {
                    directives: "[string*/S] an array of directives declared in this scope",
                    variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
                    functions: "[Object/S] like `variables`, but only lists function declarations",
                    uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
                    uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
                    parent_scope: "[AST_Scope?/S] link to the parent scope",
                    enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
                    cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
                }
            }, AST_Block),
            AST_Toplevel = DEFNODE("Toplevel", "globals", {
                $documentation: "The toplevel scope",
                $propdoc: {
                    globals: "[Object/S] a map of name -> SymbolDef for all undeclared names"
                },
                wrap_enclose: function(arg_parameter_pairs) {
                    var self = this,
                        args = [],
                        parameters = [];
                    arg_parameter_pairs.forEach(function(pair) {
                        var split = pair.split(":");
                        args.push(split[0]), parameters.push(split[1])
                    });
                    var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
                    return wrapped_tl = parse(wrapped_tl), wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
                        return node instanceof AST_Directive && "$ORIG" == node.value ? MAP.splice(self.body) : void 0
                    }))
                },
                wrap_commonjs: function(name, export_all) {
                    var self = this,
                        to_export = [];
                    export_all && (self.figure_out_scope(), self.walk(new TreeWalker(function(node) {
                        node instanceof AST_SymbolDeclaration && node.definition().global && (find_if(function(n) {
                            return n.name == node.name
                        }, to_export) || to_export.push(node))
                    })));
                    var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
                    return wrapped_tl = parse(wrapped_tl), wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
                        if (node instanceof AST_SimpleStatement && (node = node.body, node instanceof AST_String)) switch (node.getValue()) {
                            case "$ORIG":
                                return MAP.splice(self.body);
                            case "$EXPORTS":
                                var body = [];
                                return to_export.forEach(function(sym) {
                                    body.push(new AST_SimpleStatement({
                                        body: new AST_Assign({
                                            left: new AST_Sub({
                                                expression: new AST_SymbolRef({
                                                    name: "exports"
                                                }),
                                                property: new AST_String({
                                                    value: sym.name
                                                })
                                            }),
                                            operator: "=",
                                            right: new AST_SymbolRef(sym)
                                        })
                                    }))
                                }), MAP.splice(body)
                        }
                    }))
                }
            }, AST_Scope),
            AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
                $documentation: "Base class for functions",
                $propdoc: {
                    name: "[AST_SymbolDeclaration?] the name of this function",
                    argnames: "[AST_SymbolFunarg*] array of function arguments",
                    uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.name && this.name._walk(visitor), this.argnames.forEach(function(arg) {
                            arg._walk(visitor)
                        }), walk_body(this, visitor)
                    })
                }
            }, AST_Scope),
            AST_Accessor = DEFNODE("Accessor", null, {
                $documentation: "A setter/getter function"
            }, AST_Lambda),
            AST_Function = DEFNODE("Function", null, {
                $documentation: "A function expression"
            }, AST_Lambda),
            AST_Defun = DEFNODE("Defun", null, {
                $documentation: "A function definition"
            }, AST_Lambda),
            AST_Jump = DEFNODE("Jump", null, {
                $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
            }, AST_Statement),
            AST_Exit = DEFNODE("Exit", "value", {
                $documentation: "Base class for “exits” (`return` and `throw`)",
                $propdoc: {
                    value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, this.value && function() {
                        this.value._walk(visitor)
                    })
                }
            }, AST_Jump),
            AST_Return = DEFNODE("Return", null, {
                $documentation: "A `return` statement"
            }, AST_Exit),
            AST_Throw = DEFNODE("Throw", null, {
                $documentation: "A `throw` statement"
            }, AST_Exit),
            AST_LoopControl = DEFNODE("LoopControl", "label", {
                $documentation: "Base class for loop control statements (`break` and `continue`)",
                $propdoc: {
                    label: "[AST_LabelRef?] the label, or null if none"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, this.label && function() {
                        this.label._walk(visitor)
                    })
                }
            }, AST_Jump),
            AST_Break = DEFNODE("Break", null, {
                $documentation: "A `break` statement"
            }, AST_LoopControl),
            AST_Continue = DEFNODE("Continue", null, {
                $documentation: "A `continue` statement"
            }, AST_LoopControl),
            AST_If = DEFNODE("If", "condition alternative", {
                $documentation: "A `if` statement",
                $propdoc: {
                    condition: "[AST_Node] the `if` condition",
                    alternative: "[AST_Statement?] the `else` part, or null if not present"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.condition._walk(visitor), this.body._walk(visitor), this.alternative && this.alternative._walk(visitor)
                    })
                }
            }, AST_StatementWithBody),
            AST_Switch = DEFNODE("Switch", "expression", {
                $documentation: "A `switch` statement",
                $propdoc: {
                    expression: "[AST_Node] the `switch` “discriminant”"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor), walk_body(this, visitor)
                    })
                }
            }, AST_Block),
            AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
                $documentation: "Base class for `switch` branches"
            }, AST_Block),
            AST_Default = DEFNODE("Default", null, {
                $documentation: "A `default` switch branch"
            }, AST_SwitchBranch),
            AST_Case = DEFNODE("Case", "expression", {
                $documentation: "A `case` switch branch",
                $propdoc: {
                    expression: "[AST_Node] the `case` expression"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor), walk_body(this, visitor)
                    })
                }
            }, AST_SwitchBranch),
            AST_Try = DEFNODE("Try", "bcatch bfinally", {
                $documentation: "A `try` statement",
                $propdoc: {
                    bcatch: "[AST_Catch?] the catch block, or null if not present",
                    bfinally: "[AST_Finally?] the finally block, or null if not present"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        walk_body(this, visitor), this.bcatch && this.bcatch._walk(visitor), this.bfinally && this.bfinally._walk(visitor)
                    })
                }
            }, AST_Block),
            AST_Catch = DEFNODE("Catch", "argname", {
                $documentation: "A `catch` node; only makes sense as part of a `try` statement",
                $propdoc: {
                    argname: "[AST_SymbolCatch] symbol for the exception"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.argname._walk(visitor), walk_body(this, visitor)
                    })
                }
            }, AST_Block),
            AST_Finally = DEFNODE("Finally", null, {
                $documentation: "A `finally` node; only makes sense as part of a `try` statement"
            }, AST_Block),
            AST_Definitions = DEFNODE("Definitions", "definitions", {
                $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
                $propdoc: {
                    definitions: "[AST_VarDef*] array of variable definitions"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.definitions.forEach(function(def) {
                            def._walk(visitor)
                        })
                    })
                }
            }, AST_Statement),
            AST_Var = DEFNODE("Var", null, {
                $documentation: "A `var` statement"
            }, AST_Definitions),
            AST_Const = DEFNODE("Const", null, {
                $documentation: "A `const` statement"
            }, AST_Definitions),
            AST_VarDef = DEFNODE("VarDef", "name value", {
                $documentation: "A variable declaration; only appears in a AST_Definitions node",
                $propdoc: {
                    name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
                    value: "[AST_Node?] initializer, or null of there's no initializer"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.name._walk(visitor), this.value && this.value._walk(visitor)
                    })
                }
            }),
            AST_Call = DEFNODE("Call", "expression args", {
                $documentation: "A function call expression",
                $propdoc: {
                    expression: "[AST_Node] expression to invoke as function",
                    args: "[AST_Node*] array of arguments"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor), this.args.forEach(function(arg) {
                            arg._walk(visitor)
                        })
                    })
                }
            }),
            AST_New = DEFNODE("New", null, {
                $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
            }, AST_Call),
            AST_Seq = DEFNODE("Seq", "car cdr", {
                $documentation: "A sequence expression (two comma-separated expressions)",
                $propdoc: {
                    car: "[AST_Node] first element in sequence",
                    cdr: "[AST_Node] second element in sequence"
                },
                $cons: function(x, y) {
                    var seq = new AST_Seq(x);
                    return seq.car = x, seq.cdr = y, seq
                },
                $from_array: function(array) {
                    if (0 == array.length) return null;
                    if (1 == array.length) return array[0].clone();
                    for (var list = null, i = array.length; --i >= 0;) list = AST_Seq.cons(array[i], list);
                    for (var p = list; p;) {
                        if (p.cdr && !p.cdr.cdr) {
                            p.cdr = p.cdr.car;
                            break
                        }
                        p = p.cdr
                    }
                    return list
                },
                to_array: function() {
                    for (var p = this, a = []; p;) {
                        if (a.push(p.car), p.cdr && !(p.cdr instanceof AST_Seq)) {
                            a.push(p.cdr);
                            break
                        }
                        p = p.cdr
                    }
                    return a
                },
                add: function(node) {
                    for (var p = this; p;) {
                        if (!(p.cdr instanceof AST_Seq)) {
                            var cell = AST_Seq.cons(p.cdr, node);
                            return p.cdr = cell
                        }
                        p = p.cdr
                    }
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.car._walk(visitor), this.cdr && this.cdr._walk(visitor)
                    })
                }
            }),
            AST_PropAccess = DEFNODE("PropAccess", "expression property", {
                $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
                $propdoc: {
                    expression: "[AST_Node] the “container” expression",
                    property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
                }
            }),
            AST_Dot = DEFNODE("Dot", null, {
                $documentation: "A dotted property access expression",
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor)
                    })
                }
            }, AST_PropAccess),
            AST_Sub = DEFNODE("Sub", null, {
                $documentation: 'Index-style property access, i.e. `a["foo"]`',
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor), this.property._walk(visitor)
                    })
                }
            }, AST_PropAccess),
            AST_Unary = DEFNODE("Unary", "operator expression", {
                $documentation: "Base class for unary expressions",
                $propdoc: {
                    operator: "[string] the operator",
                    expression: "[AST_Node] expression that this unary operator applies to"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.expression._walk(visitor)
                    })
                }
            }),
            AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
                $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
            }, AST_Unary),
            AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
                $documentation: "Unary postfix expression, i.e. `i++`"
            }, AST_Unary),
            AST_Binary = DEFNODE("Binary", "left operator right", {
                $documentation: "Binary expression, i.e. `a + b`",
                $propdoc: {
                    left: "[AST_Node] left-hand side expression",
                    operator: "[string] the operator",
                    right: "[AST_Node] right-hand side expression"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.left._walk(visitor), this.right._walk(visitor)
                    })
                }
            }),
            AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
                $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
                $propdoc: {
                    condition: "[AST_Node]",
                    consequent: "[AST_Node]",
                    alternative: "[AST_Node]"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.condition._walk(visitor), this.consequent._walk(visitor), this.alternative._walk(visitor)
                    })
                }
            }),
            AST_Assign = DEFNODE("Assign", null, {
                $documentation: "An assignment expression — `a = b + 5`"
            }, AST_Binary),
            AST_Array = DEFNODE("Array", "elements", {
                $documentation: "An array literal",
                $propdoc: {
                    elements: "[AST_Node*] array of elements"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.elements.forEach(function(el) {
                            el._walk(visitor)
                        })
                    })
                }
            }),
            AST_Object = DEFNODE("Object", "properties", {
                $documentation: "An object literal",
                $propdoc: {
                    properties: "[AST_ObjectProperty*] array of properties"
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.properties.forEach(function(prop) {
                            prop._walk(visitor)
                        })
                    })
                }
            }),
            AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
                $documentation: "Base class for literal object properties",
                $propdoc: {
                    key: "[string] the property name; it's always a plain string in our AST, no matter if it was a string, number or identifier in original code",
                    value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
                },
                _walk: function(visitor) {
                    return visitor._visit(this, function() {
                        this.value._walk(visitor)
                    })
                }
            }),
            AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
                $documentation: "A key: value object property"
            }, AST_ObjectProperty),
            AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
                $documentation: "An object setter property"
            }, AST_ObjectProperty),
            AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
                $documentation: "An object getter property"
            }, AST_ObjectProperty),
            AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
                $propdoc: {
                    name: "[string] name of this symbol",
                    scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
                    thedef: "[SymbolDef/S] the definition of this symbol"
                },
                $documentation: "Base class for all symbols"
            }),
            AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
                $documentation: "The name of a property accessor (setter/getter function)"
            }, AST_Symbol),
            AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
                $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
                $propdoc: {
                    init: "[AST_Node*/S] array of initializers for this declaration."
                }
            }, AST_Symbol),
            AST_SymbolVar = DEFNODE("SymbolVar", null, {
                $documentation: "Symbol defining a variable"
            }, AST_SymbolDeclaration),
            AST_SymbolConst = DEFNODE("SymbolConst", null, {
                $documentation: "A constant declaration"
            }, AST_SymbolDeclaration),
            AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
                $documentation: "Symbol naming a function argument"
            }, AST_SymbolVar),
            AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
                $documentation: "Symbol defining a function"
            }, AST_SymbolDeclaration),
            AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
                $documentation: "Symbol naming a function expression"
            }, AST_SymbolDeclaration),
            AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
                $documentation: "Symbol naming the exception in catch"
            }, AST_SymbolDeclaration),
            AST_Label = DEFNODE("Label", "references", {
                $documentation: "Symbol naming a label (declaration)",
                $propdoc: {
                    references: "[AST_LoopControl*] a list of nodes referring to this label"
                },
                initialize: function() {
                    this.references = [], this.thedef = this
                }
            }, AST_Symbol),
            AST_SymbolRef = DEFNODE("SymbolRef", null, {
                $documentation: "Reference to some symbol (not definition/declaration)"
            }, AST_Symbol),
            AST_LabelRef = DEFNODE("LabelRef", null, {
                $documentation: "Reference to a label symbol"
            }, AST_Symbol),
            AST_This = DEFNODE("This", null, {
                $documentation: "The `this` symbol"
            }, AST_Symbol),
            AST_Constant = DEFNODE("Constant", null, {
                $documentation: "Base class for all constants",
                getValue: function() {
                    return this.value
                }
            }),
            AST_String = DEFNODE("String", "value", {
                $documentation: "A string literal",
                $propdoc: {
                    value: "[string] the contents of this string"
                }
            }, AST_Constant),
            AST_Number = DEFNODE("Number", "value", {
                $documentation: "A number literal",
                $propdoc: {
                    value: "[number] the numeric value"
                }
            }, AST_Constant),
            AST_RegExp = DEFNODE("RegExp", "value", {
                $documentation: "A regexp literal",
                $propdoc: {
                    value: "[RegExp] the actual regexp"
                }
            }, AST_Constant),
            AST_Atom = DEFNODE("Atom", null, {
                $documentation: "Base class for atoms"
            }, AST_Constant),
            AST_Null = DEFNODE("Null", null, {
                $documentation: "The `null` atom",
                value: null
            }, AST_Atom),
            AST_NaN = DEFNODE("NaN", null, {
                $documentation: "The impossible value",
                value: 0 / 0
            }, AST_Atom),
            AST_Undefined = DEFNODE("Undefined", null, {
                $documentation: "The `undefined` value",
                value: void 0
            }, AST_Atom),
            AST_Hole = DEFNODE("Hole", null, {
                $documentation: "A hole in an array",
                value: void 0
            }, AST_Atom),
            AST_Infinity = DEFNODE("Infinity", null, {
                $documentation: "The `Infinity` value",
                value: 1 / 0
            }, AST_Atom),
            AST_Boolean = DEFNODE("Boolean", null, {
                $documentation: "Base class for booleans"
            }, AST_Atom),
            AST_False = DEFNODE("False", null, {
                $documentation: "The `false` atom",
                value: !1
            }, AST_Boolean),
            AST_True = DEFNODE("True", null, {
                $documentation: "The `true` atom",
                value: !0
            }, AST_Boolean);
        TreeWalker.prototype = {
            _visit: function(node, descend) {
                this.stack.push(node);
                var ret = this.visit(node, descend ? function() {
                    descend.call(node)
                } : noop);
                return !ret && descend && descend.call(node), this.stack.pop(), ret
            },
            parent: function(n) {
                return this.stack[this.stack.length - 2 - (n || 0)]
            },
            push: function(node) {
                this.stack.push(node)
            },
            pop: function() {
                return this.stack.pop()
            },
            self: function() {
                return this.stack[this.stack.length - 1]
            },
            find_parent: function(type) {
                for (var stack = this.stack, i = stack.length; --i >= 0;) {
                    var x = stack[i];
                    if (x instanceof type) return x
                }
            },
            has_directive: function(type) {
                return this.find_parent(AST_Scope).has_directive(type)
            },
            in_boolean_context: function() {
                for (var stack = this.stack, i = stack.length, self = stack[--i]; i > 0;) {
                    var p = stack[--i];
                    if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_For && p.condition === self || p instanceof AST_UnaryPrefix && "!" == p.operator && p.expression === self) return !0;
                    if (!(p instanceof AST_Binary) || "&&" != p.operator && "||" != p.operator) return !1;
                    self = p
                }
            },
            loopcontrol_target: function(label) {
                var stack = this.stack;
                if (label)
                    for (var i = stack.length; --i >= 0;) {
                        var x = stack[i];
                        if (x instanceof AST_LabeledStatement && x.label.name == label.name) return x.body
                    } else
                        for (var i = stack.length; --i >= 0;) {
                            var x = stack[i];
                            if (x instanceof AST_Switch || x instanceof AST_IterationStatement) return x
                        }
            }
        };
        var KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with",
            KEYWORDS_ATOM = "false null true",
            RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile " + KEYWORDS_ATOM + " " + KEYWORDS,
            KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
        KEYWORDS = makePredicate(KEYWORDS), RESERVED_WORDS = makePredicate(RESERVED_WORDS), KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION), KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
        var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^")),
            RE_HEX_NUMBER = /^0x[0-9a-f]+$/i,
            RE_OCT_NUMBER = /^0[0-7]+$/,
            RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i,
            OPERATORS = makePredicate(["in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||"]),
            WHITESPACE_CHARS = makePredicate(characters("  \n\r \f​᠎             　")),
            PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:")),
            PUNC_CHARS = makePredicate(characters("[]{}(),;:")),
            REGEXP_MODIFIERS = makePredicate(characters("gmsiy")),
            UNICODE = {
                letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
                non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
                space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
                connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
            };
        JS_Parse_Error.prototype.toString = function() {
            return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")\n\n" + this.stack
        };
        var EX_EOF = {},
            UNARY_PREFIX = makePredicate(["typeof", "void", "delete", "--", "++", "!", "~", "-", "+"]),
            UNARY_POSTFIX = makePredicate(["--", "++"]),
            ASSIGNMENT = makePredicate(["=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]),
            PRECEDENCE = function(a, ret) {
                for (var i = 0, n = 1; i < a.length; ++i, ++n)
                    for (var b = a[i], j = 0; j < b.length; ++j) ret[b[j]] = n;
                return ret
            }([
                ["||"],
                ["&&"],
                ["|"],
                ["^"],
                ["&"],
                ["==", "===", "!=", "!=="],
                ["<", ">", "<=", ">=", "in", "instanceof"],
                [">>", "<<", ">>>"],
                ["+", "-"],
                ["*", "/", "%"]
            ], {}),
            STATEMENTS_WITH_LABELS = array_to_hash(["for", "do", "while", "switch"]),
            ATOMIC_START_TOKEN = array_to_hash(["atom", "num", "string", "regexp", "name"]);
        TreeTransformer.prototype = new TreeWalker,
            function(undefined) {
                function _(node, descend) {
                    node.DEFMETHOD("transform", function(tw, in_list) {
                        var x, y;
                        return tw.push(this), tw.before && (x = tw.before(this, descend, in_list)), x === undefined && (tw.after ? (tw.stack[tw.stack.length - 1] = x = this.clone(), descend(x, tw), y = tw.after(x, in_list), y !== undefined && (x = y)) : (x = this, descend(x, tw))), tw.pop(), x
                    })
                }

                function do_list(list, tw) {
                    return MAP(list, function(node) {
                        return node.transform(tw, !0)
                    })
                }
                _(AST_Node, noop), _(AST_LabeledStatement, function(self, tw) {
                    self.label = self.label.transform(tw), self.body = self.body.transform(tw)
                }), _(AST_SimpleStatement, function(self, tw) {
                    self.body = self.body.transform(tw)
                }), _(AST_Block, function(self, tw) {
                    self.body = do_list(self.body, tw)
                }), _(AST_DWLoop, function(self, tw) {
                    self.condition = self.condition.transform(tw), self.body = self.body.transform(tw)
                }), _(AST_For, function(self, tw) {
                    self.init && (self.init = self.init.transform(tw)), self.condition && (self.condition = self.condition.transform(tw)), self.step && (self.step = self.step.transform(tw)), self.body = self.body.transform(tw)
                }), _(AST_ForIn, function(self, tw) {
                    self.init = self.init.transform(tw), self.object = self.object.transform(tw), self.body = self.body.transform(tw)
                }), _(AST_With, function(self, tw) {
                    self.expression = self.expression.transform(tw), self.body = self.body.transform(tw)
                }), _(AST_Exit, function(self, tw) {
                    self.value && (self.value = self.value.transform(tw))
                }), _(AST_LoopControl, function(self, tw) {
                    self.label && (self.label = self.label.transform(tw))
                }), _(AST_If, function(self, tw) {
                    self.condition = self.condition.transform(tw), self.body = self.body.transform(tw), self.alternative && (self.alternative = self.alternative.transform(tw))
                }), _(AST_Switch, function(self, tw) {
                    self.expression = self.expression.transform(tw), self.body = do_list(self.body, tw)
                }), _(AST_Case, function(self, tw) {
                    self.expression = self.expression.transform(tw), self.body = do_list(self.body, tw)
                }), _(AST_Try, function(self, tw) {
                    self.body = do_list(self.body, tw), self.bcatch && (self.bcatch = self.bcatch.transform(tw)), self.bfinally && (self.bfinally = self.bfinally.transform(tw))
                }), _(AST_Catch, function(self, tw) {
                    self.argname = self.argname.transform(tw), self.body = do_list(self.body, tw)
                }), _(AST_Definitions, function(self, tw) {
                    self.definitions = do_list(self.definitions, tw)
                }), _(AST_VarDef, function(self, tw) {
                    self.name = self.name.transform(tw), self.value && (self.value = self.value.transform(tw))
                }), _(AST_Lambda, function(self, tw) {
                    self.name && (self.name = self.name.transform(tw)), self.argnames = do_list(self.argnames, tw), self.body = do_list(self.body, tw)
                }), _(AST_Call, function(self, tw) {
                    self.expression = self.expression.transform(tw), self.args = do_list(self.args, tw)
                }), _(AST_Seq, function(self, tw) {
                    self.car = self.car.transform(tw), self.cdr = self.cdr.transform(tw)
                }), _(AST_Dot, function(self, tw) {
                    self.expression = self.expression.transform(tw)
                }), _(AST_Sub, function(self, tw) {
                    self.expression = self.expression.transform(tw), self.property = self.property.transform(tw)
                }), _(AST_Unary, function(self, tw) {
                    self.expression = self.expression.transform(tw)
                }), _(AST_Binary, function(self, tw) {
                    self.left = self.left.transform(tw), self.right = self.right.transform(tw)
                }), _(AST_Conditional, function(self, tw) {
                    self.condition = self.condition.transform(tw), self.consequent = self.consequent.transform(tw), self.alternative = self.alternative.transform(tw)
                }), _(AST_Array, function(self, tw) {
                    self.elements = do_list(self.elements, tw)
                }), _(AST_Object, function(self, tw) {
                    self.properties = do_list(self.properties, tw)
                }), _(AST_ObjectProperty, function(self, tw) {
                    self.value = self.value.transform(tw)
                })
            }(), SymbolDef.prototype = {
                unmangleable: function(options) {
                    return this.global && !(options && options.toplevel) || this.undeclared || !(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with)
                },
                mangle: function(options) {
                    if (!this.mangled_name && !this.unmangleable(options)) {
                        var s = this.scope;
                        this.orig[0] instanceof AST_SymbolLambda && !options.screw_ie8 && (s = s.parent_scope), this.mangled_name = s.next_mangled(options)
                    }
                }
            }, AST_Toplevel.DEFMETHOD("figure_out_scope", function() {
                var self = this,
                    scope = self.parent_scope = null,
                    nesting = 0,
                    tw = new TreeWalker(function(node, descend) {
                        if (node instanceof AST_Scope) {
                            node.init_scope_vars(nesting);
                            var save_scope = node.parent_scope = scope;
                            return ++nesting, scope = node, descend(), scope = save_scope, --nesting, !0
                        }
                        if (node instanceof AST_Directive) return node.scope = scope, push_uniq(scope.directives, node.value), !0;
                        if (node instanceof AST_With)
                            for (var s = scope; s; s = s.parent_scope) s.uses_with = !0;
                        else if (node instanceof AST_Symbol && (node.scope = scope), node instanceof AST_SymbolLambda) scope.def_function(node);
                        else if (node instanceof AST_SymbolDefun)(node.scope = scope.parent_scope).def_function(node);
                        else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolConst) {
                            var def = scope.def_variable(node);
                            def.constant = node instanceof AST_SymbolConst, def.init = tw.parent().value
                        } else node instanceof AST_SymbolCatch && scope.def_variable(node)
                    });
                self.walk(tw);
                var func = null,
                    globals = self.globals = new Dictionary,
                    tw = new TreeWalker(function(node, descend) {
                        if (node instanceof AST_Lambda) {
                            var prev_func = func;
                            return func = node, descend(), func = prev_func, !0
                        }
                        if (node instanceof AST_SymbolRef) {
                            var name = node.name,
                                sym = node.scope.find_variable(name);
                            if (sym) node.thedef = sym;
                            else {
                                var g;
                                if (globals.has(name) ? g = globals.get(name) : (g = new SymbolDef(self, globals.size(), node), g.undeclared = !0, g.global = !0, globals.set(name, g)), node.thedef = g, "eval" == name && tw.parent() instanceof AST_Call)
                                    for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) s.uses_eval = !0;
                                func && "arguments" == name && (func.uses_arguments = !0)
                            }
                            return node.reference(), !0
                        }
                    });
                self.walk(tw)
            }), AST_Scope.DEFMETHOD("init_scope_vars", function(nesting) {
                this.directives = [], this.variables = new Dictionary, this.functions = new Dictionary, this.uses_with = !1, this.uses_eval = !1, this.parent_scope = null, this.enclosed = [], this.cname = -1, this.nesting = nesting
            }), AST_Scope.DEFMETHOD("strict", function() {
                return this.has_directive("use strict")
            }), AST_Lambda.DEFMETHOD("init_scope_vars", function() {
                AST_Scope.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1
            }), AST_SymbolRef.DEFMETHOD("reference", function() {
                var def = this.definition();
                def.references.push(this);
                for (var s = this.scope; s && (push_uniq(s.enclosed, def), s !== def.scope);) s = s.parent_scope;
                this.frame = this.scope.nesting - def.scope.nesting
            }), AST_Scope.DEFMETHOD("find_variable", function(name) {
                return name instanceof AST_Symbol && (name = name.name), this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name)
            }), AST_Scope.DEFMETHOD("has_directive", function(value) {
                return this.parent_scope && this.parent_scope.has_directive(value) || (this.directives.indexOf(value) >= 0 ? this : null)
            }), AST_Scope.DEFMETHOD("def_function", function(symbol) {
                this.functions.set(symbol.name, this.def_variable(symbol))
            }), AST_Scope.DEFMETHOD("def_variable", function(symbol) {
                var def;
                return this.variables.has(symbol.name) ? (def = this.variables.get(symbol.name), def.orig.push(symbol)) : (def = new SymbolDef(this, this.variables.size(), symbol), this.variables.set(symbol.name, def), def.global = !this.parent_scope), symbol.thedef = def
            }), AST_Scope.DEFMETHOD("next_mangled", function(options) {
                var ext = this.enclosed;
                out: for (;;) {
                    var m = base54(++this.cname);
                    if (is_identifier(m)) {
                        for (var i = ext.length; --i >= 0;) {
                            var sym = ext[i],
                                name = sym.mangled_name || sym.unmangleable(options) && sym.name;
                            if (m == name) continue out
                        }
                        return m
                    }
                }
            }), AST_Scope.DEFMETHOD("references", function(sym) {
                return sym instanceof AST_Symbol && (sym = sym.definition()), this.enclosed.indexOf(sym) < 0 ? null : sym
            }), AST_Symbol.DEFMETHOD("unmangleable", function(options) {
                return this.definition().unmangleable(options)
            }), AST_SymbolAccessor.DEFMETHOD("unmangleable", function() {
                return !0
            }), AST_Label.DEFMETHOD("unmangleable", function() {
                return !1
            }), AST_Symbol.DEFMETHOD("unreferenced", function() {
                return 0 == this.definition().references.length && !(this.scope.uses_eval || this.scope.uses_with)
            }), AST_Symbol.DEFMETHOD("undeclared", function() {
                return this.definition().undeclared
            }), AST_LabelRef.DEFMETHOD("undeclared", function() {
                return !1
            }), AST_Label.DEFMETHOD("undeclared", function() {
                return !1
            }), AST_Symbol.DEFMETHOD("definition", function() {
                return this.thedef
            }), AST_Symbol.DEFMETHOD("global", function() {
                return this.definition().global
            }), AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options) {
                return defaults(options, {
                    except: [],
                    eval: !1,
                    sort: !1,
                    toplevel: !1,
                    screw_ie8: !1
                })
            }), AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
                options = this._default_mangler_options(options);
                var lname = -1,
                    to_mangle = [],
                    tw = new TreeWalker(function(node, descend) {
                        if (node instanceof AST_LabeledStatement) {
                            var save_nesting = lname;
                            return descend(), lname = save_nesting, !0
                        }
                        if (node instanceof AST_Scope) {
                            var a = (tw.parent(), []);
                            return node.variables.each(function(symbol) {
                                options.except.indexOf(symbol.name) < 0 && a.push(symbol)
                            }), options.sort && a.sort(function(a, b) {
                                return b.references.length - a.references.length
                            }), to_mangle.push.apply(to_mangle, a), void 0
                        }
                        if (node instanceof AST_Label) {
                            var name;
                            do name = base54(++lname); while (!is_identifier(name));
                            return node.mangled_name = name, !0
                        }
                    });
                this.walk(tw), to_mangle.forEach(function(def) {
                    def.mangle(options)
                })
            }), AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
                options = this._default_mangler_options(options);
                var tw = new TreeWalker(function(node) {
                    node instanceof AST_Constant ? base54.consider(node.print_to_string()) : node instanceof AST_Return ? base54.consider("return") : node instanceof AST_Throw ? base54.consider("throw") : node instanceof AST_Continue ? base54.consider("continue") : node instanceof AST_Break ? base54.consider("break") : node instanceof AST_Debugger ? base54.consider("debugger") : node instanceof AST_Directive ? base54.consider(node.value) : node instanceof AST_While ? base54.consider("while") : node instanceof AST_Do ? base54.consider("do while") : node instanceof AST_If ? (base54.consider("if"), node.alternative && base54.consider("else")) : node instanceof AST_Var ? base54.consider("var") : node instanceof AST_Const ? base54.consider("const") : node instanceof AST_Lambda ? base54.consider("function") : node instanceof AST_For ? base54.consider("for") : node instanceof AST_ForIn ? base54.consider("for in") : node instanceof AST_Switch ? base54.consider("switch") : node instanceof AST_Case ? base54.consider("case") : node instanceof AST_Default ? base54.consider("default") : node instanceof AST_With ? base54.consider("with") : node instanceof AST_ObjectSetter ? base54.consider("set" + node.key) : node instanceof AST_ObjectGetter ? base54.consider("get" + node.key) : node instanceof AST_ObjectKeyVal ? base54.consider(node.key) : node instanceof AST_New ? base54.consider("new") : node instanceof AST_This ? base54.consider("this") : node instanceof AST_Try ? base54.consider("try") : node instanceof AST_Catch ? base54.consider("catch") : node instanceof AST_Finally ? base54.consider("finally") : node instanceof AST_Symbol && node.unmangleable(options) ? base54.consider(node.name) : node instanceof AST_Unary || node instanceof AST_Binary ? base54.consider(node.operator) : node instanceof AST_Dot && base54.consider(node.property)
                });
                this.walk(tw), base54.sort()
            });
        var base54 = function() {
            function reset() {
                frequency = Object.create(null), chars = string.split("").map(function(ch) {
                    return ch.charCodeAt(0)
                }), chars.forEach(function(ch) {
                    frequency[ch] = 0
                })
            }

            function base54(num) {
                var ret = "",
                    base = 54;
                do ret += String.fromCharCode(chars[num % base]), num = Math.floor(num / base), base = 64; while (num > 0);
                return ret
            }
            var chars, frequency, string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
            return base54.consider = function(str) {
                for (var i = str.length; --i >= 0;) {
                    var code = str.charCodeAt(i);
                    code in frequency && ++frequency[code]
                }
            }, base54.sort = function() {
                chars = mergeSort(chars, function(a, b) {
                    return is_digit(a) && !is_digit(b) ? 1 : is_digit(b) && !is_digit(a) ? -1 : frequency[b] - frequency[a]
                })
            }, base54.reset = reset, reset(), base54.get = function() {
                return chars
            }, base54.freq = function() {
                return frequency
            }, base54
        }();
        AST_Toplevel.DEFMETHOD("scope_warnings", function(options) {
                options = defaults(options, {
                    undeclared: !1,
                    unreferenced: !0,
                    assign_to_global: !0,
                    func_arguments: !0,
                    nested_defuns: !0,
                    eval: !0
                });
                var tw = new TreeWalker(function(node) {
                    if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared() && AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                            name: node.name,
                            file: node.start.file,
                            line: node.start.line,
                            col: node.start.col
                        }), options.assign_to_global) {
                        var sym = null;
                        node instanceof AST_Assign && node.left instanceof AST_SymbolRef ? sym = node.left : node instanceof AST_ForIn && node.init instanceof AST_SymbolRef && (sym = node.init), sym && (sym.undeclared() || sym.global() && sym.scope !== sym.definition().scope) && AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                            msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                            name: sym.name,
                            file: sym.start.file,
                            line: sym.start.line,
                            col: sym.start.col
                        })
                    }
                    options.eval && node instanceof AST_SymbolRef && node.undeclared() && "eval" == node.name && AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start), options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced() && AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                        type: node instanceof AST_Label ? "Label" : "Symbol",
                        name: node.name,
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    }), options.func_arguments && node instanceof AST_Lambda && node.uses_arguments && AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                        name: node.name ? node.name.name : "anonymous",
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    }), options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope) && AST_Node.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
                        name: node.name.name,
                        type: tw.parent().TYPE,
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    })
                });
                this.walk(tw)
            }),
            function() {
                function DEFPRINT(nodetype, generator) {
                    nodetype.DEFMETHOD("_codegen", generator)
                }

                function PARENS(nodetype, func) {
                    nodetype.DEFMETHOD("needs_parens", func)
                }

                function assign_and_conditional_paren_rules(output) {
                    var p = output.parent();
                    return p instanceof AST_Unary ? !0 : p instanceof AST_Binary && !(p instanceof AST_Assign) ? !0 : p instanceof AST_Call && p.expression === this ? !0 : p instanceof AST_Conditional && p.condition === this ? !0 : p instanceof AST_PropAccess && p.expression === this ? !0 : void 0
                }

                function display_body(body, is_toplevel, output) {
                    var last = body.length - 1;
                    body.forEach(function(stmt, i) {
                        stmt instanceof AST_EmptyStatement || (output.indent(), stmt.print(output), i == last && is_toplevel || (output.newline(), is_toplevel && output.newline()))
                    })
                }

                function print_bracketed(body, output) {
                    body.length > 0 ? output.with_block(function() {
                        display_body(body, !1, output)
                    }) : output.print("{}")
                }

                function make_then(self, output) {
                    if (output.option("bracketize")) return make_block(self.body, output), void 0;
                    if (!self.body) return output.force_semicolon();
                    if (self.body instanceof AST_Do && !output.option("screw_ie8")) return make_block(self.body, output), void 0;
                    for (var b = self.body;;)
                        if (b instanceof AST_If) {
                            if (!b.alternative) return make_block(self.body, output), void 0;
                            b = b.alternative
                        } else {
                            if (!(b instanceof AST_StatementWithBody)) break;
                            b = b.body
                        }
                    force_statement(self.body, output)
                }

                function parenthesize_for_noin(node, output, noin) {
                    if (noin) try {
                        node.walk(new TreeWalker(function(node) {
                            if (node instanceof AST_Binary && "in" == node.operator) throw output
                        })), node.print(output)
                    } catch (ex) {
                        if (ex !== output) throw ex;
                        node.print(output, !0)
                    } else node.print(output)
                }

                function force_statement(stat, output) {
                    output.option("bracketize") ? !stat || stat instanceof AST_EmptyStatement ? output.print("{}") : stat instanceof AST_BlockStatement ? stat.print(output) : output.with_block(function() {
                        output.indent(), stat.print(output), output.newline()
                    }) : !stat || stat instanceof AST_EmptyStatement ? output.force_semicolon() : stat.print(output)
                }

                function first_in_statement(output) {
                    for (var a = output.stack(), i = a.length, node = a[--i], p = a[--i]; i > 0;) {
                        if (p instanceof AST_Statement && p.body === node) return !0;
                        if (!(p instanceof AST_Seq && p.car === node || p instanceof AST_Call && p.expression === node && !(p instanceof AST_New) || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node)) return !1;
                        node = p, p = a[--i]
                    }
                }

                function no_constructor_parens(self, output) {
                    return 0 == self.args.length && !output.option("beautify")
                }

                function best_of(a) {
                    for (var best = a[0], len = best.length, i = 1; i < a.length; ++i) a[i].length < len && (best = a[i], len = best.length);
                    return best
                }

                function make_num(num) {
                    var m, str = num.toString(10),
                        a = [str.replace(/^0\./, ".").replace("e+", "e")];
                    return Math.floor(num) === num ? (num >= 0 ? a.push("0x" + num.toString(16).toLowerCase(), "0" + num.toString(8)) : a.push("-0x" + (-num).toString(16).toLowerCase(), "-0" + (-num).toString(8)), (m = /^(.*?)(0+)$/.exec(num)) && a.push(m[1] + "e" + m[2].length)) : (m = /^0?\.(0+)(.*)$/.exec(num)) && a.push(m[2] + "e-" + (m[1].length + m[2].length), str.substr(str.indexOf("."))), best_of(a)
                }

                function make_block(stmt, output) {
                    return stmt instanceof AST_BlockStatement ? (stmt.print(output), void 0) : (output.with_block(function() {
                        output.indent(), stmt.print(output), output.newline()
                    }), void 0)
                }

                function DEFMAP(nodetype, generator) {
                    nodetype.DEFMETHOD("add_source_map", function(stream) {
                        generator(this, stream)
                    })
                }

                function basic_sourcemap_gen(self, output) {
                    output.add_mapping(self.start)
                }
                AST_Node.DEFMETHOD("print", function(stream, force_parens) {
                    function doit() {
                        self.add_comments(stream), self.add_source_map(stream), generator(self, stream)
                    }
                    var self = this,
                        generator = self._codegen;
                    stream.push_node(self), force_parens || self.needs_parens(stream) ? stream.with_parens(doit) : doit(), stream.pop_node()
                }), AST_Node.DEFMETHOD("print_to_string", function(options) {
                    var s = OutputStream(options);
                    return this.print(s), s.get()
                }), AST_Node.DEFMETHOD("add_comments", function(output) {
                    var c = output.option("comments"),
                        self = this;
                    if (c) {
                        var start = self.start;
                        if (start && !start._comments_dumped) {
                            start._comments_dumped = !0;
                            var comments = start.comments_before;
                            self instanceof AST_Exit && self.value && self.value.start.comments_before.length > 0 && (comments = (comments || []).concat(self.value.start.comments_before), self.value.start.comments_before = []), c.test ? comments = comments.filter(function(comment) {
                                return c.test(comment.value)
                            }) : "function" == typeof c && (comments = comments.filter(function(comment) {
                                return c(self, comment)
                            })), comments.forEach(function(c) {
                                /comment[134]/.test(c.type) ? (output.print("//" + c.value + "\n"), output.indent()) : "comment2" == c.type && (output.print("/*" + c.value + "*/"), start.nlb ? (output.print("\n"), output.indent()) : output.space())
                            })
                        }
                    }
                }), PARENS(AST_Node, function() {
                    return !1
                }), PARENS(AST_Function, function(output) {
                    return first_in_statement(output)
                }), PARENS(AST_Object, function(output) {
                    return first_in_statement(output)
                }), PARENS(AST_Unary, function(output) {
                    var p = output.parent();
                    return p instanceof AST_PropAccess && p.expression === this
                }), PARENS(AST_Seq, function(output) {
                    var p = output.parent();
                    return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_Dot || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional
                }), PARENS(AST_Binary, function(output) {
                    var p = output.parent();
                    if (p instanceof AST_Call && p.expression === this) return !0;
                    if (p instanceof AST_Unary) return !0;
                    if (p instanceof AST_PropAccess && p.expression === this) return !0;
                    if (p instanceof AST_Binary) {
                        var po = p.operator,
                            pp = PRECEDENCE[po],
                            so = this.operator,
                            sp = PRECEDENCE[so];
                        if (pp > sp || pp == sp && this === p.right && (so != po || "*" != so && "&&" != so && "||" != so)) return !0
                    }
                }), PARENS(AST_PropAccess, function(output) {
                    var p = output.parent();
                    if (p instanceof AST_New && p.expression === this) try {
                        this.walk(new TreeWalker(function(node) {
                            if (node instanceof AST_Call) throw p
                        }))
                    } catch (ex) {
                        if (ex !== p) throw ex;
                        return !0
                    }
                }), PARENS(AST_Call, function(output) {
                    var p = output.parent();
                    return p instanceof AST_New && p.expression === this
                }), PARENS(AST_New, function(output) {
                    var p = output.parent();
                    return no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this) ? !0 : void 0
                }), PARENS(AST_Number, function(output) {
                    var p = output.parent();
                    return this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this ? !0 : void 0
                }), PARENS(AST_NaN, function(output) {
                    var p = output.parent();
                    return p instanceof AST_PropAccess && p.expression === this ? !0 : void 0
                }), PARENS(AST_Assign, assign_and_conditional_paren_rules), PARENS(AST_Conditional, assign_and_conditional_paren_rules), DEFPRINT(AST_Directive, function(self, output) {
                    output.print_string(self.value), output.semicolon()
                }), DEFPRINT(AST_Debugger, function(self, output) {
                    output.print("debugger"), output.semicolon()
                }), AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
                    force_statement(this.body, output)
                }), DEFPRINT(AST_Statement, function(self, output) {
                    self.body.print(output), output.semicolon()
                }), DEFPRINT(AST_Toplevel, function(self, output) {
                    display_body(self.body, !0, output), output.print("")
                }), DEFPRINT(AST_LabeledStatement, function(self, output) {
                    self.label.print(output), output.colon(), self.body.print(output)
                }), DEFPRINT(AST_SimpleStatement, function(self, output) {
                    self.body.print(output), output.semicolon()
                }), DEFPRINT(AST_BlockStatement, function(self, output) {
                    print_bracketed(self.body, output)
                }), DEFPRINT(AST_EmptyStatement, function(self, output) {
                    output.semicolon()
                }), DEFPRINT(AST_Do, function(self, output) {
                    output.print("do"), output.space(), self._do_print_body(output), output.space(), output.print("while"), output.space(), output.with_parens(function() {
                        self.condition.print(output)
                    }), output.semicolon()
                }), DEFPRINT(AST_While, function(self, output) {
                    output.print("while"), output.space(), output.with_parens(function() {
                        self.condition.print(output)
                    }), output.space(), self._do_print_body(output)
                }), DEFPRINT(AST_For, function(self, output) {
                    output.print("for"), output.space(), output.with_parens(function() {
                        self.init ? (self.init instanceof AST_Definitions ? self.init.print(output) : parenthesize_for_noin(self.init, output, !0), output.print(";"), output.space()) : output.print(";"), self.condition ? (self.condition.print(output), output.print(";"), output.space()) : output.print(";"), self.step && self.step.print(output)
                    }), output.space(), self._do_print_body(output)
                }), DEFPRINT(AST_ForIn, function(self, output) {
                    output.print("for"), output.space(), output.with_parens(function() {
                        self.init.print(output), output.space(), output.print("in"), output.space(), self.object.print(output)
                    }), output.space(), self._do_print_body(output)
                }), DEFPRINT(AST_With, function(self, output) {
                    output.print("with"), output.space(), output.with_parens(function() {
                        self.expression.print(output)
                    }), output.space(), self._do_print_body(output)
                }), AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
                    var self = this;
                    nokeyword || output.print("function"), self.name && (output.space(), self.name.print(output)), output.with_parens(function() {
                        self.argnames.forEach(function(arg, i) {
                            i && output.comma(), arg.print(output)
                        })
                    }), output.space(), print_bracketed(self.body, output)
                }), DEFPRINT(AST_Lambda, function(self, output) {
                    self._do_print(output)
                }), AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
                    output.print(kind), this.value && (output.space(), this.value.print(output)), output.semicolon()
                }), DEFPRINT(AST_Return, function(self, output) {
                    self._do_print(output, "return")
                }), DEFPRINT(AST_Throw, function(self, output) {
                    self._do_print(output, "throw")
                }), AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
                    output.print(kind), this.label && (output.space(), this.label.print(output)), output.semicolon()
                }), DEFPRINT(AST_Break, function(self, output) {
                    self._do_print(output, "break")
                }), DEFPRINT(AST_Continue, function(self, output) {
                    self._do_print(output, "continue")
                }), DEFPRINT(AST_If, function(self, output) {
                    output.print("if"), output.space(), output.with_parens(function() {
                        self.condition.print(output)
                    }), output.space(), self.alternative ? (make_then(self, output), output.space(), output.print("else"), output.space(), force_statement(self.alternative, output)) : self._do_print_body(output)
                }), DEFPRINT(AST_Switch, function(self, output) {
                    output.print("switch"), output.space(), output.with_parens(function() {
                        self.expression.print(output)
                    }), output.space(), self.body.length > 0 ? output.with_block(function() {
                        self.body.forEach(function(stmt, i) {
                            i && output.newline(), output.indent(!0), stmt.print(output)
                        })
                    }) : output.print("{}")
                }), AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
                    this.body.length > 0 && (output.newline(), this.body.forEach(function(stmt) {
                        output.indent(), stmt.print(output), output.newline()
                    }))
                }), DEFPRINT(AST_Default, function(self, output) {
                    output.print("default:"), self._do_print_body(output)
                }), DEFPRINT(AST_Case, function(self, output) {
                    output.print("case"), output.space(), self.expression.print(output), output.print(":"), self._do_print_body(output)
                }), DEFPRINT(AST_Try, function(self, output) {
                    output.print("try"), output.space(), print_bracketed(self.body, output), self.bcatch && (output.space(), self.bcatch.print(output)), self.bfinally && (output.space(), self.bfinally.print(output))
                }), DEFPRINT(AST_Catch, function(self, output) {
                    output.print("catch"), output.space(), output.with_parens(function() {
                        self.argname.print(output)
                    }), output.space(), print_bracketed(self.body, output)
                }), DEFPRINT(AST_Finally, function(self, output) {
                    output.print("finally"), output.space(), print_bracketed(self.body, output)
                }), AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
                    output.print(kind), output.space(), this.definitions.forEach(function(def, i) {
                        i && output.comma(), def.print(output)
                    });
                    var p = output.parent(),
                        in_for = p instanceof AST_For || p instanceof AST_ForIn,
                        avoid_semicolon = in_for && p.init === this;
                    avoid_semicolon || output.semicolon()
                }), DEFPRINT(AST_Var, function(self, output) {
                    self._do_print(output, "var")
                }), DEFPRINT(AST_Const, function(self, output) {
                    self._do_print(output, "const")
                }), DEFPRINT(AST_VarDef, function(self, output) {
                    if (self.name.print(output), self.value) {
                        output.space(), output.print("="), output.space();
                        var p = output.parent(1),
                            noin = p instanceof AST_For || p instanceof AST_ForIn;
                        parenthesize_for_noin(self.value, output, noin)
                    }
                }), DEFPRINT(AST_Call, function(self, output) {
                    self.expression.print(output), self instanceof AST_New && no_constructor_parens(self, output) || output.with_parens(function() {
                        self.args.forEach(function(expr, i) {
                            i && output.comma(), expr.print(output)
                        })
                    })
                }), DEFPRINT(AST_New, function(self, output) {
                    output.print("new"), output.space(), AST_Call.prototype._codegen(self, output)
                }), AST_Seq.DEFMETHOD("_do_print", function(output) {
                    this.car.print(output), this.cdr && (output.comma(), output.should_break() && (output.newline(), output.indent()), this.cdr.print(output))
                }), DEFPRINT(AST_Seq, function(self, output) {
                    self._do_print(output)
                }), DEFPRINT(AST_Dot, function(self, output) {
                    var expr = self.expression;
                    expr.print(output), expr instanceof AST_Number && expr.getValue() >= 0 && (/[xa-f.]/i.test(output.last()) || output.print(".")), output.print("."), output.add_mapping(self.end), output.print_name(self.property)
                }), DEFPRINT(AST_Sub, function(self, output) {
                    self.expression.print(output), output.print("["), self.property.print(output), output.print("]")
                }), DEFPRINT(AST_UnaryPrefix, function(self, output) {
                    var op = self.operator;
                    output.print(op), /^[a-z]/i.test(op) && output.space(), self.expression.print(output)
                }), DEFPRINT(AST_UnaryPostfix, function(self, output) {
                    self.expression.print(output), output.print(self.operator)
                }), DEFPRINT(AST_Binary, function(self, output) {
                    self.left.print(output), output.space(), output.print(self.operator), "<" == self.operator && self.right instanceof AST_UnaryPrefix && "!" == self.right.operator && self.right.expression instanceof AST_UnaryPrefix && "--" == self.right.expression.operator ? output.print(" ") : output.space(), self.right.print(output)
                }), DEFPRINT(AST_Conditional, function(self, output) {
                    self.condition.print(output), output.space(), output.print("?"), output.space(), self.consequent.print(output), output.space(), output.colon(), self.alternative.print(output)
                }), DEFPRINT(AST_Array, function(self, output) {
                    output.with_square(function() {
                        var a = self.elements,
                            len = a.length;
                        len > 0 && output.space(), a.forEach(function(exp, i) {
                            i && output.comma(), exp.print(output), i === len - 1 && exp instanceof AST_Hole && output.comma()
                        }), len > 0 && output.space()
                    })
                }), DEFPRINT(AST_Object, function(self, output) {
                    self.properties.length > 0 ? output.with_block(function() {
                        self.properties.forEach(function(prop, i) {
                            i && (output.print(","), output.newline()), output.indent(), prop.print(output)
                        }), output.newline()
                    }) : output.print("{}")
                }), DEFPRINT(AST_ObjectKeyVal, function(self, output) {
                    var key = self.key;
                    output.option("quote_keys") ? output.print_string(key + "") : ("number" == typeof key || !output.option("beautify") && +key + "" == key) && parseFloat(key) >= 0 ? output.print(make_num(key)) : (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) ? output.print_name(key) : output.print_string(key), output.colon(), self.value.print(output)
                }), DEFPRINT(AST_ObjectSetter, function(self, output) {
                    output.print("set"), self.value._do_print(output, !0)
                }), DEFPRINT(AST_ObjectGetter, function(self, output) {
                    output.print("get"), self.value._do_print(output, !0)
                }), DEFPRINT(AST_Symbol, function(self, output) {
                    var def = self.definition();
                    output.print_name(def ? def.mangled_name || def.name : self.name)
                }), DEFPRINT(AST_Undefined, function(self, output) {
                    output.print("void 0")
                }), DEFPRINT(AST_Hole, noop), DEFPRINT(AST_Infinity, function(self, output) {
                    output.print("1/0")
                }), DEFPRINT(AST_NaN, function(self, output) {
                    output.print("0/0")
                }), DEFPRINT(AST_This, function(self, output) {
                    output.print("this")
                }), DEFPRINT(AST_Constant, function(self, output) {
                    output.print(self.getValue())
                }), DEFPRINT(AST_String, function(self, output) {
                    output.print_string(self.getValue())
                }), DEFPRINT(AST_Number, function(self, output) {
                    output.print(make_num(self.getValue()))
                }), DEFPRINT(AST_RegExp, function(self, output) {
                    var str = self.getValue().toString();
                    output.option("ascii_only") && (str = output.to_ascii(str)), output.print(str);
                    var p = output.parent();
                    p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self && output.print(" ")
                }), DEFMAP(AST_Node, noop), DEFMAP(AST_Directive, basic_sourcemap_gen), DEFMAP(AST_Debugger, basic_sourcemap_gen), DEFMAP(AST_Symbol, basic_sourcemap_gen), DEFMAP(AST_Jump, basic_sourcemap_gen), DEFMAP(AST_StatementWithBody, basic_sourcemap_gen), DEFMAP(AST_LabeledStatement, noop), DEFMAP(AST_Lambda, basic_sourcemap_gen), DEFMAP(AST_Switch, basic_sourcemap_gen), DEFMAP(AST_SwitchBranch, basic_sourcemap_gen), DEFMAP(AST_BlockStatement, basic_sourcemap_gen), DEFMAP(AST_Toplevel, noop), DEFMAP(AST_New, basic_sourcemap_gen), DEFMAP(AST_Try, basic_sourcemap_gen), DEFMAP(AST_Catch, basic_sourcemap_gen), DEFMAP(AST_Finally, basic_sourcemap_gen), DEFMAP(AST_Definitions, basic_sourcemap_gen), DEFMAP(AST_Constant, basic_sourcemap_gen), DEFMAP(AST_ObjectProperty, function(self, output) {
                    output.add_mapping(self.start, self.key)
                })
            }(), Compressor.prototype = new TreeTransformer, merge(Compressor.prototype, {
                option: function(key) {
                    return this.options[key]
                },
                warn: function() {
                    this.options.warnings && AST_Node.warn.apply(AST_Node, arguments)
                },
                before: function(node, descend) {
                    return node._squeezed ? node : (node instanceof AST_Scope && (node.drop_unused(this), node = node.hoist_declarations(this)), descend(node, this), node = node.optimize(this), node instanceof AST_Scope && node.drop_unused(this), node._squeezed = !0, node)
                }
            }),
            function() {
                function OPT(node, optimizer) {
                    node.DEFMETHOD("optimize", function(compressor) {
                        var self = this;
                        if (self._optimized) return self;
                        var opt = optimizer(self, compressor);
                        return opt._optimized = !0, opt === self ? opt : opt.transform(compressor)
                    })
                }

                function make_node(ctor, orig, props) {
                    return props || (props = {}), orig && (props.start || (props.start = orig.start), props.end || (props.end = orig.end)), new ctor(props)
                }

                function make_node_from_constant(compressor, val, orig) {
                    if (val instanceof AST_Node) return val.transform(compressor);
                    switch (typeof val) {
                        case "string":
                            return make_node(AST_String, orig, {
                                value: val
                            }).optimize(compressor);
                        case "number":
                            return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                                value: val
                            }).optimize(compressor);
                        case "boolean":
                            return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
                        case "undefined":
                            return make_node(AST_Undefined, orig).optimize(compressor);
                        default:
                            if (null === val) return make_node(AST_Null, orig).optimize(compressor);
                            if (val instanceof RegExp) return make_node(AST_RegExp, orig).optimize(compressor);
                            throw new Error(string_template("Can't handle constant of type: {type}", {
                                type: typeof val
                            }))
                    }
                }

                function as_statement_array(thing) {
                    if (null === thing) return [];
                    if (thing instanceof AST_BlockStatement) return thing.body;
                    if (thing instanceof AST_EmptyStatement) return [];
                    if (thing instanceof AST_Statement) return [thing];
                    throw new Error("Can't convert thing to statement array")
                }

                function is_empty(thing) {
                    return null === thing ? !0 : thing instanceof AST_EmptyStatement ? !0 : thing instanceof AST_BlockStatement ? 0 == thing.body.length : !1
                }

                function loop_body(x) {
                    return x instanceof AST_Switch ? x : x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop ? x.body instanceof AST_BlockStatement ? x.body : x : x
                }

                function tighten_body(statements, compressor) {
                    function eliminate_spurious_blocks(statements) {
                        var seen_dirs = [];
                        return statements.reduce(function(a, stat) {
                            return stat instanceof AST_BlockStatement ? (CHANGED = !0, a.push.apply(a, eliminate_spurious_blocks(stat.body))) : stat instanceof AST_EmptyStatement ? CHANGED = !0 : stat instanceof AST_Directive ? seen_dirs.indexOf(stat.value) < 0 ? (a.push(stat), seen_dirs.push(stat.value)) : CHANGED = !0 : a.push(stat), a
                        }, [])
                    }

                    function handle_if_return(statements, compressor) {
                        var self = compressor.self(),
                            in_lambda = self instanceof AST_Lambda,
                            ret = [];
                        loop: for (var i = statements.length; --i >= 0;) {
                            var stat = statements[i];
                            switch (!0) {
                                case in_lambda && stat instanceof AST_Return && !stat.value && 0 == ret.length:
                                    CHANGED = !0;
                                    continue loop;
                                case stat instanceof AST_If:
                                    if (stat.body instanceof AST_Return) {
                                        if ((in_lambda && 0 == ret.length || ret[0] instanceof AST_Return && !ret[0].value) && !stat.body.value && !stat.alternative) {
                                            CHANGED = !0;
                                            var cond = make_node(AST_SimpleStatement, stat.condition, {
                                                body: stat.condition
                                            });
                                            ret.unshift(cond);
                                            continue loop
                                        }
                                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                                            CHANGED = !0, stat = stat.clone(), stat.alternative = ret[0], ret[0] = stat.transform(compressor);
                                            continue loop
                                        }
                                        if ((0 == ret.length || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                                            CHANGED = !0, stat = stat.clone(), stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                                value: make_node(AST_Undefined, stat)
                                            }), ret[0] = stat.transform(compressor);
                                            continue loop
                                        }
                                        if (!stat.body.value && in_lambda) {
                                            CHANGED = !0, stat = stat.clone(), stat.condition = stat.condition.negate(compressor), stat.body = make_node(AST_BlockStatement, stat, {
                                                body: as_statement_array(stat.alternative).concat(ret)
                                            }), stat.alternative = null, ret = [stat.transform(compressor)];
                                            continue loop
                                        }
                                        if (1 == ret.length && in_lambda && ret[0] instanceof AST_SimpleStatement && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                                            CHANGED = !0, ret.push(make_node(AST_Return, ret[0], {
                                                value: make_node(AST_Undefined, ret[0])
                                            }).transform(compressor)), ret = as_statement_array(stat.alternative).concat(ret), ret.unshift(stat);
                                            continue loop
                                        }
                                    }
                                    var ab = aborts(stat.body),
                                        lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                                    if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                        ab.label && remove(ab.label.thedef.references, ab), CHANGED = !0;
                                        var body = as_statement_array(stat.body).slice(0, -1);
                                        stat = stat.clone(), stat.condition = stat.condition.negate(compressor), stat.body = make_node(AST_BlockStatement, stat, {
                                            body: ret
                                        }), stat.alternative = make_node(AST_BlockStatement, stat, {
                                            body: body
                                        }), ret = [stat.transform(compressor)];
                                        continue loop
                                    }
                                    var ab = aborts(stat.alternative),
                                        lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                                    if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                        ab.label && remove(ab.label.thedef.references, ab), CHANGED = !0, stat = stat.clone(), stat.body = make_node(AST_BlockStatement, stat.body, {
                                            body: as_statement_array(stat.body).concat(ret)
                                        }), stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                                            body: as_statement_array(stat.alternative).slice(0, -1)
                                        }), ret = [stat.transform(compressor)];
                                        continue loop
                                    }
                                    ret.unshift(stat);
                                    break;
                                default:
                                    ret.unshift(stat)
                            }
                        }
                        return ret
                    }

                    function eliminate_dead_code(statements, compressor) {
                        var has_quit = !1,
                            orig = statements.length,
                            self = compressor.self();
                        return statements = statements.reduce(function(a, stat) {
                            if (has_quit) extract_declarations_from_unreachable_code(compressor, stat, a);
                            else {
                                if (stat instanceof AST_LoopControl) {
                                    var lct = compressor.loopcontrol_target(stat.label);
                                    stat instanceof AST_Break && lct instanceof AST_BlockStatement && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self ? stat.label && remove(stat.label.thedef.references, stat) : a.push(stat)
                                } else a.push(stat);
                                aborts(stat) && (has_quit = !0)
                            }
                            return a
                        }, []), CHANGED = statements.length != orig, statements
                    }

                    function sequencesize(statements, compressor) {
                        function push_seq() {
                            seq = AST_Seq.from_array(seq), seq && ret.push(make_node(AST_SimpleStatement, seq, {
                                body: seq
                            })), seq = []
                        }
                        if (statements.length < 2) return statements;
                        var seq = [],
                            ret = [];
                        return statements.forEach(function(stat) {
                            stat instanceof AST_SimpleStatement ? seq.push(stat.body) : (push_seq(), ret.push(stat))
                        }), push_seq(), ret = sequencesize_2(ret, compressor), CHANGED = ret.length != statements.length, ret
                    }

                    function sequencesize_2(statements, compressor) {
                        function cons_seq(right) {
                            ret.pop();
                            var left = prev.body;
                            return left instanceof AST_Seq ? left.add(right) : left = AST_Seq.cons(left, right), left.transform(compressor)
                        }
                        var ret = [],
                            prev = null;
                        return statements.forEach(function(stat) {
                            if (prev)
                                if (stat instanceof AST_For) {
                                    var opera = {};
                                    try {
                                        prev.body.walk(new TreeWalker(function(node) {
                                            if (node instanceof AST_Binary && "in" == node.operator) throw opera
                                        })), !stat.init || stat.init instanceof AST_Definitions ? stat.init || (stat.init = prev.body, ret.pop()) : stat.init = cons_seq(stat.init)
                                    } catch (ex) {
                                        if (ex !== opera) throw ex
                                    }
                                } else stat instanceof AST_If ? stat.condition = cons_seq(stat.condition) : stat instanceof AST_With ? stat.expression = cons_seq(stat.expression) : stat instanceof AST_Exit && stat.value ? stat.value = cons_seq(stat.value) : stat instanceof AST_Exit ? stat.value = cons_seq(make_node(AST_Undefined, stat)) : stat instanceof AST_Switch && (stat.expression = cons_seq(stat.expression));
                            ret.push(stat), prev = stat instanceof AST_SimpleStatement ? stat : null
                        }), ret
                    }

                    function join_consecutive_vars(statements) {
                        var prev = null;
                        return statements.reduce(function(a, stat) {
                            return stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE ? (prev.definitions = prev.definitions.concat(stat.definitions), CHANGED = !0) : stat instanceof AST_For && prev instanceof AST_Definitions && (!stat.init || stat.init.TYPE == prev.TYPE) ? (CHANGED = !0, a.pop(), stat.init ? stat.init.definitions = prev.definitions.concat(stat.init.definitions) : stat.init = prev, a.push(stat), prev = stat) : (prev = stat, a.push(stat)), a
                        }, [])
                    }

                    function negate_iifes(statements) {
                        statements.forEach(function(stat) {
                            stat instanceof AST_SimpleStatement && (stat.body = function transform(thing) {
                                return thing.transform(new TreeTransformer(function(node) {
                                    if (node instanceof AST_Call && node.expression instanceof AST_Function) return make_node(AST_UnaryPrefix, node, {
                                        operator: "!",
                                        expression: node
                                    });
                                    if (node instanceof AST_Call) node.expression = transform(node.expression);
                                    else if (node instanceof AST_Seq) node.car = transform(node.car);
                                    else if (node instanceof AST_Conditional) {
                                        var expr = transform(node.condition);
                                        if (expr !== node.condition) {
                                            node.condition = expr;
                                            var tmp = node.consequent;
                                            node.consequent = node.alternative, node.alternative = tmp
                                        }
                                    }
                                    return node
                                }))
                            }(stat.body))
                        })
                    }
                    var CHANGED;
                    do CHANGED = !1, statements = eliminate_spurious_blocks(statements), compressor.option("dead_code") && (statements = eliminate_dead_code(statements, compressor)), compressor.option("if_return") && (statements = handle_if_return(statements, compressor)), compressor.option("sequences") && (statements = sequencesize(statements, compressor)), compressor.option("join_vars") && (statements = join_consecutive_vars(statements, compressor)); while (CHANGED);
                    return compressor.option("negate_iife") && negate_iifes(statements, compressor), statements
                }

                function extract_declarations_from_unreachable_code(compressor, stat, target) {
                    compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start), stat.walk(new TreeWalker(function(node) {
                        return node instanceof AST_Definitions ? (compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start), node.remove_initializers(), target.push(node), !0) : node instanceof AST_Defun ? (target.push(node), !0) : node instanceof AST_Scope ? !0 : void 0
                    }))
                }

                function best_of(ast1, ast2) {
                    return ast1.print_to_string().length > ast2.print_to_string().length ? ast2 : ast1
                }

                function aborts(thing) {
                    return thing && thing.aborts()
                }

                function if_break_in_loop(self, compressor) {
                    function drop_it(rest) {
                        rest = as_statement_array(rest), self.body instanceof AST_BlockStatement ? (self.body = self.body.clone(), self.body.body = rest.concat(self.body.body.slice(1)), self.body = self.body.transform(compressor)) : self.body = make_node(AST_BlockStatement, self.body, {
                            body: rest
                        }).transform(compressor), if_break_in_loop(self, compressor)
                    }
                    var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
                    first instanceof AST_If && (first.body instanceof AST_Break && compressor.loopcontrol_target(first.body.label) === self ? (self.condition = self.condition ? make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition.negate(compressor)
                    }) : first.condition.negate(compressor), drop_it(first.alternative)) : first.alternative instanceof AST_Break && compressor.loopcontrol_target(first.alternative.label) === self && (self.condition = self.condition ? make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition
                    }) : first.condition, drop_it(first.body)))
                }

                function literals_in_boolean_context(self, compressor) {
                    return compressor.option("booleans") && compressor.in_boolean_context() ? make_node(AST_True, self) : self
                }
                OPT(AST_Node, function(self) {
                        return self
                    }), AST_Node.DEFMETHOD("equivalent_to", function(node) {
                        return this.print_to_string() == node.print_to_string()
                    }),
                    function(def) {
                        var unary_bool = ["!", "delete"],
                            binary_bool = ["in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">"];
                        def(AST_Node, function() {
                            return !1
                        }), def(AST_UnaryPrefix, function() {
                            return member(this.operator, unary_bool)
                        }), def(AST_Binary, function() {
                            return member(this.operator, binary_bool) || ("&&" == this.operator || "||" == this.operator) && this.left.is_boolean() && this.right.is_boolean()
                        }), def(AST_Conditional, function() {
                            return this.consequent.is_boolean() && this.alternative.is_boolean()
                        }), def(AST_Assign, function() {
                            return "=" == this.operator && this.right.is_boolean()
                        }), def(AST_Seq, function() {
                            return this.cdr.is_boolean()
                        }), def(AST_True, function() {
                            return !0
                        }), def(AST_False, function() {
                            return !0
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("is_boolean", func)
                    }),
                    function(def) {
                        def(AST_Node, function() {
                            return !1
                        }), def(AST_String, function() {
                            return !0
                        }), def(AST_UnaryPrefix, function() {
                            return "typeof" == this.operator
                        }), def(AST_Binary, function(compressor) {
                            return "+" == this.operator && (this.left.is_string(compressor) || this.right.is_string(compressor))
                        }), def(AST_Assign, function(compressor) {
                            return ("=" == this.operator || "+=" == this.operator) && this.right.is_string(compressor)
                        }), def(AST_Seq, function(compressor) {
                            return this.cdr.is_string(compressor)
                        }), def(AST_Conditional, function(compressor) {
                            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor)
                        }), def(AST_Call, function(compressor) {
                            return compressor.option("unsafe") && this.expression instanceof AST_SymbolRef && "String" == this.expression.name && this.expression.undeclared()
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("is_string", func)
                    }),
                    function(def) {
                        function ev(node, compressor) {
                            if (!compressor) throw new Error("Compressor must be passed");
                            return node._eval(compressor)
                        }
                        AST_Node.DEFMETHOD("evaluate", function(compressor) {
                            if (!compressor.option("evaluate")) return [this];
                            try {
                                var val = this._eval(compressor);
                                return [best_of(make_node_from_constant(compressor, val, this), this), val]
                            } catch (ex) {
                                if (ex !== def) throw ex;
                                return [this]
                            }
                        }), def(AST_Statement, function() {
                            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start))
                        }), def(AST_Function, function() {
                            throw def
                        }), def(AST_Node, function() {
                            throw def
                        }), def(AST_Constant, function() {
                            return this.getValue()
                        }), def(AST_UnaryPrefix, function(compressor) {
                            var e = this.expression;
                            switch (this.operator) {
                                case "!":
                                    return !ev(e, compressor);
                                case "typeof":
                                    if (e instanceof AST_Function) return "function";
                                    if (e = ev(e, compressor), e instanceof RegExp) throw def;
                                    return typeof e;
                                case "void":
                                    return void ev(e, compressor);
                                case "~":
                                    return ~ev(e, compressor);
                                case "-":
                                    if (e = ev(e, compressor), 0 === e) throw def;
                                    return -e;
                                case "+":
                                    return +ev(e, compressor)
                            }
                            throw def
                        }), def(AST_Binary, function(c) {
                            var left = this.left,
                                right = this.right;
                            switch (this.operator) {
                                case "&&":
                                    return ev(left, c) && ev(right, c);
                                case "||":
                                    return ev(left, c) || ev(right, c);
                                case "|":
                                    return ev(left, c) | ev(right, c);
                                case "&":
                                    return ev(left, c) & ev(right, c);
                                case "^":
                                    return ev(left, c) ^ ev(right, c);
                                case "+":
                                    return ev(left, c) + ev(right, c);
                                case "*":
                                    return ev(left, c) * ev(right, c);
                                case "/":
                                    return ev(left, c) / ev(right, c);
                                case "%":
                                    return ev(left, c) % ev(right, c);
                                case "-":
                                    return ev(left, c) - ev(right, c);
                                case "<<":
                                    return ev(left, c) << ev(right, c);
                                case ">>":
                                    return ev(left, c) >> ev(right, c);
                                case ">>>":
                                    return ev(left, c) >>> ev(right, c);
                                case "==":
                                    return ev(left, c) == ev(right, c);
                                case "===":
                                    return ev(left, c) === ev(right, c);
                                case "!=":
                                    return ev(left, c) != ev(right, c);
                                case "!==":
                                    return ev(left, c) !== ev(right, c);
                                case "<":
                                    return ev(left, c) < ev(right, c);
                                case "<=":
                                    return ev(left, c) <= ev(right, c);
                                case ">":
                                    return ev(left, c) > ev(right, c);
                                case ">=":
                                    return ev(left, c) >= ev(right, c);
                                case "in":
                                    return ev(left, c) in ev(right, c);
                                case "instanceof":
                                    return ev(left, c) instanceof ev(right, c)
                            }
                            throw def
                        }), def(AST_Conditional, function(compressor) {
                            return ev(this.condition, compressor) ? ev(this.consequent, compressor) : ev(this.alternative, compressor)
                        }), def(AST_SymbolRef, function(compressor) {
                            var d = this.definition();
                            if (d && d.constant && d.init) return ev(d.init, compressor);
                            throw def
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("_eval", func)
                    }),
                    function(def) {
                        function basic_negation(exp) {
                            return make_node(AST_UnaryPrefix, exp, {
                                operator: "!",
                                expression: exp
                            })
                        }
                        def(AST_Node, function() {
                            return basic_negation(this)
                        }), def(AST_Statement, function() {
                            throw new Error("Cannot negate a statement")
                        }), def(AST_Function, function() {
                            return basic_negation(this)
                        }), def(AST_UnaryPrefix, function() {
                            return "!" == this.operator ? this.expression : basic_negation(this)
                        }), def(AST_Seq, function(compressor) {
                            var self = this.clone();
                            return self.cdr = self.cdr.negate(compressor), self
                        }), def(AST_Conditional, function(compressor) {
                            var self = this.clone();
                            return self.consequent = self.consequent.negate(compressor), self.alternative = self.alternative.negate(compressor), best_of(basic_negation(this), self)
                        }), def(AST_Binary, function(compressor) {
                            var self = this.clone(),
                                op = this.operator;
                            if (compressor.option("unsafe_comps")) switch (op) {
                                case "<=":
                                    return self.operator = ">", self;
                                case "<":
                                    return self.operator = ">=", self;
                                case ">=":
                                    return self.operator = "<", self;
                                case ">":
                                    return self.operator = "<=", self
                            }
                            switch (op) {
                                case "==":
                                    return self.operator = "!=", self;
                                case "!=":
                                    return self.operator = "==", self;
                                case "===":
                                    return self.operator = "!==", self;
                                case "!==":
                                    return self.operator = "===", self;
                                case "&&":
                                    return self.operator = "||", self.left = self.left.negate(compressor), self.right = self.right.negate(compressor), best_of(basic_negation(this), self);
                                case "||":
                                    return self.operator = "&&", self.left = self.left.negate(compressor), self.right = self.right.negate(compressor), best_of(basic_negation(this), self)
                            }
                            return basic_negation(this)
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("negate", function(compressor) {
                            return func.call(this, compressor)
                        })
                    }),
                    function(def) {
                        def(AST_Node, function() {
                            return !0
                        }), def(AST_EmptyStatement, function() {
                            return !1
                        }), def(AST_Constant, function() {
                            return !1
                        }), def(AST_This, function() {
                            return !1
                        }), def(AST_Call, function(compressor) {
                            var pure = compressor.option("pure_funcs");
                            return pure ? pure.indexOf(this.expression.print_to_string()) < 0 : !0
                        }), def(AST_Block, function(compressor) {
                            for (var i = this.body.length; --i >= 0;)
                                if (this.body[i].has_side_effects(compressor)) return !0;
                            return !1
                        }), def(AST_SimpleStatement, function(compressor) {
                            return this.body.has_side_effects(compressor)
                        }), def(AST_Defun, function() {
                            return !0
                        }), def(AST_Function, function() {
                            return !1
                        }), def(AST_Binary, function(compressor) {
                            return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor)
                        }), def(AST_Assign, function() {
                            return !0
                        }), def(AST_Conditional, function(compressor) {
                            return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor)
                        }), def(AST_Unary, function(compressor) {
                            return "delete" == this.operator || "++" == this.operator || "--" == this.operator || this.expression.has_side_effects(compressor)
                        }), def(AST_SymbolRef, function() {
                            return !1
                        }), def(AST_Object, function(compressor) {
                            for (var i = this.properties.length; --i >= 0;)
                                if (this.properties[i].has_side_effects(compressor)) return !0;
                            return !1
                        }), def(AST_ObjectProperty, function(compressor) {
                            return this.value.has_side_effects(compressor)
                        }), def(AST_Array, function(compressor) {
                            for (var i = this.elements.length; --i >= 0;)
                                if (this.elements[i].has_side_effects(compressor)) return !0;
                            return !1
                        }), def(AST_Dot, function(compressor) {
                            return compressor.option("pure_getters") ? this.expression.has_side_effects(compressor) : !0
                        }), def(AST_Sub, function(compressor) {
                            return compressor.option("pure_getters") ? this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor) : !0
                        }), def(AST_PropAccess, function(compressor) {
                            return !compressor.option("pure_getters")
                        }), def(AST_Seq, function(compressor) {
                            return this.car.has_side_effects(compressor) || this.cdr.has_side_effects(compressor)
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("has_side_effects", func)
                    }),
                    function(def) {
                        function block_aborts() {
                            var n = this.body.length;
                            return n > 0 && aborts(this.body[n - 1])
                        }
                        def(AST_Statement, function() {
                            return null
                        }), def(AST_Jump, function() {
                            return this
                        }), def(AST_BlockStatement, block_aborts), def(AST_SwitchBranch, block_aborts), def(AST_If, function() {
                            return this.alternative && aborts(this.body) && aborts(this.alternative)
                        })
                    }(function(node, func) {
                        node.DEFMETHOD("aborts", func)
                    }), OPT(AST_Directive, function(self) {
                        return self.scope.has_directive(self.value) !== self.scope ? make_node(AST_EmptyStatement, self) : self
                    }), OPT(AST_Debugger, function(self, compressor) {
                        return compressor.option("drop_debugger") ? make_node(AST_EmptyStatement, self) : self
                    }), OPT(AST_LabeledStatement, function(self, compressor) {
                        return self.body instanceof AST_Break && compressor.loopcontrol_target(self.body.label) === self.body ? make_node(AST_EmptyStatement, self) : 0 == self.label.references.length ? self.body : self
                    }), OPT(AST_Block, function(self, compressor) {
                        return self.body = tighten_body(self.body, compressor), self
                    }), OPT(AST_BlockStatement, function(self, compressor) {
                        switch (self.body = tighten_body(self.body, compressor), self.body.length) {
                            case 1:
                                return self.body[0];
                            case 0:
                                return make_node(AST_EmptyStatement, self)
                        }
                        return self
                    }), AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
                        var self = this;
                        if (compressor.option("unused") && !(self instanceof AST_Toplevel) && !self.uses_eval) {
                            var in_use = [],
                                initializations = new Dictionary,
                                scope = this,
                                tw = new TreeWalker(function(node, descend) {
                                    if (node !== self) {
                                        if (node instanceof AST_Defun) return initializations.add(node.name.name, node), !0;
                                        if (node instanceof AST_Definitions && scope === self) return node.definitions.forEach(function(def) {
                                            def.value && (initializations.add(def.name.name, def.value), def.value.has_side_effects(compressor) && def.value.walk(tw))
                                        }), !0;
                                        if (node instanceof AST_SymbolRef) return push_uniq(in_use, node.definition()), !0;
                                        if (node instanceof AST_Scope) {
                                            var save_scope = scope;
                                            return scope = node, descend(), scope = save_scope, !0
                                        }
                                    }
                                });
                            self.walk(tw);
                            for (var i = 0; i < in_use.length; ++i) in_use[i].orig.forEach(function(decl) {
                                var init = initializations.get(decl.name);
                                init && init.forEach(function(init) {
                                    var tw = new TreeWalker(function(node) {
                                        node instanceof AST_SymbolRef && push_uniq(in_use, node.definition())
                                    });
                                    init.walk(tw)
                                })
                            });
                            var tt = new TreeTransformer(function(node, descend, in_list) {
                                if (node instanceof AST_Lambda && !(node instanceof AST_Accessor))
                                    for (var a = node.argnames, i = a.length; --i >= 0;) {
                                        var sym = a[i];
                                        if (!sym.unreferenced()) break;
                                        a.pop(), compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                            name: sym.name,
                                            file: sym.start.file,
                                            line: sym.start.line,
                                            col: sym.start.col
                                        })
                                    }
                                if (node instanceof AST_Defun && node !== self) return member(node.name.definition(), in_use) ? node : (compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                    name: node.name.name,
                                    file: node.name.start.file,
                                    line: node.name.start.line,
                                    col: node.name.start.col
                                }), make_node(AST_EmptyStatement, node));
                                if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                                    var def = node.definitions.filter(function(def) {
                                        if (member(def.name.definition(), in_use)) return !0;
                                        var w = {
                                            name: def.name.name,
                                            file: def.name.start.file,
                                            line: def.name.start.line,
                                            col: def.name.start.col
                                        };
                                        return def.value && def.value.has_side_effects(compressor) ? (def._unused_side_effects = !0, compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w), !0) : (compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w), !1)
                                    });
                                    def = mergeSort(def, function(a, b) {
                                        return !a.value && b.value ? -1 : !b.value && a.value ? 1 : 0
                                    });
                                    for (var side_effects = [], i = 0; i < def.length;) {
                                        var x = def[i];
                                        x._unused_side_effects ? (side_effects.push(x.value), def.splice(i, 1)) : (side_effects.length > 0 && (side_effects.push(x.value), x.value = AST_Seq.from_array(side_effects), side_effects = []), ++i)
                                    }
                                    return side_effects = side_effects.length > 0 ? make_node(AST_BlockStatement, node, {
                                        body: [make_node(AST_SimpleStatement, node, {
                                            body: AST_Seq.from_array(side_effects)
                                        })]
                                    }) : null, 0 != def.length || side_effects ? 0 == def.length ? side_effects : (node.definitions = def, side_effects && (side_effects.body.unshift(node), node = side_effects), node) : make_node(AST_EmptyStatement, node)
                                }
                                if (node instanceof AST_For && node.init instanceof AST_BlockStatement) {
                                    descend(node, this);
                                    var body = node.init.body.slice(0, -1);
                                    return node.init = node.init.body.slice(-1)[0].body, body.push(node), in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                                        body: body
                                    })
                                }
                                return node instanceof AST_Scope && node !== self ? node : void 0
                            });
                            self.transform(tt)
                        }
                    }), AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
                        var hoist_funs = compressor.option("hoist_funs"),
                            hoist_vars = compressor.option("hoist_vars"),
                            self = this;
                        if (hoist_funs || hoist_vars) {
                            var dirs = [],
                                hoisted = [],
                                vars = new Dictionary,
                                vars_found = 0,
                                var_decl = 0;
                            self.walk(new TreeWalker(function(node) {
                                return node instanceof AST_Scope && node !== self ? !0 : node instanceof AST_Var ? (++var_decl, !0) : void 0
                            })), hoist_vars = hoist_vars && var_decl > 1;
                            var tt = new TreeTransformer(function(node) {
                                if (node !== self) {
                                    if (node instanceof AST_Directive) return dirs.push(node), make_node(AST_EmptyStatement, node);
                                    if (node instanceof AST_Defun && hoist_funs) return hoisted.push(node), make_node(AST_EmptyStatement, node);
                                    if (node instanceof AST_Var && hoist_vars) {
                                        node.definitions.forEach(function(def) {
                                            vars.set(def.name.name, def), ++vars_found
                                        });
                                        var seq = node.to_assignments(),
                                            p = tt.parent();
                                        return p instanceof AST_ForIn && p.init === node ? null == seq ? node.definitions[0].name : seq : p instanceof AST_For && p.init === node ? seq : seq ? make_node(AST_SimpleStatement, node, {
                                            body: seq
                                        }) : make_node(AST_EmptyStatement, node)
                                    }
                                    if (node instanceof AST_Scope) return node
                                }
                            });
                            if (self = self.transform(tt), vars_found > 0) {
                                var defs = [];
                                if (vars.each(function(def, name) {
                                        self instanceof AST_Lambda && find_if(function(x) {
                                            return x.name == def.name.name
                                        }, self.argnames) ? vars.del(name) : (def = def.clone(), def.value = null, defs.push(def), vars.set(name, def))
                                    }), defs.length > 0) {
                                    for (var i = 0; i < self.body.length;) {
                                        if (self.body[i] instanceof AST_SimpleStatement) {
                                            var sym, assign, expr = self.body[i].body;
                                            if (expr instanceof AST_Assign && "=" == expr.operator && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                                var def = vars.get(sym.name);
                                                if (def.value) break;
                                                def.value = expr.right, remove(defs, def), defs.push(def), self.body.splice(i, 1);
                                                continue
                                            }
                                            if (expr instanceof AST_Seq && (assign = expr.car) instanceof AST_Assign && "=" == assign.operator && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                                var def = vars.get(sym.name);
                                                if (def.value) break;
                                                def.value = assign.right, remove(defs, def), defs.push(def), self.body[i].body = expr.cdr;
                                                continue
                                            }
                                        }
                                        if (self.body[i] instanceof AST_EmptyStatement) self.body.splice(i, 1);
                                        else {
                                            if (!(self.body[i] instanceof AST_BlockStatement)) break;
                                            var tmp = [i, 1].concat(self.body[i].body);
                                            self.body.splice.apply(self.body, tmp)
                                        }
                                    }
                                    defs = make_node(AST_Var, self, {
                                        definitions: defs
                                    }), hoisted.push(defs)
                                }
                            }
                            self.body = dirs.concat(hoisted, self.body)
                        }
                        return self
                    }), OPT(AST_SimpleStatement, function(self, compressor) {
                        return compressor.option("side_effects") && !self.body.has_side_effects(compressor) ? (compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start), make_node(AST_EmptyStatement, self)) : self
                    }), OPT(AST_DWLoop, function(self, compressor) {
                        var cond = self.condition.evaluate(compressor);
                        if (self.condition = cond[0], !compressor.option("loops")) return self;
                        if (cond.length > 1) {
                            if (cond[1]) return make_node(AST_For, self, {
                                body: self.body
                            });
                            if (self instanceof AST_While && compressor.option("dead_code")) {
                                var a = [];
                                return extract_declarations_from_unreachable_code(compressor, self.body, a), make_node(AST_BlockStatement, self, {
                                    body: a
                                })
                            }
                        }
                        return self
                    }), OPT(AST_While, function(self, compressor) {
                        return compressor.option("loops") ? (self = AST_DWLoop.prototype.optimize.call(self, compressor), self instanceof AST_While && (if_break_in_loop(self, compressor), self = make_node(AST_For, self, self).transform(compressor)), self) : self
                    }), OPT(AST_For, function(self, compressor) {
                        var cond = self.condition;
                        if (cond && (cond = cond.evaluate(compressor), self.condition = cond[0]), !compressor.option("loops")) return self;
                        if (cond && cond.length > 1 && !cond[1] && compressor.option("dead_code")) {
                            var a = [];
                            return self.init instanceof AST_Statement ? a.push(self.init) : self.init && a.push(make_node(AST_SimpleStatement, self.init, {
                                body: self.init
                            })), extract_declarations_from_unreachable_code(compressor, self.body, a), make_node(AST_BlockStatement, self, {
                                body: a
                            })
                        }
                        return if_break_in_loop(self, compressor), self
                    }), OPT(AST_If, function(self, compressor) {
                        if (!compressor.option("conditionals")) return self;
                        var cond = self.condition.evaluate(compressor);
                        if (self.condition = cond[0], cond.length > 1)
                            if (cond[1]) {
                                if (compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start), compressor.option("dead_code")) {
                                    var a = [];
                                    return self.alternative && extract_declarations_from_unreachable_code(compressor, self.alternative, a), a.push(self.body), make_node(AST_BlockStatement, self, {
                                        body: a
                                    }).transform(compressor)
                                }
                            } else if (compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start), compressor.option("dead_code")) {
                            var a = [];
                            return extract_declarations_from_unreachable_code(compressor, self.body, a), self.alternative && a.push(self.alternative), make_node(AST_BlockStatement, self, {
                                body: a
                            }).transform(compressor)
                        }
                        is_empty(self.alternative) && (self.alternative = null);
                        var negated = self.condition.negate(compressor),
                            negated_is_best = best_of(self.condition, negated) === negated;
                        if (self.alternative && negated_is_best) {
                            negated_is_best = !1, self.condition = negated;
                            var tmp = self.body;
                            self.body = self.alternative || make_node(AST_EmptyStatement), self.alternative = tmp
                        }
                        if (is_empty(self.body) && is_empty(self.alternative)) return make_node(AST_SimpleStatement, self.condition, {
                            body: self.condition
                        }).transform(compressor);
                        if (self.body instanceof AST_SimpleStatement && self.alternative instanceof AST_SimpleStatement) return make_node(AST_SimpleStatement, self, {
                            body: make_node(AST_Conditional, self, {
                                condition: self.condition,
                                consequent: self.body.body,
                                alternative: self.alternative.body
                            })
                        }).transform(compressor);
                        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) return negated_is_best ? make_node(AST_SimpleStatement, self, {
                            body: make_node(AST_Binary, self, {
                                operator: "||",
                                left: negated,
                                right: self.body.body
                            })
                        }).transform(compressor) : make_node(AST_SimpleStatement, self, {
                            body: make_node(AST_Binary, self, {
                                operator: "&&",
                                left: self.condition,
                                right: self.body.body
                            })
                        }).transform(compressor);
                        if (self.body instanceof AST_EmptyStatement && self.alternative && self.alternative instanceof AST_SimpleStatement) return make_node(AST_SimpleStatement, self, {
                            body: make_node(AST_Binary, self, {
                                operator: "||",
                                left: self.condition,
                                right: self.alternative.body
                            })
                        }).transform(compressor);
                        if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) return make_node(self.body.CTOR, self, {
                            value: make_node(AST_Conditional, self, {
                                condition: self.condition,
                                consequent: self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                                alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                            })
                        }).transform(compressor);
                        if (self.body instanceof AST_If && !self.body.alternative && !self.alternative && (self.condition = make_node(AST_Binary, self.condition, {
                                operator: "&&",
                                left: self.condition,
                                right: self.body.condition
                            }).transform(compressor), self.body = self.body.body), aborts(self.body) && self.alternative) {
                            var alt = self.alternative;
                            return self.alternative = null, make_node(AST_BlockStatement, self, {
                                body: [self, alt]
                            }).transform(compressor)
                        }
                        if (aborts(self.alternative)) {
                            var body = self.body;
                            return self.body = self.alternative, self.condition = negated_is_best ? negated : self.condition.negate(compressor), self.alternative = null, make_node(AST_BlockStatement, self, {
                                body: [self, body]
                            }).transform(compressor)
                        }
                        return self
                    }), OPT(AST_Switch, function(self, compressor) {
                        if (0 == self.body.length && compressor.option("conditionals")) return make_node(AST_SimpleStatement, self, {
                            body: self.expression
                        }).transform(compressor);
                        for (;;) {
                            var last_branch = self.body[self.body.length - 1];
                            if (last_branch) {
                                var stat = last_branch.body[last_branch.body.length - 1];
                                if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self && last_branch.body.pop(), last_branch instanceof AST_Default && 0 == last_branch.body.length) {
                                    self.body.pop();
                                    continue
                                }
                            }
                            break
                        }
                        var exp = self.expression.evaluate(compressor);
                        out: if (2 == exp.length) try {
                                if (self.expression = exp[0], !compressor.option("dead_code")) break out;
                                var value = exp[1],
                                    in_if = !1,
                                    in_block = !1,
                                    started = !1,
                                    stopped = !1,
                                    ruined = !1,
                                    tt = new TreeTransformer(function(node, descend, in_list) {
                                        if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) return node;
                                        if (node instanceof AST_Switch && node === self) return node = node.clone(), descend(node, this), ruined ? node : make_node(AST_BlockStatement, node, {
                                            body: node.body.reduce(function(a, branch) {
                                                return a.concat(branch.body)
                                            }, [])
                                        }).transform(compressor);
                                        if (node instanceof AST_If || node instanceof AST_Try) {
                                            var save = in_if;
                                            return in_if = !in_block, descend(node, this), in_if = save, node
                                        }
                                        if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                                            var save = in_block;
                                            return in_block = !0, descend(node, this), in_block = save, node
                                        }
                                        if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) return in_if ? (ruined = !0, node) : in_block ? node : (stopped = !0, in_list ? MAP.skip : make_node(AST_EmptyStatement, node));
                                        if (node instanceof AST_SwitchBranch && this.parent() === self) {
                                            if (stopped) return MAP.skip;
                                            if (node instanceof AST_Case) {
                                                var exp = node.expression.evaluate(compressor);
                                                if (exp.length < 2) throw self;
                                                return exp[1] === value || started ? (started = !0, aborts(node) && (stopped = !0), descend(node, this), node) : MAP.skip
                                            }
                                            return descend(node, this), node
                                        }
                                    });
                                tt.stack = compressor.stack.slice(), self = self.transform(tt)
                            } catch (ex) {
                                if (ex !== self) throw ex
                            }
                            return self
                    }), OPT(AST_Case, function(self, compressor) {
                        return self.body = tighten_body(self.body, compressor), self
                    }), OPT(AST_Try, function(self, compressor) {
                        return self.body = tighten_body(self.body, compressor), self
                    }), AST_Definitions.DEFMETHOD("remove_initializers", function() {
                        this.definitions.forEach(function(def) {
                            def.value = null
                        })
                    }), AST_Definitions.DEFMETHOD("to_assignments", function() {
                        var assignments = this.definitions.reduce(function(a, def) {
                            if (def.value) {
                                var name = make_node(AST_SymbolRef, def.name, def.name);
                                a.push(make_node(AST_Assign, def, {
                                    operator: "=",
                                    left: name,
                                    right: def.value
                                }))
                            }
                            return a
                        }, []);
                        return 0 == assignments.length ? null : AST_Seq.from_array(assignments)
                    }), OPT(AST_Definitions, function(self) {
                        return 0 == self.definitions.length ? make_node(AST_EmptyStatement, self) : self
                    }), OPT(AST_Function, function(self, compressor) {
                        return self = AST_Lambda.prototype.optimize.call(self, compressor), compressor.option("unused") && self.name && self.name.unreferenced() && (self.name = null), self
                    }), OPT(AST_Call, function(self, compressor) {
                        if (compressor.option("unsafe")) {
                            var exp = self.expression;
                            if (exp instanceof AST_SymbolRef && exp.undeclared()) switch (exp.name) {
                                case "Array":
                                    if (1 != self.args.length) return make_node(AST_Array, self, {
                                        elements: self.args
                                    });
                                    break;
                                case "Object":
                                    if (0 == self.args.length) return make_node(AST_Object, self, {
                                        properties: []
                                    });
                                    break;
                                case "String":
                                    return 0 == self.args.length ? make_node(AST_String, self, {
                                        value: ""
                                    }) : make_node(AST_Binary, self, {
                                        left: self.args[0],
                                        operator: "+",
                                        right: make_node(AST_String, self, {
                                            value: ""
                                        })
                                    });
                                case "Function":
                                    if (all(self.args, function(x) {
                                            return x instanceof AST_String
                                        })) try {
                                        var code = "(function(" + self.args.slice(0, -1).map(function(arg) {
                                                return arg.value
                                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()",
                                            ast = parse(code);
                                        ast.figure_out_scope();
                                        var comp = new Compressor(compressor.options);
                                        ast = ast.transform(comp), ast.figure_out_scope(), ast.mangle_names();
                                        var fun;
                                        try {
                                            ast.walk(new TreeWalker(function(node) {
                                                if (node instanceof AST_Lambda) throw fun = node, ast
                                            }))
                                        } catch (ex) {
                                            if (ex !== ast) throw ex
                                        }
                                        var args = fun.argnames.map(function(arg, i) {
                                                return make_node(AST_String, self.args[i], {
                                                    value: arg.print_to_string()
                                                })
                                            }),
                                            code = OutputStream();
                                        return AST_BlockStatement.prototype._codegen.call(fun, fun, code), code = code.toString().replace(/^\{|\}$/g, ""), args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                            value: code
                                        })), self.args = args, self
                                    } catch (ex) {
                                        if (!(ex instanceof JS_Parse_Error)) throw console.log(ex), ex;
                                        compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start), compressor.warn(ex.toString())
                                    }
                            } else {
                                if (exp instanceof AST_Dot && "toString" == exp.property && 0 == self.args.length) return make_node(AST_Binary, self, {
                                    left: make_node(AST_String, self, {
                                        value: ""
                                    }),
                                    operator: "+",
                                    right: exp.expression
                                }).transform(compressor);
                                if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && "join" == exp.property) {
                                    var separator = 0 == self.args.length ? "," : self.args[0].evaluate(compressor)[1];
                                    if (null != separator) {
                                        var elements = exp.expression.elements.reduce(function(a, el) {
                                            if (el = el.evaluate(compressor), 0 == a.length || 1 == el.length) a.push(el);
                                            else {
                                                var last = a[a.length - 1];
                                                if (2 == last.length) {
                                                    var val = "" + last[1] + separator + el[1];
                                                    a[a.length - 1] = [make_node_from_constant(compressor, val, last[0]), val]
                                                } else a.push(el)
                                            }
                                            return a
                                        }, []);
                                        if (0 == elements.length) return make_node(AST_String, self, {
                                            value: ""
                                        });
                                        if (1 == elements.length) return elements[0][0];
                                        if ("" == separator) {
                                            var first;
                                            return first = elements[0][0] instanceof AST_String || elements[1][0] instanceof AST_String ? elements.shift()[0] : make_node(AST_String, self, {
                                                value: ""
                                            }), elements.reduce(function(prev, el) {
                                                return make_node(AST_Binary, el[0], {
                                                    operator: "+",
                                                    left: prev,
                                                    right: el[0]
                                                })
                                            }, first).transform(compressor)
                                        }
                                        var node = self.clone();
                                        return node.expression = node.expression.clone(), node.expression.expression = node.expression.expression.clone(), node.expression.expression.elements = elements.map(function(el) {
                                            return el[0]
                                        }), best_of(self, node)
                                    }
                                }
                            }
                        }
                        return compressor.option("side_effects") && self.expression instanceof AST_Function && 0 == self.args.length && !AST_Block.prototype.has_side_effects.call(self.expression, compressor) ? make_node(AST_Undefined, self).transform(compressor) : self.evaluate(compressor)[0]
                    }), OPT(AST_New, function(self, compressor) {
                        if (compressor.option("unsafe")) {
                            var exp = self.expression;
                            if (exp instanceof AST_SymbolRef && exp.undeclared()) switch (exp.name) {
                                case "Object":
                                case "RegExp":
                                case "Function":
                                case "Error":
                                case "Array":
                                    return make_node(AST_Call, self, self).transform(compressor)
                            }
                        }
                        return self
                    }), OPT(AST_Seq, function(self, compressor) {
                        if (!compressor.option("side_effects")) return self;
                        if (!self.car.has_side_effects(compressor)) {
                            var p;
                            if (!(self.cdr instanceof AST_SymbolRef && "eval" == self.cdr.name && self.cdr.undeclared() && (p = compressor.parent()) instanceof AST_Call && p.expression === self)) return self.cdr
                        }
                        if (compressor.option("cascade")) {
                            if (self.car instanceof AST_Assign && !self.car.left.has_side_effects(compressor) && self.car.left.equivalent_to(self.cdr)) return self.car;
                            if (!self.car.has_side_effects(compressor) && !self.cdr.has_side_effects(compressor) && self.car.equivalent_to(self.cdr)) return self.car
                        }
                        return self
                    }), AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
                        if (compressor.option("sequences") && this.expression instanceof AST_Seq) {
                            var seq = this.expression,
                                x = seq.to_array();
                            return this.expression = x.pop(), x.push(this), seq = AST_Seq.from_array(x).transform(compressor)
                        }
                        return this
                    }), OPT(AST_UnaryPostfix, function(self, compressor) {
                        return self.lift_sequences(compressor)
                    }), OPT(AST_UnaryPrefix, function(self, compressor) {
                        self = self.lift_sequences(compressor);
                        var e = self.expression;
                        if (compressor.option("booleans") && compressor.in_boolean_context()) {
                            switch (self.operator) {
                                case "!":
                                    if (e instanceof AST_UnaryPrefix && "!" == e.operator) return e.expression;
                                    break;
                                case "typeof":
                                    return compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start), make_node(AST_True, self)
                            }
                            e instanceof AST_Binary && "!" == self.operator && (self = best_of(self, e.negate(compressor)))
                        }
                        return self.evaluate(compressor)[0]
                    }), AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
                        if (compressor.option("sequences")) {
                            if (this.left instanceof AST_Seq) {
                                var seq = this.left,
                                    x = seq.to_array();
                                return this.left = x.pop(), x.push(this), seq = AST_Seq.from_array(x).transform(compressor)
                            }
                            if (this.right instanceof AST_Seq && "||" != this.operator && "&&" != this.operator && !this.left.has_side_effects(compressor)) {
                                var seq = this.right,
                                    x = seq.to_array();
                                return this.right = x.pop(), x.push(this), seq = AST_Seq.from_array(x).transform(compressor)
                            }
                        }
                        return this
                    });
                var commutativeOperators = makePredicate("== === != !== * & | ^");
                OPT(AST_Binary, function(self, compressor) {
                    var reverse = compressor.has_directive("use asm") ? noop : function(op, force) {
                        if (force || !self.left.has_side_effects(compressor) && !self.right.has_side_effects(compressor)) {
                            op && (self.operator = op);
                            var tmp = self.left;
                            self.left = self.right, self.right = tmp
                        }
                    };
                    if (commutativeOperators(self.operator) && (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant) && reverse(null, !0), /^[!=]==?$/.test(self.operator))) {
                        if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                            if (self.right.consequent instanceof AST_SymbolRef && self.right.consequent.definition() === self.left.definition()) {
                                if (/^==/.test(self.operator)) return self.right.condition;
                                if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor)
                            }
                            if (self.right.alternative instanceof AST_SymbolRef && self.right.alternative.definition() === self.left.definition()) {
                                if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                                if (/^!=/.test(self.operator)) return self.right.condition
                            }
                        }
                        if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                            if (self.left.consequent instanceof AST_SymbolRef && self.left.consequent.definition() === self.right.definition()) {
                                if (/^==/.test(self.operator)) return self.left.condition;
                                if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor)
                            }
                            if (self.left.alternative instanceof AST_SymbolRef && self.left.alternative.definition() === self.right.definition()) {
                                if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                                if (/^!=/.test(self.operator)) return self.left.condition
                            }
                        }
                    }
                    if (self = self.lift_sequences(compressor), compressor.option("comparisons")) switch (self.operator) {
                        case "===":
                        case "!==":
                            (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_boolean() && self.right.is_boolean()) && (self.operator = self.operator.substr(0, 2));
                        case "==":
                        case "!=":
                            self.left instanceof AST_String && "undefined" == self.left.value && self.right instanceof AST_UnaryPrefix && "typeof" == self.right.operator && compressor.option("unsafe") && (self.right.expression instanceof AST_SymbolRef && self.right.expression.undeclared() || (self.right = self.right.expression, self.left = make_node(AST_Undefined, self.left).optimize(compressor), 2 == self.operator.length && (self.operator += "=")))
                    }
                    if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
                        case "&&":
                            var ll = self.left.evaluate(compressor),
                                rr = self.right.evaluate(compressor);
                            if (ll.length > 1 && !ll[1] || rr.length > 1 && !rr[1]) return compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start), make_node(AST_False, self);
                            if (ll.length > 1 && ll[1]) return rr[0];
                            if (rr.length > 1 && rr[1]) return ll[0];
                            break;
                        case "||":
                            var ll = self.left.evaluate(compressor),
                                rr = self.right.evaluate(compressor);
                            if (ll.length > 1 && ll[1] || rr.length > 1 && rr[1]) return compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start), make_node(AST_True, self);
                            if (ll.length > 1 && !ll[1]) return rr[0];
                            if (rr.length > 1 && !rr[1]) return ll[0];
                            break;
                        case "+":
                            var ll = self.left.evaluate(compressor),
                                rr = self.right.evaluate(compressor);
                            if (ll.length > 1 && ll[0] instanceof AST_String && ll[1] || rr.length > 1 && rr[0] instanceof AST_String && rr[1]) return compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start), make_node(AST_True, self)
                    }
                    if (compressor.option("comparisons")) {
                        if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
                            var negated = make_node(AST_UnaryPrefix, self, {
                                operator: "!",
                                expression: self.negate(compressor)
                            });
                            self = best_of(self, negated)
                        }
                        switch (self.operator) {
                            case "<":
                                reverse(">");
                                break;
                            case "<=":
                                reverse(">=")
                        }
                    }
                    return "+" == self.operator && self.right instanceof AST_String && "" === self.right.getValue() && self.left instanceof AST_Binary && "+" == self.left.operator && self.left.is_string(compressor) ? self.left : (compressor.option("evaluate") && "+" == self.operator && (self.left instanceof AST_Constant && self.right instanceof AST_Binary && "+" == self.right.operator && self.right.left instanceof AST_Constant && self.right.is_string(compressor) && (self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_String, null, {
                            value: "" + self.left.getValue() + self.right.left.getValue(),
                            start: self.left.start,
                            end: self.right.left.end
                        }),
                        right: self.right.right
                    })), self.right instanceof AST_Constant && self.left instanceof AST_Binary && "+" == self.left.operator && self.left.right instanceof AST_Constant && self.left.is_string(compressor) && (self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: self.left.left,
                        right: make_node(AST_String, null, {
                            value: "" + self.left.right.getValue() + self.right.getValue(),
                            start: self.left.right.start,
                            end: self.right.end
                        })
                    })), self.left instanceof AST_Binary && "+" == self.left.operator && self.left.is_string(compressor) && self.left.right instanceof AST_Constant && self.right instanceof AST_Binary && "+" == self.right.operator && self.right.left instanceof AST_Constant && (self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_Binary, self.left, {
                            operator: "+",
                            left: self.left.left,
                            right: make_node(AST_String, null, {
                                value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                start: self.left.right.start,
                                end: self.right.left.end
                            })
                        }),
                        right: self.right.right
                    }))), self.evaluate(compressor)[0])
                }), OPT(AST_SymbolRef, function(self, compressor) {
                    if (self.undeclared()) {
                        var defines = compressor.option("global_defs");
                        if (defines && defines.hasOwnProperty(self.name)) return make_node_from_constant(compressor, defines[self.name], self);
                        switch (self.name) {
                            case "undefined":
                                return make_node(AST_Undefined, self);
                            case "NaN":
                                return make_node(AST_NaN, self);
                            case "Infinity":
                                return make_node(AST_Infinity, self)
                        }
                    }
                    return self
                }), OPT(AST_Undefined, function(self, compressor) {
                    if (compressor.option("unsafe")) {
                        var scope = compressor.find_parent(AST_Scope),
                            undef = scope.find_variable("undefined");
                        if (undef) {
                            var ref = make_node(AST_SymbolRef, self, {
                                name: "undefined",
                                scope: scope,
                                thedef: undef
                            });
                            return ref.reference(), ref
                        }
                    }
                    return self
                });
                var ASSIGN_OPS = ["+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&"];
                OPT(AST_Assign, function(self, compressor) {
                    return self = self.lift_sequences(compressor), "=" == self.operator && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary && self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && member(self.right.operator, ASSIGN_OPS) && (self.operator = self.right.operator + "=", self.right = self.right.right), self
                }), OPT(AST_Conditional, function(self, compressor) {
                    if (!compressor.option("conditionals")) return self;
                    if (self.condition instanceof AST_Seq) {
                        var car = self.condition.car;
                        return self.condition = self.condition.cdr, AST_Seq.cons(car, self)
                    }
                    var cond = self.condition.evaluate(compressor);
                    if (cond.length > 1) return cond[1] ? (compressor.warn("Condition always true [{file}:{line},{col}]", self.start), self.consequent) : (compressor.warn("Condition always false [{file}:{line},{col}]", self.start), self.alternative);
                    var negated = cond[0].negate(compressor);
                    best_of(cond[0], negated) === negated && (self = make_node(AST_Conditional, self, {
                        condition: negated,
                        consequent: self.alternative,
                        alternative: self.consequent
                    }));
                    var consequent = self.consequent,
                        alternative = self.alternative;
                    return consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator == alternative.operator && consequent.left.equivalent_to(alternative.left) && (self = make_node(AST_Assign, self, {
                        operator: consequent.operator,
                        left: consequent.left,
                        right: make_node(AST_Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.right,
                            alternative: alternative.right
                        })
                    })), self
                }), OPT(AST_Boolean, function(self, compressor) {
                    if (compressor.option("booleans")) {
                        var p = compressor.parent();
                        return p instanceof AST_Binary && ("==" == p.operator || "!=" == p.operator) ? (compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                            operator: p.operator,
                            value: self.value,
                            file: p.start.file,
                            line: p.start.line,
                            col: p.start.col
                        }), make_node(AST_Number, self, {
                            value: +self.value
                        })) : make_node(AST_UnaryPrefix, self, {
                            operator: "!",
                            expression: make_node(AST_Number, self, {
                                value: 1 - self.value
                            })
                        })
                    }
                    return self
                }), OPT(AST_Sub, function(self, compressor) {
                    var prop = self.property;
                    return prop instanceof AST_String && compressor.option("properties") && (prop = prop.getValue(), RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) ? make_node(AST_Dot, self, {
                        expression: self.expression,
                        property: prop
                    }) : self
                }), OPT(AST_Array, literals_in_boolean_context), OPT(AST_Object, literals_in_boolean_context), OPT(AST_RegExp, literals_in_boolean_context)
            }(),
            function() {
                function From_Moz_Unary(M) {
                    var prefix = "prefix" in M ? M.prefix : "UnaryExpression" == M.type ? !0 : !1;
                    return new(prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
                        start: my_start_token(M),
                        end: my_end_token(M),
                        operator: M.operator,
                        expression: from_moz(M.argument)
                    })
                }

                function my_start_token(moznode) {
                    return new AST_Token({
                        file: moznode.loc && moznode.loc.source,
                        line: moznode.loc && moznode.loc.start.line,
                        col: moznode.loc && moznode.loc.start.column,
                        pos: moznode.start,
                        endpos: moznode.start
                    })
                }

                function my_end_token(moznode) {
                    return new AST_Token({
                        file: moznode.loc && moznode.loc.source,
                        line: moznode.loc && moznode.loc.end.line,
                        col: moznode.loc && moznode.loc.end.column,
                        pos: moznode.end,
                        endpos: moznode.end
                    })
                }

                function map(moztype, mytype, propmap) {
                    var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
                    return moz_to_me += "return new mytype({\nstart: my_start_token(M),\nend: my_end_token(M)", propmap && propmap.split(/\s*,\s*/).forEach(function(prop) {
                        var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
                        if (!m) throw new Error("Can't understand property map: " + prop);
                        var moz = "M." + m[1],
                            how = m[2],
                            my = m[3];
                        if (moz_to_me += ",\n" + my + ": ", "@" == how) moz_to_me += moz + ".map(from_moz)";
                        else if (">" == how) moz_to_me += "from_moz(" + moz + ")";
                        else if ("=" == how) moz_to_me += moz;
                        else {
                            if ("%" != how) throw new Error("Can't understand operator in propmap: " + prop);
                            moz_to_me += "from_moz(" + moz + ").body"
                        }
                    }), moz_to_me += "\n})}", moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(mytype, my_start_token, my_end_token, from_moz), MOZ_TO_ME[moztype] = moz_to_me
                }

                function from_moz(node) {
                    FROM_MOZ_STACK.push(node);
                    var ret = null != node ? MOZ_TO_ME[node.type](node) : null;
                    return FROM_MOZ_STACK.pop(), ret
                }
                var MOZ_TO_ME = {
                    TryStatement: function(M) {
                        return new AST_Try({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            body: from_moz(M.block).body,
                            bcatch: from_moz(M.handlers[0]),
                            bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
                        })
                    },
                    CatchClause: function(M) {
                        return new AST_Catch({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            argname: from_moz(M.param),
                            body: from_moz(M.body).body
                        })
                    },
                    ObjectExpression: function(M) {
                        return new AST_Object({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            properties: M.properties.map(function(prop) {
                                var key = prop.key,
                                    name = "Identifier" == key.type ? key.name : key.value,
                                    args = {
                                        start: my_start_token(key),
                                        end: my_end_token(prop.value),
                                        key: name,
                                        value: from_moz(prop.value)
                                    };
                                switch (prop.kind) {
                                    case "init":
                                        return new AST_ObjectKeyVal(args);
                                    case "set":
                                        return args.value.name = from_moz(key), new AST_ObjectSetter(args);
                                    case "get":
                                        return args.value.name = from_moz(key), new AST_ObjectGetter(args)
                                }
                            })
                        })
                    },
                    SequenceExpression: function(M) {
                        return AST_Seq.from_array(M.expressions.map(from_moz))
                    },
                    MemberExpression: function(M) {
                        return new(M.computed ? AST_Sub : AST_Dot)({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            property: M.computed ? from_moz(M.property) : M.property.name,
                            expression: from_moz(M.object)
                        })
                    },
                    SwitchCase: function(M) {
                        return new(M.test ? AST_Case : AST_Default)({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            expression: from_moz(M.test),
                            body: M.consequent.map(from_moz)
                        })
                    },
                    Literal: function(M) {
                        var val = M.value,
                            args = {
                                start: my_start_token(M),
                                end: my_end_token(M)
                            };
                        if (null === val) return new AST_Null(args);
                        switch (typeof val) {
                            case "string":
                                return args.value = val, new AST_String(args);
                            case "number":
                                return args.value = val, new AST_Number(args);
                            case "boolean":
                                return new(val ? AST_True : AST_False)(args);
                            default:
                                return args.value = val, new AST_RegExp(args)
                        }
                    },
                    UnaryExpression: From_Moz_Unary,
                    UpdateExpression: From_Moz_Unary,
                    Identifier: function(M) {
                        var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
                        return new("this" == M.name ? AST_This : "LabeledStatement" == p.type ? AST_Label : "VariableDeclarator" == p.type && p.id === M ? "const" == p.kind ? AST_SymbolConst : AST_SymbolVar : "FunctionExpression" == p.type ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : "FunctionDeclaration" == p.type ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : "CatchClause" == p.type ? AST_SymbolCatch : "BreakStatement" == p.type || "ContinueStatement" == p.type ? AST_LabelRef : AST_SymbolRef)({
                            start: my_start_token(M),
                            end: my_end_token(M),
                            name: M.name
                        })
                    }
                };
                map("Node", AST_Node), map("Program", AST_Toplevel, "body@body"), map("Function", AST_Function, "id>name, params@argnames, body%body"), map("EmptyStatement", AST_EmptyStatement), map("BlockStatement", AST_BlockStatement, "body@body"), map("ExpressionStatement", AST_SimpleStatement, "expression>body"), map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative"), map("LabeledStatement", AST_LabeledStatement, "label>label, body>body"), map("BreakStatement", AST_Break, "label>label"), map("ContinueStatement", AST_Continue, "label>label"), map("WithStatement", AST_With, "object>expression, body>body"), map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body"), map("ReturnStatement", AST_Return, "argument>value"), map("ThrowStatement", AST_Throw, "argument>value"), map("WhileStatement", AST_While, "test>condition, body>body"), map("DoWhileStatement", AST_Do, "test>condition, body>body"), map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body"), map("ForInStatement", AST_ForIn, "left>init, right>object, body>body"), map("DebuggerStatement", AST_Debugger), map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body"), map("VariableDeclaration", AST_Var, "declarations@definitions"), map("VariableDeclarator", AST_VarDef, "id>name, init>value"), map("ThisExpression", AST_This), map("ArrayExpression", AST_Array, "elements@elements"), map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body"), map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right"), map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right"), map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right"), map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative"), map("NewExpression", AST_New, "callee>expression, arguments@args"), map("CallExpression", AST_Call, "callee>expression, arguments@args");
                var FROM_MOZ_STACK = null;
                AST_Node.from_mozilla_ast = function(node) {
                    var save_stack = FROM_MOZ_STACK;
                    FROM_MOZ_STACK = [];
                    var ast = from_moz(node);
                    return FROM_MOZ_STACK = save_stack, ast
                }
            }(), exports.array_to_hash = array_to_hash, exports.slice = slice, exports.characters = characters, exports.member = member, exports.find_if = find_if, exports.repeat_string = repeat_string, exports.DefaultsError = DefaultsError, exports.defaults = defaults, exports.merge = merge, exports.noop = noop, exports.MAP = MAP, exports.push_uniq = push_uniq, exports.string_template = string_template, exports.remove = remove, exports.mergeSort = mergeSort, exports.set_difference = set_difference, exports.set_intersection = set_intersection, exports.makePredicate = makePredicate, exports.all = all, exports.Dictionary = Dictionary, exports.DEFNODE = DEFNODE, exports.AST_Token = AST_Token, exports.AST_Node = AST_Node, exports.AST_Statement = AST_Statement, exports.AST_Debugger = AST_Debugger, exports.AST_Directive = AST_Directive, exports.AST_SimpleStatement = AST_SimpleStatement, exports.walk_body = walk_body, exports.AST_Block = AST_Block, exports.AST_BlockStatement = AST_BlockStatement, exports.AST_EmptyStatement = AST_EmptyStatement, exports.AST_StatementWithBody = AST_StatementWithBody, exports.AST_LabeledStatement = AST_LabeledStatement, exports.AST_IterationStatement = AST_IterationStatement, exports.AST_DWLoop = AST_DWLoop, exports.AST_Do = AST_Do, exports.AST_While = AST_While, exports.AST_For = AST_For, exports.AST_ForIn = AST_ForIn, exports.AST_With = AST_With, exports.AST_Scope = AST_Scope, exports.AST_Toplevel = AST_Toplevel, exports.AST_Lambda = AST_Lambda, exports.AST_Accessor = AST_Accessor, exports.AST_Function = AST_Function, exports.AST_Defun = AST_Defun, exports.AST_Jump = AST_Jump, exports.AST_Exit = AST_Exit, exports.AST_Return = AST_Return, exports.AST_Throw = AST_Throw, exports.AST_LoopControl = AST_LoopControl, exports.AST_Break = AST_Break, exports.AST_Continue = AST_Continue, exports.AST_If = AST_If, exports.AST_Switch = AST_Switch, exports.AST_SwitchBranch = AST_SwitchBranch, exports.AST_Default = AST_Default, exports.AST_Case = AST_Case, exports.AST_Try = AST_Try, exports.AST_Catch = AST_Catch, exports.AST_Finally = AST_Finally, exports.AST_Definitions = AST_Definitions, exports.AST_Var = AST_Var, exports.AST_Const = AST_Const, exports.AST_VarDef = AST_VarDef, exports.AST_Call = AST_Call, exports.AST_New = AST_New, exports.AST_Seq = AST_Seq, exports.AST_PropAccess = AST_PropAccess, exports.AST_Dot = AST_Dot, exports.AST_Sub = AST_Sub, exports.AST_Unary = AST_Unary, exports.AST_UnaryPrefix = AST_UnaryPrefix, exports.AST_UnaryPostfix = AST_UnaryPostfix, exports.AST_Binary = AST_Binary, exports.AST_Conditional = AST_Conditional, exports.AST_Assign = AST_Assign, exports.AST_Array = AST_Array, exports.AST_Object = AST_Object, exports.AST_ObjectProperty = AST_ObjectProperty, exports.AST_ObjectKeyVal = AST_ObjectKeyVal, exports.AST_ObjectSetter = AST_ObjectSetter, exports.AST_ObjectGetter = AST_ObjectGetter, exports.AST_Symbol = AST_Symbol, exports.AST_SymbolAccessor = AST_SymbolAccessor, exports.AST_SymbolDeclaration = AST_SymbolDeclaration, exports.AST_SymbolVar = AST_SymbolVar, exports.AST_SymbolConst = AST_SymbolConst, exports.AST_SymbolFunarg = AST_SymbolFunarg, exports.AST_SymbolDefun = AST_SymbolDefun, exports.AST_SymbolLambda = AST_SymbolLambda, exports.AST_SymbolCatch = AST_SymbolCatch, exports.AST_Label = AST_Label, exports.AST_SymbolRef = AST_SymbolRef, exports.AST_LabelRef = AST_LabelRef, exports.AST_This = AST_This, exports.AST_Constant = AST_Constant, exports.AST_String = AST_String, exports.AST_Number = AST_Number, exports.AST_RegExp = AST_RegExp, exports.AST_Atom = AST_Atom, exports.AST_Null = AST_Null, exports.AST_NaN = AST_NaN, exports.AST_Undefined = AST_Undefined, exports.AST_Hole = AST_Hole, exports.AST_Infinity = AST_Infinity, exports.AST_Boolean = AST_Boolean, exports.AST_False = AST_False, exports.AST_True = AST_True, exports.TreeWalker = TreeWalker, exports.KEYWORDS = KEYWORDS, exports.KEYWORDS_ATOM = KEYWORDS_ATOM, exports.RESERVED_WORDS = RESERVED_WORDS, exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION, exports.OPERATOR_CHARS = OPERATOR_CHARS, exports.RE_HEX_NUMBER = RE_HEX_NUMBER, exports.RE_OCT_NUMBER = RE_OCT_NUMBER, exports.RE_DEC_NUMBER = RE_DEC_NUMBER, exports.OPERATORS = OPERATORS, exports.WHITESPACE_CHARS = WHITESPACE_CHARS, exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION, exports.PUNC_CHARS = PUNC_CHARS, exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS, exports.UNICODE = UNICODE, exports.is_letter = is_letter, exports.is_digit = is_digit, exports.is_alphanumeric_char = is_alphanumeric_char, exports.is_unicode_combining_mark = is_unicode_combining_mark, exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation, exports.is_identifier = is_identifier, exports.is_identifier_start = is_identifier_start, exports.is_identifier_char = is_identifier_char, exports.is_identifier_string = is_identifier_string, exports.parse_js_number = parse_js_number, exports.JS_Parse_Error = JS_Parse_Error, exports.js_error = js_error, exports.is_token = is_token, exports.EX_EOF = EX_EOF, exports.tokenizer = tokenizer, exports.UNARY_PREFIX = UNARY_PREFIX, exports.UNARY_POSTFIX = UNARY_POSTFIX, exports.ASSIGNMENT = ASSIGNMENT, exports.PRECEDENCE = PRECEDENCE, exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS, exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN, exports.parse = parse, exports.TreeTransformer = TreeTransformer, exports.SymbolDef = SymbolDef, exports.base54 = base54, exports.OutputStream = OutputStream, exports.Compressor = Compressor, exports.SourceMap = SourceMap
    }({}, function() {
        return this
    }()), module("users.timfelgentreff.babelsberg.src_transform").requires("cop.Layers", "lively.morphic.Halos", "lively.ide.CodeEditor").toRun(function() {
        JSLoader.loadJs(module("users.timfelgentreff.babelsberg.uglify").uri()), Object.subclass("BabelsbergSrcTransform", {
            isAlways: function(node) {
                return node instanceof UglifyJS.AST_LabeledStatement && "always" === node.label.name && node.body instanceof UglifyJS.AST_BlockStatement
            },
            isStay: function(node) {
                return node instanceof UglifyJS.AST_LabeledStatement && "stay" === node.label.name && node.body instanceof UglifyJS.AST_BlockStatement
            },
            isRule: function(node) {
                return node instanceof UglifyJS.AST_Label && "rule" === node.name ? (this.__ruleLabelSeen = node, !0) : this.__ruleLabelSeen && node instanceof UglifyJS.AST_String ? !0 : node instanceof UglifyJS.AST_LabeledStatement && "rule" === node.label.name && node.body instanceof UglifyJS.AST_BlockStatement ? !0 : node instanceof UglifyJS.AST_LabeledStatement && node.body.body instanceof UglifyJS.AST_SimpleStatement && node.body.body.body instanceof UglifyJS.AST_Call && node.body.body.body.expression instanceof UglifyJS.AST_Dot && "rule" === node.body.body.body.expression.property && "bbb" === node.body.body.body.expression.expression.name ? (this.__ruleLabelRemove = !0, !0) : (this.__ruleLabelSeen = null, !1)
            },
            isOnce: function(node) {
                return node instanceof UglifyJS.AST_LabeledStatement && "once" === node.label.name && node.body instanceof UglifyJS.AST_BlockStatement
            },
            isTrigger: function(node) {
                return node instanceof UglifyJS.AST_Call && node.expression instanceof UglifyJS.AST_SymbolRef && "when" === node.expression.name
            },
            ensureThisToSelfIn: function(ast) {
                var tr = new UglifyJS.TreeTransformer(function(node) {
                    return node instanceof UglifyJS.AST_This ? new UglifyJS.AST_SymbolRef({
                        start: node.start,
                        end: node.end,
                        name: "_$_self"
                    }) : void 0
                }, null);
                ast.transform(tr)
            },
            hasContextInArgs: function(constraintNode) {
                if (2 == constraintNode.args.length) {
                    if (!constraintNode.args[0] instanceof UglifyJS.AST_Object) throw new SyntaxError("first argument of call to `always' must be an object");
                    return constraintNode.args[0].properties.any(function(ea) {
                        return "ctx" === ea.key
                    })
                }
                return !1
            },
            createContextFor: function(ast, constraintNode) {
                var enclosed = ast.enclosed,
                    self = this;
                constraintNode.args.last() instanceof UglifyJS.AST_Function && (enclosed = constraintNode.args.last().enclosed || [], enclosed = enclosed.reject(function(ea) {
                    return ea.init && ea.init.start.pos > constraintNode.start.pos || ea.orig && ea.orig[0] && ea.orig[0].start.pos > constraintNode.end.pos
                }), enclosed.push({
                    name: "_$_self"
                }));
                var ctx = new UglifyJS.AST_Object({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        properties: enclosed.collect(function(ea) {
                            return new UglifyJS.AST_ObjectKeyVal({
                                start: constraintNode.start,
                                end: constraintNode.end,
                                key: ea.name,
                                value: self.contextMap(ea.name)
                            })
                        })
                    }),
                    ctxkeyval = new UglifyJS.AST_ObjectKeyVal({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        key: "ctx",
                        value: ctx
                    });
                2 == constraintNode.args.length ? constraintNode.args[0].properties.push(ctxkeyval) : constraintNode.args.unshift(new UglifyJS.AST_Object({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    properties: [ctxkeyval]
                }))
            },
            ensureContextFor: function(ast, constraintNode) {
                this.hasContextInArgs(constraintNode) || this.createContextFor(ast, constraintNode)
            },
            getContextTransformerFor: function(ast) {
                var self = this;
                return new UglifyJS.TreeTransformer(null, function(node) {
                    if (self.isAlways(node)) return self.transformConstraint(ast, node, "always");
                    if (self.isOnce(node)) return self.transformConstraint(ast, node, "once");
                    if (self.isTrigger(node)) return self.transformConstraint(ast, node, "when");
                    if (self.isStay(node)) return self.transformConstraint(ast, node, "stay");
                    if (self.isRule(node)) {
                        var node = self.createRuleFor(node);
                        return self.isTransformed = !0, node
                    }
                })
            },
            transformConstraint: function(ast, node, name) {
                var node = this.createCallFor(ast, node, name);
                return this.isTransformed = !0, node
            },
            transform: function(code) {
                var ast = UglifyJS.parse(code);
                ast.figure_out_scope();
                var transformedAst = ast.transform(this.getContextTransformerFor(ast)),
                    stream = UglifyJS.OutputStream({
                        beautify: !0,
                        comments: !0
                    });
                return this.isTransformed ? (transformedAst.print(stream), stream.toString()) : code
            },
            transformAddScript: function(code) {
                var ast = UglifyJS.parse(code);
                ast.figure_out_scope(), transformed = !1;
                var transformedAst = ast.transform(new UglifyJS.TreeTransformer(null, function(node) {
                        return node instanceof UglifyJS.AST_Call && node.expression instanceof UglifyJS.AST_Dot && "addScript" === node.expression.property && node.expression.expression instanceof UglifyJS.AST_This ? (assert(1 === node.args.length), node.args.push(new UglifyJS.AST_String({
                            value: code.slice(node.args[0].start.pos, node.args[0].end.endpos)
                        })), transformed = !0, node) : void 0
                    })),
                    stream = UglifyJS.OutputStream({
                        beautify: !0,
                        comments: !0
                    });
                return transformed ? (transformedAst.print(stream), stream.toString()) : code
            },
            ensureReturnIn: function(body) {
                var lastStatement = body.last();
                lastStatement.body instanceof UglifyJS.AST_Return || (body[body.length - 1] = new UglifyJS.AST_Return({
                    start: lastStatement.start,
                    end: lastStatement.end,
                    value: lastStatement
                }))
            },
            extractArgumentsFrom: function(constraintNode) {
                var store, body = constraintNode.body.body,
                    newBody = [],
                    args = [],
                    extraArgs = [];
                return newBody = body.select(function(ea) {
                    if (ea instanceof UglifyJS.AST_LabeledStatement) {
                        if (!(ea.body instanceof UglifyJS.AST_SimpleStatement)) throw new SyntaxError("Labeled arguments in `always:' have to be simple statements");
                        return "store" == ea.label.name || "name" == ea.label.name ? store = new UglifyJS.AST_Assign({
                            start: ea.start,
                            end: ea.end,
                            right: void 0,
                            operator: "=",
                            left: ea.body.body
                        }) : extraArgs.push(new UglifyJS.AST_ObjectKeyVal({
                            start: ea.start,
                            end: ea.end,
                            key: ea.label.name,
                            value: ea.body.body
                        })), !1
                    }
                    return !0
                }), extraArgs && args.push(new UglifyJS.AST_Object({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    properties: extraArgs
                })), {
                    body: newBody,
                    args: args,
                    store: store
                }
            },
            createCallFor: function(ast, constraintNode, methodName) {
                var body, args, store, enclosed, self = this;
                if (constraintNode instanceof UglifyJS.AST_LabeledStatement) {
                    var splitBodyAndArgs = this.extractArgumentsFrom(constraintNode);
                    body = splitBodyAndArgs.body, args = splitBodyAndArgs.args, store = splitBodyAndArgs.store, enclosed = constraintNode.label.scope.enclosed
                } else {
                    if (!(constraintNode instanceof UglifyJS.AST_Call)) throw SyntaxError("Don't know what to do with " + constraintNode);
                    var nodeArgs = constraintNode.args,
                        funcArg = nodeArgs[nodeArgs.length - 1];
                    if (!(funcArg instanceof UglifyJS.AST_Function)) throw new SyntaxError("Last argument to " + constraintNode.expression.name + " must be a function");
                    body = funcArg.body, args = nodeArgs.slice(0, nodeArgs.length - 1), enclosed = funcArg.enclosed
                }
                this.ensureReturnIn(body), body.each(function(ea) {
                    self.ensureThisToSelfIn(ea)
                });
                var call = new UglifyJS.AST_Call({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    expression: new UglifyJS.AST_Dot({
                        start: constraintNode.start,
                        end: constraintNode.end,
                        property: methodName,
                        expression: new UglifyJS.AST_SymbolRef({
                            start: constraintNode.start,
                            end: constraintNode.end,
                            name: "bbb"
                        })
                    }),
                    args: args.concat([new UglifyJS.AST_Function({
                        start: body.start,
                        end: body.end,
                        body: body,
                        enclosed: enclosed,
                        argnames: []
                    })])
                });
                this.ensureContextFor(ast, call);
                var newBody;
                return store ? (store.right = call, newBody = store) : newBody = call, constraintNode instanceof UglifyJS.AST_Statement ? new UglifyJS.AST_SimpleStatement({
                    start: constraintNode.start,
                    end: constraintNode.end,
                    body: newBody
                }) : newBody
            },
            createRuleFor: function(ruleNode) {
                if (ruleNode instanceof UglifyJS.AST_Label) return ruleNode;
                var stringNode;
                if (ruleNode instanceof UglifyJS.AST_String) stringNode = ruleNode, stringNode.value = stringNode.value.replace(/\|\s*-/gm, ":-"), ruleNode = this.__ruleLabelSeen, delete this.__ruleLabelSeen;
                else {
                    if (this.__ruleLabelRemove) return delete this.__ruleLabelRemove, ruleNode.body.body;
                    var stream = UglifyJS.OutputStream({
                        beautify: !0,
                        comments: !0
                    });
                    ruleNode.body.print(stream), stringNode = new UglifyJS.AST_String({
                        start: ruleNode.body.start,
                        end: ruleNode.body.end,
                        value: stream.toString().replace(/\|\s*-/gm, ":-").replace(/^{\s*/, "").replace(/\s*}\s*$/, "").replace(/\s*;\s*$/, "")
                    })
                }
                return new UglifyJS.AST_SimpleStatement({
                    start: ruleNode.start,
                    end: ruleNode.end,
                    body: new UglifyJS.AST_Call({
                        start: ruleNode.start,
                        end: ruleNode.end,
                        expression: new UglifyJS.AST_Dot({
                            start: ruleNode.start,
                            end: ruleNode.end,
                            property: "rule",
                            expression: new UglifyJS.AST_SymbolRef({
                                start: ruleNode.start,
                                end: ruleNode.end,
                                name: "bbb"
                            })
                        }),
                        args: [stringNode]
                    })
                })
            },
            contextMap: function(name) {
                return "_$_self" === name ? new UglifyJS.AST_Binary({
                    operator: "||",
                    left: new UglifyJS.AST_Dot({
                        expression: new UglifyJS.AST_This({}),
                        property: "doitContext"
                    }),
                    right: new UglifyJS.AST_This({})
                }) : ("ro" === name && (name = "bbb.readonly"), "system" === name && (name = "bbb.system()"), new UglifyJS.AST_SymbolRef({
                    name: name
                }))
            }
        }), lively && lively.morphic && lively.morphic.Morph && lively.morphic.CodeEditor && (cop.create("AddScriptWithFakeOriginalLayer").refineClass(lively.morphic.Morph, {
            addScript: function(funcOrString, origSource) {
                var originalFunction;
                originalFunction = cop.proceed.apply(this, [origSource]);
                var result = cop.proceed.apply(this, [funcOrString]);
                return result.getOriginal().setProperty("originalFunction", originalFunction), result
            }
        }), cop.create("ConstraintSyntaxLayer").refineClass(lively.morphic.CodeEditor, {
            doSave: function() {
                if (this.owner instanceof lively.ide.BrowserPanel) {
                    for (var matchData = this.textString.match(/[^"](always:|once:)/), t = new BabelsbergSrcTransform, idx = matchData && matchData.index || -1, endIdx = this.textString.indexOf("}", idx + 1), fragments = [], offset = 0, lines = this.textString.split("\n").map(function(line) {
                            return [line, offset += line.length + 1]
                        }); - 1 !== idx && -1 !== endIdx;) try {
                        var line, str = t.transform(this.textString.slice(idx, endIdx + 1));
                        lines.some(function(ary) {
                            return line = ary[0], ary[1] > idx
                        });
                        var indent = new Array(line.match(/always:|once:/).index + 1).join(" ");
                        str = str.split("\n").inject("", function(acc, line) {
                            return acc + "\n" + indent + line
                        }).slice("\n".length + indent.length), fragments.push([idx + 1, endIdx, str]), matchData = this.textString.slice(idx + 1).match(/[^"](always:|once:)/), idx = matchData && matchData.index + idx + 1 || -1, endIdx = this.textString.indexOf("}", idx + 2)
                    } catch (e) {
                        endIdx = this.textString.indexOf("}", endIdx + 1)
                    }
                    if (0 !== fragments.length) {
                        var textPos = 0,
                            newTextString = fragments.inject("", function(memo, fragment) {
                                var r = this.textString.slice(textPos, fragment[0]) + fragment[2];
                                return textPos = fragment[1] + 1, memo + r
                            }.bind(this));
                        newTextString += this.textString.slice(textPos), this.textString = newTextString
                    }
                    return cop.withoutLayers([ConstraintSyntaxLayer], function() {
                        return cop.proceed()
                    })
                }
                return cop.proceed()
            },
            boundEval: function(code) {
                var t = new BabelsbergSrcTransform,
                    addScriptWithOrigCode = t.transformAddScript(code),
                    constraintCode = t.transform(addScriptWithOrigCode);
                return addScriptWithOrigCode === constraintCode ? cop.proceed.apply(this, [code]) : cop.withLayers([AddScriptWithFakeOriginalLayer], function() {
                    return cop.proceed.apply(this, [constraintCode])
                })
            }
        }), ConstraintSyntaxLayer.beGlobal())
    }),
    function() {
        function load() {
            function checkForFinish() {
                if (0 === numScripts && !fired) {
                    if (document.createEvent) {
                        var event = document.createEvent("CustomEvent");
                        if (event.initCustomEvent) return event.initCustomEvent("babelsbergready", !0, !0, {
                            message: "Babelsberg Scripts loaded",
                            time: new Date
                        }), fired = !0, document.dispatchEvent(event), void 0
                    }
                    console.warn("Custom Events not supported on this platform")
                }
            }

            function checkScript(script) {
                if (/^text\/(?:x-|)babelsbergscript$/.test(script.type) && !script.getAttribute("babelsberg-ignore")) {
                    var src = script.src;
                    src ? (numScripts += 1, Http.request("get", src, function(code) {
                        Babelsberg.execute(code), numScripts -= 1, checkForFinish()
                    })) : Babelsberg.execute(script.innerHTML), script.setAttribute("babelsberg-ignore", !0)
                }
            }
            for (var numScripts = 0, fired = !1, scripts = document.getElementsByTagName("script"), i = 0; i < scripts.length; i++) checkScript(scripts[i]);
            checkForFinish()
        }
        var Http = {
            request: function(method, url, callback) {
                var xhr = new(window.ActiveXObject || XMLHttpRequest)("Microsoft.XMLHTTP");
                return xhr.open(method.toUpperCase(), url, !0), "overrideMimeType" in xhr && xhr.overrideMimeType("text/plain"), xhr.onreadystatechange = function() {
                    if (4 === xhr.readyState) {
                        var status = xhr.status;
                        if (0 !== status && 200 !== status) throw new Error("Could not load " + url + " (Error " + status + ")");
                        callback.call(xhr, xhr.responseText)
                    }
                }, xhr.send(null)
            }
        };
        Babelsberg.compile = function(code) {
            var t = new BabelsbergSrcTransform;
            return t.transform(code)
        }, Babelsberg.execute = function(code, scope) {
            var func, params = [],
                args = [];
            code = Babelsberg.compile(code);
            var firefox = window.InstallTrigger;
            if (firefox || window.chrome) {
                var script = document.createElement("script"),
                    head = document.head;
                firefox && (code = "\n" + code), script.appendChild(document.createTextNode("bbb._execute = function(" + params + ") {" + code + "\n}")), head.appendChild(script), func = bbb._execute, delete bbb._execute, head.removeChild(script)
            } else func = Function(params, code);
            func.apply(scope, args) || {}
        }, "complete" === document.readyState ? setTimeout(load) : contentLoaded(window, load)
    }(), module("users.timfelgentreff.cassowary.Hashtable").requires().toRun(function() {
        function hashObject(obj) {
            function safeToString(obj) {
                try {
                    return String(obj)
                } catch (ex) {
                    return Object.prototype.toString.call(obj)
                }
            }
            var hashCode;
            return "string" == typeof obj ? obj : typeof obj.hashCode == FUNCTION ? (hashCode = obj.hashCode(), "string" == typeof hashCode ? hashCode : hashObject(hashCode)) : typeof obj.toString == FUNCTION ? obj.toString() : safeToString(obj)
        }

        function equals_fixedValueHasEquals(fixedValue, variableValue) {
            return fixedValue.equals(variableValue)
        }

        function equals_fixedValueNoEquals(fixedValue, variableValue) {
            return typeof variableValue.equals == FUNCTION ? variableValue.equals(fixedValue) : fixedValue === variableValue
        }

        function createKeyValCheck(kvStr) {
            return function(kv) {
                if (null === kv) throw new Error("null is not a valid " + kvStr);
                if ("undefined" == typeof kv) throw new Error(kvStr + " must not be undefined")
            }
        }

        function searchBuckets(buckets, hash) {
            for (var bucket, i = buckets.length; i--;)
                if (bucket = buckets[i], hash === bucket[0]) return i;
            return null
        }

        function getBucketForHash(bucketsByHash, hash) {
            var bucket = bucketsByHash[hash];
            return bucket && bucket instanceof Bucket ? bucket : null
        }
        var FUNCTION = "function",
            arrayRemoveAt = typeof Array.prototype.splice == FUNCTION ? function(arr, idx) {
                arr.splice(idx, 1)
            } : function(arr, idx) {
                var itemsAfterDeleted, i, len;
                if (idx === arr.length - 1) arr.length = idx;
                else
                    for (itemsAfterDeleted = arr.slice(idx + 1), arr.length = idx, i = 0, len = itemsAfterDeleted.length; len > i; ++i) arr[idx + i] = itemsAfterDeleted[i]
            },
            checkKey = createKeyValCheck("key"),
            checkValue = createKeyValCheck("value"),
            EXISTENCE = 0,
            ENTRY = 1,
            ENTRY_INDEX_AND_VALUE = 2;
        Object.subclass("Bucket", "default category", {
            initialize: function(hash, firstKey, firstValue, equalityFunction) {
                this[0] = hash, this.entries = [], this.addEntry(firstKey, firstValue), null !== equalityFunction && (this.getEqualityFunction = function() {
                    return equalityFunction
                })
            },
            createBucketSearcher: function(mode) {
                var that = this;
                return function(key) {
                    for (var entry, i = that.entries.length, equals = that.getEqualityFunction(key); i--;)
                        if (entry = that.entries[i], equals(key, entry[0])) switch (mode) {
                            case EXISTENCE:
                                return !0;
                            case ENTRY:
                                return entry;
                            case ENTRY_INDEX_AND_VALUE:
                                return [i, entry[1]]
                        }
                        return !1
                }
            },
            createBucketLister: function(entryProperty) {
                var that = this;
                return function(aggregatedArr) {
                    for (var startIndex = aggregatedArr.length, i = 0, len = that.entries.length; len > i; ++i) aggregatedArr[startIndex + i] = that.entries[i][entryProperty]
                }
            },
            getEqualityFunction: function(searchValue) {
                return typeof searchValue.equals == FUNCTION ? equals_fixedValueHasEquals : equals_fixedValueNoEquals
            },
            getEntryForKey: function(key) {
                return this.createBucketSearcher(ENTRY)(key)
            },
            getEntryAndIndexForKey: function(key) {
                return this.createBucketSearcher(ENTRY_INDEX_AND_VALUE)(key)
            },
            removeEntryForKey: function(key) {
                var result = this.getEntryAndIndexForKey(key);
                return result ? (arrayRemoveAt(this.entries, result[0]), result[1]) : null
            },
            addEntry: function(key, value) {
                this.entries[this.entries.length] = [key, value]
            },
            keys: function(aggregatedArr) {
                return this.createBucketLister(0)(aggregatedArr)
            },
            values: function(aggregatedArr) {
                return this.createBucketLister(1)(aggregatedArr)
            },
            getEntries: function(entries) {
                for (var startIndex = entries.length, i = 0, len = this.entries.length; len > i; ++i) entries[startIndex + i] = this.entries[i].slice(0)
            },
            containsKey: function(key) {
                return this.createBucketSearcher(EXISTENCE)(key)
            },
            containsValue: function(value) {
                for (var i = this.entries.length; i--;)
                    if (value === this.entries[i][1]) return !0;
                return !1
            }
        }), Object.subclass("Hashtable", "default category", {
            initialize: function(hashingFunctionParam, equalityFunctionParam) {
                this.hashingFunctionParam = hashingFunctionParam, this.equalityFunctionParam = equalityFunctionParam, this.hasCustomEqualityFunction = typeof equalityFunctionParam == FUNCTION, this.buckets = [], this.bucketsByHash = {}
            },
            hashingFunction: function(key) {
                return (typeof this.hashingFunctionParam == FUNCTION ? this.hashingFunctionParam : hashObject)(key)
            },
            equalityFunction: function(arg1, arg2) {
                return (this.hasCustomEqualityFunction ? equalityFunctionParam : function(a, b) {
                    return a == b
                })(arg1, arg2)
            },
            put: function(key, value) {
                checkKey(key), checkValue(value);
                var bucket, bucketEntry, hash = this.hashingFunction(key),
                    oldValue = null;
                return bucket = getBucketForHash(this.bucketsByHash, hash), bucket ? (bucketEntry = bucket.getEntryForKey(key), bucketEntry ? (oldValue = bucketEntry[1], bucketEntry[1] = value) : bucket.addEntry(key, value)) : (bucket = new Bucket(hash, key, value, this.hasCustomEqualityFunction ? this.equalityFunction : null), this.buckets[this.buckets.length] = bucket, this.bucketsByHash[hash] = bucket), oldValue
            },
            get: function(key) {
                checkKey(key);
                var hash = this.hashingFunction(key),
                    bucket = getBucketForHash(this.bucketsByHash, hash);
                if (bucket) {
                    var bucketEntry = bucket.getEntryForKey(key);
                    if (bucketEntry) return bucketEntry[1]
                }
                return null
            },
            containsKey: function(key) {
                checkKey(key);
                var bucketKey = this.hashingFunction(key),
                    bucket = getBucketForHash(this.bucketsByHash, bucketKey);
                return bucket ? bucket.containsKey(key) : !1
            },
            containsValue: function(value) {
                checkValue(value);
                for (var i = this.buckets.length; i--;)
                    if (this.buckets[i].containsValue(value)) return !0;
                return !1
            },
            clear: function() {
                this.buckets.length = 0, this.bucketsByHash = {}
            },
            isEmpty: function() {
                return !this.buckets.length
            },
            createBucketAggregator: function(bucketFuncName) {
                var that = this;
                return function() {
                    for (var aggregated = [], i = that.buckets.length; i--;) that.buckets[i][bucketFuncName](aggregated);
                    return aggregated
                }
            },
            keys: function() {
                return this.createBucketAggregator("keys")()
            },
            values: function() {
                return this.createBucketAggregator("values")()
            },
            entries: function() {
                return this.createBucketAggregator("getEntries")()
            },
            remove: function(key) {
                checkKey(key);
                var bucketIndex, hash = this.hashingFunction(key),
                    oldValue = null,
                    bucket = getBucketForHash(this.bucketsByHash, hash);
                return bucket && (oldValue = bucket.removeEntryForKey(key), null !== oldValue && (bucket.entries.length || (bucketIndex = searchBuckets(this.buckets, hash), arrayRemoveAt(this.buckets, bucketIndex), delete this.bucketsByHash[hash]))), oldValue
            },
            size: function() {
                for (var total = 0, i = this.buckets.length; i--;) total += this.buckets[i].entries.length;
                return total
            },
            each: function(callback) {
                for (var entry, that = this, entries = that.entries(), i = entries.length; i--;) entry = entries[i], callback(entry[0], entry[1])
            },
            escapingEach: function(callback) {
                for (var entry, that = this, entries = that.entries(), i = entries.length, context = {}; i--;) {
                    if (entry = entries[i], context = callback(entry[0], entry[1]), context && context.hasOwnProperty("return")) return context["return"];
                    if (context && context.hasOwnProperty("retval")) return context.retval;
                    if (context && context.hasOwnProperty("break")) break
                }
            },
            putAll: function(hashtable, conflictCallback) {
                for (var entry, key, value, thisValue, that = this, entries = hashtable.entries(), i = entries.length, hasConflictCallback = typeof conflictCallback == FUNCTION; i--;) entry = entries[i], key = entry[0], value = entry[1], hasConflictCallback && (thisValue = that.get(key)) && (value = conflictCallback(key, thisValue, value)), that.put(key, value)
            },
            clone: function() {
                var that = this,
                    clone = new Hashtable(this.hashingFunctionParam, this.equalityFunctionParam);
                return clone.putAll(that), clone
            }
        })
    }), module("users.timfelgentreff.cassowary.HashSet").requires("users.timfelgentreff.cassowary.Hashtable").toRun(function() {
        Object.subclass("HashSet", "default category", {
            initialize: function(hashingFunction, equalityFunction) {
                this.hashingFunction = hashingFunction, this.equalityFunction = equalityFunction, this.hashTable = new Hashtable(hashingFunction, equalityFunction)
            },
            add: function(o) {
                this.hashTable.put(o, !0)
            },
            addAll: function(arr) {
                for (var i = arr.length; i--;) this.hashTable.put(arr[i], !0)
            },
            values: function() {
                return this.hashTable.keys()
            },
            remove: function(o) {
                return this.hashTable.remove(o) ? o : null
            },
            contains: function(o) {
                return this.hashTable.containsKey(o)
            },
            clear: function() {
                this.hashTable.clear()
            },
            size: function() {
                return this.hashTable.size()
            },
            isEmpty: function() {
                return this.hashTable.isEmpty()
            },
            clone: function() {
                var h = new HashSet(this.hashingFunction, this.equalityFunction);
                return h.addAll(this.hashTable.keys()), h
            },
            intersection: function() {
                for (var val, intersection = new HashSet(this.hashingFunction, this.equalityFunction), values = this.hashSet.values(), i = values.length; i--;) val = values[i], this.hashTable.containsKey(val) && intersection.add(val);
                return intersection
            },
            union: function() {
                for (var val, union = this.clone(), values = this.hashSet.values(), i = values.length; i--;) val = values[i], this.hashTable.containsKey(val) || union.add(val);
                return union
            },
            isSubsetOf: function() {
                for (var values = this.hashTable.keys(), i = values.length; i--;)
                    if (!this.hashSet.contains(values[i])) return !1;
                return !0
            },
            each: function(f) {
                for (var e = this.hashTable.keys(), i = e.length; i-- && i >= 0;) f(this.hashTable.keys()[i])
            },
            escapingEach: function(callback) {
                return this.hashTable.escapingEach(callback)
            }
        })
    }), module("users.timfelgentreff.cassowary.DwarfCassowary").requires("users.timfelgentreff.cassowary.HashSet").toRun(function() {
        Object.extend(Global, {
            ExCLError: function() {
                return new Error("(ExCLError) An error has occured in CL")
            }
        }), Object.extend(ExCLError, {
            subclass: function(name, category, obj) {
                Global[name] = function() {
                    return new Error(obj.description())
                }
            }
        }), ExCLError.subclass("ExCLConstraintNotFound", "default category", {
            description: function() {
                return "(ExCLConstraintNotFound) Tried to remove a constraint never added to the tableu"
            }
        }), ExCLError.subclass("ExCLInternalError", "default category", {
            initialize: function(s) {
                description_ = s
            },
            description: function() {
                return "(ExCLInternalError) " + description_
            }
        }), ExCLError.subclass("ExCLNonlinearExpression", "default category", {
            description: function() {
                return "(ExCLNonlinearExpression) The resulting expression would be nonlinear"
            }
        }), ExCLError.subclass("ExCLNotEnoughStays", "default category", {
            description: function() {
                return "(ExCLNotEnoughStays) There are not enough stays to give specific values to all variables"
            }
        }), ExCLError.subclass("ExCLRequiredFailure", "default category", {
            description: function() {
                return "(ExCLRequiredFailure) A required constraint cannot be satisfied"
            }
        }), ExCLError.subclass("ExCLTooDifficult", "default category", {
            description: function() {
                return "(ExCLTooDifficult) The constraints are too difficult to solve"
            }
        }), Object.subclass("ClSymbolicWeight", "default category", {
            initialize: function(w1, w2, w3) {
                this._values = new Array(w1, w2, w3)
            },
            times: function(n) {
                return new ClSymbolicWeight(this._values[0] * n, this._values[1] * n, this._values[2] * n)
            },
            divideBy: function(n) {
                return new ClSymbolicWeight(this._values[0] / n, this._values[1] / n, this._values[2] / n)
            },
            add: function(c) {
                return new ClSymbolicWeight(this._values[0] + c._values[0], this._values[1] + c._values[1], this._values[2] + c._values[2])
            },
            subtract: function(c) {
                return new ClSymbolicWeight(this._values[0] - c._values[0], this._values[1] - c._values[1], this._values[2] - c._values[2])
            },
            lessThan: function(c) {
                for (var i = 0; i < this._values.length; ++i) {
                    if (this._values[i] < c._values[i]) return !0;
                    if (this._values[i] > c._values[i]) return !1
                }
                return !1
            },
            lessThanOrEqual: function(c) {
                for (var i = 0; i < this._values.length; ++i) {
                    if (this._values[i] < c._values[i]) return !0;
                    if (this._values[i] > c._values[i]) return !1
                }
                return !0
            },
            equal: function(c) {
                for (var i = 0; i < this._values.length; ++i)
                    if (this._values[i] != c._values[i]) return !1;
                return !0
            },
            greaterThan: function(c) {
                return !this.lessThanOrEqual(c)
            },
            greaterThanOrEqual: function(c) {
                return !this.lessThan(c)
            },
            isNegative: function() {
                return this.lessThan(ClSymbolicWeight.clsZero)
            },
            toDouble: function() {
                sum = 0, factor = 1, multiplier = 1e3;
                for (var i = this._values.length - 1; i >= 0; --i) sum += this._values[i] * factor, factor *= multiplier;
                return sum
            },
            toString: function() {
                return "[" + this._values[0] + "," + this._values[1] + "," + this._values[2] + "]"
            },
            cLevels: function() {
                return 3
            }
        }), ClSymbolicWeight.clsZero = new ClSymbolicWeight(0, 0, 0), Object.subclass("ClStrength", "default category", {
            initialize: function(name, symbolicWeight, w2, w3) {
                this._name = name, this._symbolicWeight = symbolicWeight instanceof ClSymbolicWeight ? symbolicWeight : new ClSymbolicWeight(symbolicWeight, w2, w3)
            },
            isRequired: function() {
                return this == ClStrength.required
            },
            toString: function() {
                return this._name + (this.isRequired() ? "" : ":" + this.symbolicWeight())
            },
            symbolicWeight: function() {
                return this._symbolicWeight
            },
            name: function() {
                return this._name
            },
            set_name: function(name) {
                this._name = name
            },
            set_symbolicWeight: function(symbolicWeight) {
                this._symbolicWeight = symbolicWeight
            }
        }), ClStrength.required = new ClStrength("<Required>", 1e3, 1e3, 1e3), ClStrength.strong = new ClStrength("strong", 1, 0, 0), ClStrength.medium = new ClStrength("medium", 0, 1, 0), ClStrength.weak = new ClStrength("weak", 0, 0, 1), Object.subclass("ClAbstractVariable", "default category", {
            initialize: function(a1, a2) {
                if (this.hash_code = ClAbstractVariable.iVariableNumber++, "string" == typeof a1 || null == a1) this._name = a1 || "v" + this.hash_code;
                else {
                    var varnumber = a1,
                        prefix = a2;
                    this._name = prefix + varnumber
                }
            },
            hashCode: function() {
                return this.hash_code
            },
            name: function() {
                return this._name
            },
            setName: function(name) {
                this._name = name
            },
            isDummy: function() {
                return !1
            },
            isExternal: function() {
                throw "abstract isExternal"
            },
            isPivotable: function() {
                throw "abstract isPivotable"
            },
            isRestricted: function() {
                throw "abstract isRestricted"
            },
            toString: function() {
                return "ABSTRACT[" + this._name + "]"
            }
        }), ClAbstractVariable.iVariableNumber = 1, ClAbstractVariable.subclass("ClVariable", "default category", {
            initialize: function($super, name_or_val, value) {
                this._name = "", this._value = 0, "string" == typeof name_or_val ? ($super(name_or_val), this._value = value || 0) : "number" == typeof name_or_val ? ($super(), this._value = name_or_val) : $super(), ClVariable._ourVarMap && (ClVariable._ourVarMap[this._name] = this)
            },
            isDummy: function() {
                return !1
            },
            isExternal: function() {
                return !0
            },
            isPivotable: function() {
                return !1
            },
            isRestricted: function() {
                return !1
            },
            toString: function() {
                return "[" + this.name() + ":" + this._value + "]"
            },
            value: function() {
                return this._value
            },
            set_value: function(value) {
                this._value = value
            },
            change_value: function(value) {
                this._value = value
            },
            setAttachedObject: function(o) {
                this._attachedObject = o
            },
            getAttachedObject: function() {
                return this._attachedObject
            }
        }), ClVariable.setVarMap = function(map) {
            this._ourVarMap = map
        }, ClVariable.getVarMap = function() {
            return this._ourVarMap
        }, ClAbstractVariable.subclass("ClDummyVariable", "default category", {
            initialize: function($super, name_or_val, prefix) {
                $super(name_or_val, prefix)
            },
            isDummy: function() {
                return !0
            },
            isExternal: function() {
                return !1
            },
            isPivotable: function() {
                return !1
            },
            isRestricted: function() {
                return !0
            },
            toString: function() {
                return "[" + this.name() + ":dummy]"
            }
        }), ClAbstractVariable.subclass("ClObjectiveVariable", "default category", {
            initialize: function($super, name_or_val, prefix) {
                $super(name_or_val, prefix)
            },
            isExternal: function() {
                return !1
            },
            isPivotable: function() {
                return !1
            },
            isRestricted: function() {
                return !1
            },
            toString: function() {
                return "[" + this.name() + ":obj]"
            }
        }), ClAbstractVariable.subclass("ClSlackVariable", "default category", {
            initialize: function($super, name_or_val, prefix) {
                $super(name_or_val, prefix)
            },
            isExternal: function() {
                return !1
            },
            isPivotable: function() {
                return !0
            },
            isRestricted: function() {
                return !0
            },
            toString: function() {
                return "[" + this.name() + ":slack]"
            }
        }), Object.subclass("ClPoint", "default category", {
            initialize: function(x, y, suffix) {
                this.x = x instanceof ClVariable ? x : null != suffix ? new ClVariable("x" + suffix, x) : new ClVariable(x), this.y = y instanceof ClVariable ? y : null != suffix ? new ClVariable("y" + suffix, y) : new ClVariable(y)
            },
            SetXY: function(x, y) {
                x instanceof ClVariable ? this.x = x : this.x.set_value(x), y instanceof ClVariable ? this.y = y : this.y.set_value(y)
            },
            X: function() {
                return this.x
            },
            Y: function() {
                return this.y
            },
            Xvalue: function() {
                return this.x.value()
            },
            Yvalue: function() {
                return this.y.value()
            },
            toString: function() {
                return "(" + this.x + ", " + this.y + ")"
            }
        }), Object.subclass("ClLinearExpression", "default category", {
            initialize: function(clv, value, constant) {
                CL.fGC && print("new ClLinearExpression"), this._constant = constant || 0, this._terms = new Hashtable, clv instanceof ClAbstractVariable ? this._terms.put(clv, value || 1) : "number" == typeof clv && (this._constant = clv)
            },
            initializeFromHash: function(constant, terms) {
                return CL.fGC && print("clone ClLinearExpression"), this._constant = constant, this._terms = terms.clone(), this
            },
            multiplyMe: function(x) {
                var that = this;
                return this._constant *= x, this._terms.each(function(clv, coeff) {
                    that._terms.put(clv, coeff * x)
                }), this
            },
            clone: function() {
                return (new ClLinearExpression).initializeFromHash(this._constant, this._terms)
            },
            times: function(x) {
                if ("number" == typeof x) return this.clone().multiplyMe(x);
                if (this.isConstant()) return x.times(this._constant);
                if (x.isConstant()) return this.times(x._constant);
                throw new ExCLNonlinearExpression
            },
            plus: function(expr) {
                return expr instanceof ClLinearExpression ? this.clone().addExpression(expr, 1) : expr instanceof ClVariable ? this.clone().addVariable(expr, 1) : void 0
            },
            minus: function(expr) {
                return expr instanceof ClLinearExpression ? this.clone().addExpression(expr, -1) : expr instanceof ClVariable ? this.clone().addVariable(expr, -1) : void 0
            },
            divide: function(x) {
                if ("number" == typeof x) {
                    if (CL.approx(x, 0)) throw new ExCLNonlinearExpression;
                    return this.times(1 / x)
                }
                if (x instanceof ClLinearExpression) {
                    if (!x.isConstant) throw new ExCLNonlinearExpression;
                    return this.times(1 / x._constant)
                }
            },
            divFrom: function() {
                if (!this.isConstant() || CL.approx(this._constant, 0)) throw new ExCLNonlinearExpression;
                return x.divide(this._constant)
            },
            subtractFrom: function(expr) {
                return expr.minus(this)
            },
            addExpression: function(expr, n, subject, solver) {
                expr instanceof ClAbstractVariable && (expr = new ClLinearExpression(expr), print("addExpression: Had to cast a var to an expression")), this.incrementConstant(n * expr.constant()), n = n || 1;
                var that = this;
                return expr.terms().each(function(clv, coeff) {
                    that.addVariable(clv, coeff * n, subject, solver)
                }), this
            },
            addVariable: function(v, c, subject, solver) {
                return c = c || 1, CL.fTraceOn && CL.fnenterprint("CLE: addVariable:" + v + ", " + c), coeff = this._terms.get(v), coeff ? (new_coefficient = coeff + c, CL.approx(new_coefficient, 0) ? (solver && solver.noteRemovedVariable(v, subject), this._terms.remove(v)) : this._terms.put(v, new_coefficient)) : CL.approx(c, 0) || (this._terms.put(v, c), solver && solver.noteAddedVariable(v, subject)), this
            },
            setVariable: function(v, c) {
                return this._terms.put(v, c), this
            },
            anyPivotableVariable: function() {
                if (this.isConstant()) throw new ExCLInternalError("anyPivotableVariable called on a constant");
                var pivotable = null;
                try {
                    this._terms.each(function(clv) {
                        if (clv.isPivotable()) throw pivotable = clv, "NLR"
                    })
                } catch (e) {
                    if ("NLR" === e) return pivotable;
                    throw e
                }
                return null
            },
            substituteOut: function(outvar, expr, subject, solver) {
                var that = this;
                CL.fTraceOn && (CL.fnenterprint("CLE:substituteOut: " + outvar + ", " + expr + ", " + subject + ", ..."), CL.traceprint("this = " + this));
                var multiplier = this._terms.remove(outvar);
                this.incrementConstant(multiplier * expr.constant()), expr.terms().each(function(clv, coeff) {
                    var old_coeff = that._terms.get(clv);
                    if (old_coeff) {
                        var newCoeff = old_coeff + multiplier * coeff;
                        CL.approx(newCoeff, 0) ? (solver.noteRemovedVariable(clv, subject), that._terms.remove(clv)) : that._terms.put(clv, newCoeff)
                    } else that._terms.put(clv, multiplier * coeff), solver.noteAddedVariable(clv, subject)
                }), CL.fTraceOn && CL.traceprint("Now this is " + this)
            },
            changeSubject: function(old_subject, new_subject) {
                this._terms.put(old_subject, this.newSubject(new_subject))
            },
            newSubject: function(subject) {
                CL.fTraceOn && CL.fnenterprint("newSubject:" + subject);
                var reciprocal = 1 / this._terms.remove(subject);
                return this.multiplyMe(-reciprocal), reciprocal
            },
            coefficientFor: function(clv) {
                return this._terms.get(clv) || 0
            },
            constant: function() {
                return this._constant
            },
            set_constant: function(c) {
                this._constant = c
            },
            terms: function() {
                return this._terms
            },
            incrementConstant: function(c) {
                this._constant += c
            },
            isConstant: function() {
                return 0 == this._terms.size()
            },
            toString: function() {
                var bstr = "",
                    needsplus = !1;
                if (!CL.approx(this._constant, 0) || this.isConstant()) {
                    if (bstr += this._constant, this.isConstant()) return bstr;
                    needsplus = !0
                }
                return this._terms.each(function(clv, coeff) {
                    needsplus && (bstr += " + "), bstr += coeff + "*" + clv, needsplus = !0
                }), bstr
            },
            Plus: function(e1, e2) {
                return e1.plus(e2)
            },
            Minus: function(e1, e2) {
                return e1.minus(e2)
            },
            Times: function(e1, e2) {
                return e1.times(e2)
            },
            Divide: function(e1, e2) {
                return e1.divide(e2)
            }
        }), Object.subclass("ClConstraint", "default category", {
            initialize: function(strength, weight) {
                this.hash_code = ClConstraint.iConstraintNumber++, this._strength = strength || ClStrength.required, this._weight = weight || 1, this._times_added = 0
            },
            hashCode: function() {
                return this.hash_code
            },
            isEditConstraint: function() {
                return !1
            },
            isInequality: function() {
                return !1
            },
            isRequired: function() {
                return this._strength.isRequired()
            },
            isStayConstraint: function() {
                return !1
            },
            strength: function() {
                return this._strength
            },
            weight: function() {
                return this._weight
            },
            toString: function() {
                return this._strength + " {" + this._weight + "} (" + this.expression() + ")"
            },
            setAttachedObject: function(o) {
                this._attachedObject = o
            },
            getAttachedObject: function() {
                return this._attachedObject
            },
            changeStrength: function(strength) {
                if (0 != this._times_added) throw new ExCLTooDifficult;
                this.setStrength(strength)
            },
            addedTo: function() {
                ++this._times_added
            },
            removedFrom: function() {
                --this._times_added
            },
            setStrength: function(strength) {
                this._strength = strength
            },
            setWeight: function(weight) {
                this._weight = weight
            }
        }), ClConstraint.subclass("ClEditOrStayConstraint", "default category", {
            initialize: function($super, clv, strength, weight) {
                $super(strength, weight), this._variable = clv, this._expression = new ClLinearExpression(this._variable, -1, this._variable.value())
            },
            variable: function() {
                return this._variable
            },
            expression: function() {
                return this._expression
            },
            setVariable: function(v) {
                this._variable = v
            }
        }), ClEditOrStayConstraint.subclass("ClEditConstraint", "default category", {
            initialize: function($super, clv, strength, weight) {
                $super(clv, strength, weight)
            },
            isEditConstraint: function() {
                return !0
            },
            toString: function() {
                return "edit" + $super()
            }
        }), ClEditOrStayConstraint.subclass("ClStayConstraint", "default category", {
            initialize: function($super, clv, strength, weight) {
                $super(clv, strength || ClStrength.weak, weight)
            },
            isStayConstraint: function() {
                return !0
            },
            toString: function() {
                return "stay " + $super()
            }
        }), ClConstraint.iConstraintNumber = 1, ClConstraint.subclass("ClLinearConstraint", "default category", {
            initialize: function($super, cle, strength, weight) {
                $super(strength, weight), this._expression = cle
            },
            expression: function() {
                return this._expression
            },
            setExpression: function(expr) {
                this._expression = expr
            }
        }), ClLinearConstraint.subclass("ClLinearInequality", "default category", {
            initialize: function($super, a1, a2, a3, a4, a5) {
                if (a1 instanceof ClLinearExpression && a3 instanceof ClAbstractVariable) {
                    var cle = a1,
                        op = a2,
                        clv = a3,
                        strength = a4,
                        weight = a5;
                    if ($super(cle.clone(), strength, weight), op == CL.LEQ) this._expression.multiplyMe(-1), this._expression.addVariable(clv);
                    else {
                        if (op != CL.GEQ) throw new ExCLInternalError("Invalid operator in ClLinearInequality constructor");
                        this._expression.addVariable(clv, -1)
                    }
                } else {
                    if (a1 instanceof ClLinearExpression) return $super(a1, a2, a3);
                    if (a2 == CL.GEQ) $super(new ClLinearExpression(a3), a4, a5), this._expression.multiplyMe(-1), this._expression.addVariable(a1);
                    else {
                        if (a2 != CL.LEQ) throw new ExCLInternalError("Invalid operator in ClLinearInequality constructor");
                        $super(new ClLinearExpression(a3), a4, a5), this._expression.addVariable(a1, -1)
                    }
                }
            },
            isInequality: function() {
                return !0
            },
            toString: function($super) {
                return $super() + " >= 0)"
            }
        }), ClLinearConstraint.subclass("ClLinearEquation", "default category", {
            initialize: function($super, a1, a2, a3, a4) {
                if (a1 instanceof ClLinearExpression && !a2 || a2 instanceof ClStrength) $super(a1, a2, a3);
                else if (a1 instanceof ClAbstractVariable && a2 instanceof ClLinearExpression) {
                    var clv = a1,
                        cle = a2,
                        strength = a3,
                        weight = a4;
                    $super(cle, strength, weight), this._expression.addVariable(clv, -1)
                } else if (a1 instanceof ClAbstractVariable && "number" == typeof a2) {
                    var clv = a1,
                        val = a2,
                        strength = a3,
                        weight = a4;
                    $super(new ClLinearExpression(val), strength, weight), this._expression.addVariable(clv, -1)
                } else if (a1 instanceof ClLinearExpression && a2 instanceof ClAbstractVariable) {
                    var cle = a1,
                        clv = a2,
                        strength = a3,
                        weight = a4;
                    $super(cle.clone(), strength, weight), this._expression.addVariable(clv, -1)
                } else {
                    if (!(a1 instanceof ClLinearExpression || a1 instanceof ClAbstractVariable || "number" == typeof a1) || !(a2 instanceof ClLinearExpression || a2 instanceof ClAbstractVariable || "number" == typeof a2)) throw "Bad initializer to ClLinearEquation";
                    a1 = a1 instanceof ClLinearExpression ? a1.clone() : new ClLinearExpression(a1), a2 = a2 instanceof ClLinearExpression ? a2.clone() : new ClLinearExpression(a2), $super(a1, a3, a4), this._expression.addExpression(a2, -1)
                }
                CL.Assert(this._strength instanceof ClStrength, "_strength not set")
            },
            toString: function() {
                return $super() + " = 0)"
            }
        }), Object.subclass("ClEditInfo", "default category", {
            initialize: function(cn_, eplus_, eminus_, prevEditConstant_, i_) {
                this.cn = cn_, this.clvEditPlus = eplus_, this.clvEditMinus = eminus_, this.prevEditConstant = prevEditConstant_, this.i = i_
            },
            Index: function() {
                return this.i
            },
            Constraint: function() {
                return this.cn
            },
            ClvEditPlus: function() {
                return this.clvEditPlus
            },
            ClvEditMinus: function() {
                return this.clvEditMinus
            },
            PrevEditConstant: function() {
                return this.prevEditConstant
            },
            SetPrevEditConstant: function(prevEditConstant_) {
                this.prevEditConstant = prevEditConstant_
            },
            toString: function() {
                return "<cn=" + this.cn + ",ep=" + this.clvEditPlus + ",em=" + this.clvEditMinus + ",pec=" + this.prevEditConstant + ",i=" + i + ">"
            }
        }), Object.subclass("ClTableau", "default category", {
            initialize: function() {
                this._columns = new Hashtable, this._rows = new Hashtable, this._infeasibleRows = new HashSet, this._externalRows = new HashSet, this._externalParametricVars = new HashSet
            },
            noteRemovedVariable: function(v, subject) {
                CL.fVerboseTraceOn && CL.fnenterprint("noteRemovedVariable: " + v + ", " + subject), null != subject && this._columns.get(v).remove(subject)
            },
            noteAddedVariable: function(v, subject) {
                CL.fVerboseTraceOn && CL.fnenterprint("noteAddedVariable: " + v + ", " + subject), subject && this.insertColVar(v, subject)
            },
            getInternalInfo: function() {
                var retstr = "Tableau Information:\n";
                return retstr += "Rows: " + this._rows.size(), retstr += " (= " + (this._rows.size() - 1) + " constraints)", retstr += "\nColumns: " + this._columns.size(), retstr += "\nInfeasible Rows: " + this._infeasibleRows.size(), retstr += "\nExternal basic variables: " + this._externalRows.size(), retstr += "\nExternal parametric variables: ", retstr += this._externalParametricVars.size(), retstr += "\n"
            },
            toString: function() {
                var bstr = "Tableau:\n";
                return this._rows.each(function(clv, expr) {
                    bstr += clv, bstr += " <==> ", bstr += expr, bstr += "\n"
                }), bstr += "\nColumns:\n", bstr += CL.hashToString(this._columns), bstr += "\nInfeasible rows: ", bstr += CL.setToString(this._infeasibleRows), bstr += "External basic variables: ", bstr += CL.setToString(this._externalRows), bstr += "External parametric variables: ", bstr += CL.setToString(this._externalParametricVars)
            },
            insertColVar: function(param_var, rowvar) {
                var rowset = this._columns.get(param_var);
                rowset || this._columns.put(param_var, rowset = new HashSet), rowset.add(rowvar)
            },
            addRow: function(aVar, expr) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("addRow: " + aVar + ", " + expr), this._rows.put(aVar, expr), expr.terms().each(function(clv) {
                    that.insertColVar(clv, aVar), clv.isExternal() && that._externalParametricVars.add(clv)
                }), aVar.isExternal() && this._externalRows.add(aVar), CL.fTraceOn && CL.traceprint(this.toString())
            },
            removeColumn: function(aVar) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("removeColumn:" + aVar);
                var rows = this._columns.remove(aVar);
                rows ? rows.each(function(clv) {
                    var expr = that._rows.get(clv);
                    expr.terms().remove(aVar)
                }) : CL.fTraceOn && CL.debugprint("Could not find var " + aVar + " in _columns"), aVar.isExternal() && (this._externalRows.remove(aVar), this._externalParametricVars.remove(aVar))
            },
            removeRow: function(aVar) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("removeRow:" + aVar);
                var expr = this._rows.get(aVar);
                return CL.Assert(null != expr), expr.terms().each(function(clv) {
                    var varset = that._columns.get(clv);
                    null != varset && (CL.fTraceOn && CL.debugprint("removing from varset " + aVar), varset.remove(aVar))
                }), this._infeasibleRows.remove(aVar), aVar.isExternal() && this._externalRows.remove(aVar), this._rows.remove(aVar), CL.fTraceOn && CL.fnexitprint("returning " + expr), expr
            },
            substituteOut: function(oldVar, expr) {
                var that = this;
                CL.fTraceOn && (CL.fnenterprint("substituteOut:" + oldVar + ", " + expr), CL.traceprint(this.toString()));
                var varset = this._columns.get(oldVar);
                varset.each(function(v) {
                    var row = that._rows.get(v);
                    row.substituteOut(oldVar, expr, v, that), v.isRestricted() && row.constant() < 0 && that._infeasibleRows.add(v)
                }), oldVar.isExternal() && (this._externalRows.add(oldVar), this._externalParametricVars.remove(oldVar)), this._columns.remove(oldVar)
            },
            columns: function() {
                return this._columns
            },
            rows: function() {
                return this._rows
            },
            columnsHasKey: function(subject) {
                return null != this._columns.get(subject)
            },
            rowExpression: function(v) {
                return this._rows.get(v)
            }
        }), ClTableau.subclass("ClSimplexSolver", "default category", {
            initialize: function($super) {
                $super(), this._stayMinusErrorVars = new Array, this._stayPlusErrorVars = new Array, this._errorVars = new Hashtable, this._markerVars = new Hashtable, this._resolve_pair = new Array(0, 0), this._objective = new ClObjectiveVariable("Z"), this._editVarMap = new Hashtable, this._slackCounter = 0, this._artificialCounter = 0, this._dummyCounter = 0, this._epsilon = 1e-8, this._fOptimizeAutomatically = !0, this._fNeedsSolving = !1, this._rows = new Hashtable, this._rows.put(this._objective, new ClLinearExpression), this._stkCedcns = new Array, this._stkCedcns.push(0), CL.fTraceOn && CL.traceprint("objective expr == " + this.rowExpression(this._objective))
            },
            addLowerBound: function(v, lower) {
                var cn = new ClLinearInequality(v, CL.GEQ, new ClLinearExpression(lower));
                return this.addConstraint(cn)
            },
            addUpperBound: function(v, upper) {
                var cn = new ClLinearInequality(v, CL.LEQ, new ClLinearExpression(upper));
                return this.addConstraint(cn)
            },
            addBounds: function(v, lower, upper) {
                return this.addLowerBound(v, lower), this.addUpperBound(v, upper), this
            },
            addConstraint: function(cn) {
                CL.fTraceOn && CL.fnenterprint("addConstraint: " + cn);
                var eplus_eminus = new Array(2),
                    prevEConstant = new Array(1),
                    expr = this.newExpression(cn, eplus_eminus, prevEConstant);
                prevEConstant = prevEConstant[0];
                var fAddedOkDirectly = !1;
                if (fAddedOkDirectly = this.tryAddingDirectly(expr), fAddedOkDirectly || this.addWithArtificialVariable(expr), this._fNeedsSolving = !0, cn.isEditConstraint()) {
                    var i = this._editVarMap.size(),
                        clvEplus = eplus_eminus[0],
                        clvEminus = eplus_eminus[1];
                    !clvEplus instanceof ClSlackVariable && print("clvEplus not a slack variable = " + clvEplus), !clvEminus instanceof ClSlackVariable && print("clvEminus not a slack variable = " + clvEminus), this._editVarMap.put(cn.variable(), new ClEditInfo(cn, clvEplus, clvEminus, prevEConstant, i))
                }
                return this._fOptimizeAutomatically && (this.optimize(this._objective), this.setExternalVariables()), cn.addedTo(this), cn
            },
            addConstraintNoException: function(cn) {
                CL.fTraceOn && CL.fnenterprint("addConstraintNoException: " + cn);
                try {
                    return this.addConstraint(cn), !0
                } catch (e) {
                    return !1
                }
            },
            addEditVar: function(v, strength) {
                CL.fTraceOn && CL.fnenterprint("addEditVar: " + v + " @ " + strength), strength = strength || ClStrength.strong;
                var cnEdit = new ClEditConstraint(v, strength);
                return this.addConstraint(cnEdit)
            },
            removeEditVar: function(v) {
                var cei = this._editVarMap.get(v),
                    cn = cei.Constraint();
                return this.removeConstraint(cn), this
            },
            beginEdit: function() {
                return this.solve(), CL.Assert(this._editVarMap.size() > 0, "_editVarMap.size() > 0"), this._infeasibleRows.clear(), this.resetStayConstants(), this._stkCedcns.push(this._editVarMap.size()), this
            },
            endEdit: function() {
                CL.Assert(this._editVarMap.size() > 0, "_editVarMap.size() > 0"), this.resolve(), this._stkCedcns.pop();
                var n = this._stkCedcns[this._stkCedcns.length - 1];
                return this.removeEditVarsTo(n), this
            },
            removeAllEditVars: function() {
                return this.removeEditVarsTo(0)
            },
            removeEditVarsTo: function(n) {
                try {
                    var that = this;
                    return this._editVarMap.each(function(v, cei) {
                        cei.Index() >= n && that.removeEditVar(v)
                    }), CL.Assert(this._editVarMap.size() == n, "_editVarMap.size() == n"), this
                } catch (e) {
                    throw new ExCLInternalError("Constraint not found in removeEditVarsTo")
                }
            },
            addPointStays: function(listOfPoints) {
                CL.fTraceOn && CL.fnenterprint("addPointStays" + listOfPoints);
                for (var weight = 1, multiplier = 2, i = 0; i < listOfPoints.length; i++) this.addPointStay(listOfPoints[i], weight), weight *= multiplier;
                return this
            },
            addPointStay: function(a1, a2, a3) {
                if (a1 instanceof ClPoint) {
                    var clp = a1,
                        weight = a2;
                    this.addStay(clp.X(), ClStrength.weak, weight || 1), this.addStay(clp.Y(), ClStrength.weak, weight || 1)
                } else {
                    var vx = a1,
                        vy = a2,
                        weight = a3;
                    this.addStay(vx, ClStrength.weak, weight || 1), this.addStay(vy, ClStrength.weak, weight || 1)
                }
                return this
            },
            addStay: function(v, strength, weight) {
                var cn = new ClStayConstraint(v, strength || ClStrength.weak, weight || 1);
                return this.addConstraint(cn)
            },
            removeConstraint: function(cn) {
                return this.removeConstraintInternal(cn), cn.removedFrom(this), this
            },
            removeConstraintInternal: function(cn) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("removeConstraint: " + cn), CL.fTraceOn && CL.traceprint(this.toString()), this._fNeedsSolving = !0, this.resetStayConstants();
                var zRow = this.rowExpression(this._objective),
                    eVars = this._errorVars.get(cn);
                CL.fTraceOn && CL.traceprint("eVars == " + CL.setToString(eVars)), null != eVars && eVars.each(function(clv) {
                    var expr = that.rowExpression(clv);
                    null == expr ? zRow.addVariable(clv, -cn.weight() * cn.strength().symbolicWeight().toDouble(), that._objective, that) : zRow.addExpression(expr, -cn.weight() * cn.strength().symbolicWeight().toDouble(), that._objective, that), CL.fTraceOn && CL.traceprint("now eVars == " + CL.setToString(eVars))
                });
                var marker = this._markerVars.remove(cn);
                if (null == marker) throw new ExCLConstraintNotFound;
                if (CL.fTraceOn && CL.traceprint("Looking to remove var " + marker), null == this.rowExpression(marker)) {
                    var col = this._columns.get(marker);
                    CL.fTraceOn && CL.traceprint("Must pivot -- columns are " + col);
                    var exitVar = null,
                        minRatio = 0;
                    col.each(function(v) {
                        if (v.isRestricted()) {
                            var expr = that.rowExpression(v),
                                coeff = expr.coefficientFor(marker);
                            if (that.fTraceOn && that.traceprint("Marker " + marker + "'s coefficient in " + expr + " is " + coeff), 0 > coeff) {
                                var r = -expr.constant() / coeff;
                                (null == exitVar || minRatio > r || CL.approx(r, minRatio) && v.hashCode() < exitVar.hashCode()) && (minRatio = r, exitVar = v)
                            }
                        }
                    }), null == exitVar && (CL.fTraceOn && CL.traceprint("exitVar is still null"), col.each(function(v) {
                        if (v.isRestricted()) {
                            var expr = that.rowExpression(v),
                                coeff = expr.coefficientFor(marker),
                                r = expr.constant() / coeff;
                            (null == exitVar || minRatio > r) && (minRatio = r, exitVar = v)
                        }
                    })), null == exitVar && (0 == col.size() ? this.removeColumn(marker) : col.escapingEach(function(v) {
                        return v != that._objective ? (exitVar = v, {
                            brk: !0
                        }) : void 0
                    })), null != exitVar && this.pivot(marker, exitVar)
                }
                if (null != this.rowExpression(marker)) {
                    var expr = this.removeRow(marker);
                    expr = null
                }
                if (null != eVars && eVars.each(function(v) {
                        v != marker && (that.removeColumn(v), v = null)
                    }), cn.isStayConstraint()) {
                    if (null != eVars)
                        for (var i = 0; i < this._stayPlusErrorVars.length; i++) eVars.remove(this._stayPlusErrorVars[i]), eVars.remove(this._stayMinusErrorVars[i])
                } else if (cn.isEditConstraint()) {
                    CL.Assert(null != eVars, "eVars != null");
                    var cnEdit = cn,
                        clv = cnEdit.variable(),
                        cei = this._editVarMap.get(clv),
                        clvEditMinus = cei.ClvEditMinus();
                    this.removeColumn(clvEditMinus), this._editVarMap.remove(clv)
                }
                return null != eVars && this._errorVars.remove(eVars), marker = null, this._fOptimizeAutomatically && (this.optimize(this._objective), this.setExternalVariables()), this
            },
            reset: function() {
                throw CL.fTraceOn && CL.fnenterprint("reset"), new ExCLInternalError("reset not implemented")
            },
            resolveArray: function(newEditConstants) {
                CL.fTraceOn && CL.fnenterprint("resolveArray" + newEditConstants);
                var that = this;
                this._editVarMap.each(function(v, cei) {
                    var i = cei.Index();
                    i < newEditConstants.length && that.suggestValue(v, newEditConstants[i])
                }), this.resolve()
            },
            resolvePair: function(x, y) {
                this._resolve_pair[0] = x, this._resolve_pair[1] = y, this.resolveArray(this._resolve_pair)
            },
            resolve: function() {
                CL.fTraceOn && CL.fnenterprint("resolve()"), this.dualOptimize(), this.setExternalVariables(), this._infeasibleRows.clear(), this.resetStayConstants()
            },
            suggestValue: function(v, x) {
                CL.fTraceOn && CL.fnenterprint("suggestValue(" + v + ", " + x + ")");
                var cei = this._editVarMap.get(v);
                if (null == cei) throw print("suggestValue for variable " + v + ", but var is not an edit variable\n"), new ExCLError;
                cei.Index();
                var clvEditPlus = cei.ClvEditPlus(),
                    clvEditMinus = cei.ClvEditMinus(),
                    delta = x - cei.PrevEditConstant();
                return cei.SetPrevEditConstant(x), this.deltaEditConstant(delta, clvEditPlus, clvEditMinus), this
            },
            setAutosolve: function(f) {
                return this._fOptimizeAutomatically = f, this
            },
            FIsAutosolving: function() {
                return this._fOptimizeAutomatically
            },
            solve: function() {
                return this._fNeedsSolving && (this.optimize(this._objective), this.setExternalVariables()), this
            },
            setEditedValue: function(v, n) {
                if (!this.FContainsVariable(v)) return v.change_value(n), this;
                if (!CL.approx(n, v.value())) {
                    this.addEditVar(v), this.beginEdit();
                    try {
                        this.suggestValue(v, n)
                    } catch (e) {
                        throw new ExCLInternalError("Error in setEditedValue")
                    }
                    this.endEdit()
                }
                return this
            },
            FContainsVariable: function(v) {
                return this.columnsHasKey(v) || null != this.rowExpression(v)
            },
            addVar: function(v) {
                if (!this.FContainsVariable(v)) {
                    try {
                        this.addStay(v)
                    } catch (e) {
                        throw new ExCLInternalError("Error in addVar -- required failure is impossible")
                    }
                    CL.fTraceOn && CL.traceprint("added initial stay on " + v)
                }
                return this
            },
            getInternalInfo: function($super) {
                var retstr = $super();
                return retstr += "\nSolver info:\n", retstr += "Stay Error Variables: ", retstr += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length, retstr += " (" + this._stayPlusErrorVars.length + " +, ", retstr += this._stayMinusErrorVars.length + " -)\n", retstr += "Edit Variables: " + this._editVarMap.size(), retstr += "\n"
            },
            getDebugInfo: function() {
                var bstr = this.toString();
                return bstr += this.getInternalInfo(), bstr += "\n"
            },
            toString: function($super) {
                var bstr = $super();
                return bstr += "\n_stayPlusErrorVars: ", bstr += "[" + this._stayPlusErrorVars + "]", bstr += "\n_stayMinusErrorVars: ", bstr += "[" + this._stayMinusErrorVars + "]", bstr += "\n", bstr += "_editVarMap:\n" + CL.hashToString(this._editVarMap), bstr += "\n"
            },
            getConstraintMap: function() {
                return this._markerVars
            },
            addWithArtificialVariable: function(expr) {
                CL.fTraceOn && CL.fnenterprint("addWithArtificialVariable: " + expr);
                var av = new ClSlackVariable(++this._artificialCounter, "a"),
                    az = new ClObjectiveVariable("az"),
                    azRow = expr.clone();
                CL.fTraceOn && CL.traceprint("before addRows:\n" + this), this.addRow(az, azRow), this.addRow(av, expr), CL.fTraceOn && CL.traceprint("after addRows:\n" + this), this.optimize(az);
                var azTableauRow = this.rowExpression(az);
                if (CL.fTraceOn && CL.traceprint("azTableauRow.constant() == " + azTableauRow.constant()), !CL.approx(azTableauRow.constant(), 0)) throw this.removeRow(az), this.removeColumn(av), new ExCLRequiredFailure;
                var e = this.rowExpression(av);
                if (null != e) {
                    if (e.isConstant()) return this.removeRow(av), this.removeRow(az), void 0;
                    var entryVar = e.anyPivotableVariable();
                    this.pivot(entryVar, av)
                }
                CL.Assert(null == this.rowExpression(av), "rowExpression(av) == null"), this.removeColumn(av), this.removeRow(az)
            },
            tryAddingDirectly: function(expr) {
                CL.fTraceOn && CL.fnenterprint("tryAddingDirectly: " + expr);
                var subject = this.chooseSubject(expr);
                return null == subject ? (CL.fTraceOn && CL.fnexitprint("returning false"), !1) : (expr.newSubject(subject), this.columnsHasKey(subject) && this.substituteOut(subject, expr), this.addRow(subject, expr), CL.fTraceOn && CL.fnexitprint("returning true"), !0)
            },
            chooseSubject: function(expr) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("chooseSubject: " + expr);
                var subject = null,
                    foundUnrestricted = !1,
                    foundNewRestricted = !1,
                    terms = expr.terms(),
                    rv = terms.escapingEach(function(v, c) {
                        if (foundUnrestricted) {
                            if (!v.isRestricted() && !that.columnsHasKey(v)) return {
                                retval: v
                            }
                        } else if (v.isRestricted()) {
                            if (!foundNewRestricted && !v.isDummy() && 0 > c) {
                                var col = that._columns.get(v);
                                (null == col || 1 == col.size() && that.columnsHasKey(that._objective)) && (subject = v, foundNewRestricted = !0)
                            }
                        } else subject = v, foundUnrestricted = !0
                    });
                if (void 0 !== rv) return rv;
                if (null != subject) return subject;
                var coeff = 0,
                    rv = terms.escapingEach(function(v, c) {
                        return v.isDummy() ? (that.columnsHasKey(v) || (subject = v, coeff = c), void 0) : {
                            retval: null
                        }
                    });
                if (void 0 !== rv) return rv;
                if (!CL.approx(expr.constant(), 0)) throw new ExCLRequiredFailure;
                return coeff > 0 && expr.multiplyMe(-1), subject
            },
            deltaEditConstant: function(delta, plusErrorVar, minusErrorVar) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("deltaEditConstant :" + delta + ", " + plusErrorVar + ", " + minusErrorVar);
                var exprPlus = this.rowExpression(plusErrorVar);
                if (null != exprPlus) return exprPlus.incrementConstant(delta), exprPlus.constant() < 0 && this._infeasibleRows.add(plusErrorVar), void 0;
                var exprMinus = this.rowExpression(minusErrorVar);
                if (null != exprMinus) return exprMinus.incrementConstant(-delta), exprMinus.constant() < 0 && this._infeasibleRows.add(minusErrorVar), void 0;
                var columnVars = this._columns.get(minusErrorVar);
                columnVars || print("columnVars is null -- tableau is:\n" + this), columnVars.each(function(basicVar) {
                    var expr = that.rowExpression(basicVar),
                        c = expr.coefficientFor(minusErrorVar);
                    expr.incrementConstant(c * delta), basicVar.isRestricted() && expr.constant() < 0 && that._infeasibleRows.add(basicVar)
                })
            },
            dualOptimize: function() {
                CL.fTraceOn && CL.fnenterprint("dualOptimize:");
                for (var zRow = this.rowExpression(this._objective); !this._infeasibleRows.isEmpty();) {
                    var exitVar = this._infeasibleRows.values()[0];
                    this._infeasibleRows.remove(exitVar);
                    var entryVar = null,
                        expr = this.rowExpression(exitVar);
                    if (null != expr && expr.constant() < 0) {
                        var r, ratio = Number.MAX_VALUE,
                            terms = expr.terms();
                        if (terms.each(function(v, c) {
                                if (c > 0 && v.isPivotable()) {
                                    var zc = zRow.coefficientFor(v);
                                    r = zc / c, (ratio > r || CL.approx(r, ratio) && v.hashCode() < entryVar.hashCode()) && (entryVar = v, ratio = r)
                                }
                            }), ratio == Number.MAX_VALUE) throw new ExCLInternalError("ratio == nil (MAX_VALUE) in dualOptimize");
                        this.pivot(entryVar, exitVar)
                    }
                }
            },
            newExpression: function(cn, eplus_eminus, prevEConstant) {
                var that = this;
                CL.fTraceOn && (CL.fnenterprint("newExpression: " + cn), CL.traceprint("cn.isInequality() == " + cn.isInequality()), CL.traceprint("cn.isRequired() == " + cn.isRequired()));
                var cnExpr = cn.expression(),
                    expr = new ClLinearExpression(cnExpr.constant()),
                    slackVar = new ClSlackVariable,
                    dummyVar = new ClDummyVariable,
                    eminus = new ClSlackVariable,
                    eplus = new ClSlackVariable,
                    cnTerms = cnExpr.terms();
                if (cnTerms.each(function(v, c) {
                        var e = that.rowExpression(v);
                        null == e ? expr.addVariable(v, c) : expr.addExpression(e, c)
                    }), cn.isInequality()) {
                    if (++this._slackCounter, slackVar = new ClSlackVariable(this._slackCounter, "s"), expr.setVariable(slackVar, -1), this._markerVars.put(cn, slackVar), !cn.isRequired()) {
                        ++this._slackCounter, eminus = new ClSlackVariable(this._slackCounter, "em"), expr.setVariable(eminus, 1);
                        var zRow = this.rowExpression(this._objective),
                            sw = cn.strength().symbolicWeight().times(cn.weight());
                        zRow.setVariable(eminus, sw.toDouble()), this.insertErrorVar(cn, eminus), this.noteAddedVariable(eminus, this._objective)
                    }
                } else if (cn.isRequired()) ++this._dummyCounter, dummyVar = new ClDummyVariable(this._dummyCounter, "d"), expr.setVariable(dummyVar, 1), this._markerVars.put(cn, dummyVar), CL.fTraceOn && CL.traceprint("Adding dummyVar == d" + this._dummyCounter);
                else {
                    ++this._slackCounter, eplus = new ClSlackVariable(this._slackCounter, "ep"), eminus = new ClSlackVariable(this._slackCounter, "em"), expr.setVariable(eplus, -1), expr.setVariable(eminus, 1), this._markerVars.put(cn, eplus);
                    var zRow = this.rowExpression(this._objective),
                        sw = cn.strength().symbolicWeight().times(cn.weight()),
                        swCoeff = sw.toDouble();
                    0 == swCoeff && CL.fTraceOn && (CL.traceprint("sw == " + sw), CL.traceprint("cn == " + cn), CL.traceprint("adding " + eplus + " and " + eminus + " with swCoeff == " + swCoeff)), zRow.setVariable(eplus, swCoeff), this.noteAddedVariable(eplus, this._objective), zRow.setVariable(eminus, swCoeff), this.noteAddedVariable(eminus, this._objective), this.insertErrorVar(cn, eminus), this.insertErrorVar(cn, eplus), cn.isStayConstraint() ? (this._stayPlusErrorVars.push(eplus), this._stayMinusErrorVars.push(eminus)) : cn.isEditConstraint() && (eplus_eminus[0] = eplus, eplus_eminus[1] = eminus, prevEConstant[0] = cnExpr.constant())
                }
                return expr.constant() < 0 && expr.multiplyMe(-1), CL.fTraceOn && CL.fnexitprint("returning " + expr), expr
            },
            optimize: function(zVar) {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("optimize: " + zVar), CL.fTraceOn && CL.traceprint(this.toString());
                var zRow = this.rowExpression(zVar);
                CL.Assert(null != zRow, "zRow != null");
                for (var entryVar = null, exitVar = null;;) {
                    var objectiveCoeff = 0,
                        terms = zRow.terms();
                    if (terms.escapingEach(function(v, c) {
                            return v.isPivotable() && objectiveCoeff > c ? (objectiveCoeff = c, entryVar = v, {
                                brk: !0
                            }) : void 0
                        }), objectiveCoeff >= -this._epsilon) return;
                    CL.fTraceOn && CL.traceprint("entryVar == " + entryVar + ", objectiveCoeff == " + objectiveCoeff);
                    var minRatio = Number.MAX_VALUE,
                        columnVars = this._columns.get(entryVar),
                        r = 0;
                    if (columnVars.each(function(v) {
                            if (that.fTraceOn && that.traceprint("Checking " + v), v.isPivotable()) {
                                var expr = that.rowExpression(v),
                                    coeff = expr.coefficientFor(entryVar);
                                that.fTraceOn && that.traceprint("pivotable, coeff = " + coeff), 0 > coeff && (r = -expr.constant() / coeff, (minRatio > r || CL.approx(r, minRatio) && v.hashCode() < exitVar.hashCode()) && (minRatio = r, exitVar = v))
                            }
                        }), minRatio == Number.MAX_VALUE) throw new ExCLInternalError("Objective function is unbounded in optimize");
                    this.pivot(entryVar, exitVar), CL.fTraceOn && CL.traceprint(this.toString())
                }
            },
            pivot: function(entryVar, exitVar) {
                CL.fTraceOn && CL.fnenterprint("pivot: " + entryVar + ", " + exitVar), null == entryVar && console.log("pivot: entryVar == null"), null == exitVar && console.log("pivot: exitVar == null");
                var pexpr = this.removeRow(exitVar);
                pexpr.changeSubject(exitVar, entryVar), this.substituteOut(entryVar, pexpr), this.addRow(entryVar, pexpr)
            },
            resetStayConstants: function() {
                CL.fTraceOn && CL.fnenterprint("resetStayConstants");
                for (var i = 0; i < this._stayPlusErrorVars.length; i++) {
                    var expr = this.rowExpression(this._stayPlusErrorVars[i]);
                    null == expr && (expr = this.rowExpression(this._stayMinusErrorVars[i])), null != expr && expr.set_constant(0)
                }
            },
            setExternalVariables: function() {
                var that = this;
                CL.fTraceOn && CL.fnenterprint("setExternalVariables:"), CL.fTraceOn && CL.traceprint(this.toString()), this._externalParametricVars.each(function(v) {
                    null != that.rowExpression(v) ? print("Error: variable" + v + " in _externalParametricVars is basic") : v.change_value(0)
                }), this._externalRows.each(function(v) {
                    var expr = that.rowExpression(v);
                    CL.fTraceOn && CL.debugprint("v == " + v), CL.fTraceOn && CL.debugprint("expr == " + expr), v.change_value(expr.constant())
                }), this._fNeedsSolving = !1
            },
            insertErrorVar: function(cn, aVar) {
                CL.fTraceOn && CL.fnenterprint("insertErrorVar:" + cn + ", " + aVar);
                var cnset = this._errorVars.get(aVar);
                null == cnset && this._errorVars.put(cn, cnset = new HashSet), cnset.add(aVar)
            }
        }), CL = {
            debugprint: function(s) {
                CL.fVerboseTraceOn && print(s)
            },
            traceprint: function(s) {
                CL.fVerboseTraceOn && print(s)
            },
            fnenterprint: function(s) {
                print("* " + s)
            },
            fnexitprint: function(s) {
                print("- " + s)
            },
            Assert: function(f, description) {
                if (!f) throw new ExCLInternalError("Assertion failed:" + description)
            },
            Plus: function(e1, e2) {
                return e1 instanceof ClLinearExpression || (e1 = new ClLinearExpression(e1)), e2 instanceof ClLinearExpression || (e2 = new ClLinearExpression(e2)), e1.plus(e2)
            },
            Minus: function(e1, e2) {
                return e1 instanceof ClLinearExpression || (e1 = new ClLinearExpression(e1)), e2 instanceof ClLinearExpression || (e2 = new ClLinearExpression(e2)), e1.minus(e2)
            },
            Times: function(e1, e2) {
                return e1 instanceof ClLinearExpression && e2 instanceof ClLinearExpression ? e1.times(e2) : e1 instanceof ClLinearExpression && e2 instanceof ClVariable ? e1.times(new ClLinearExpression(e2)) : e1 instanceof ClVariable && e2 instanceof ClLinearExpression ? new ClLinearExpression(e1).times(e2) : e1 instanceof ClLinearExpression && "number" == typeof e2 ? e1.times(new ClLinearExpression(e2)) : "number" == typeof e1 && e2 instanceof ClLinearExpression ? new ClLinearExpression(e1).times(e2) : "number" == typeof e1 && e2 instanceof ClVariable ? new ClLinearExpression(e2, e1) : e1 instanceof ClVariable && "number" == typeof e2 ? new ClLinearExpression(e1, e2) : e1 instanceof ClVariable && e2 instanceof ClLinearExpression ? new ClLinearExpression(e2, n) : void 0
            },
            Divide: function(e1, e2) {
                return e1.divide(e2)
            },
            approx: function(a, b) {
                return a instanceof ClVariable && (a = a.value()), b instanceof ClVariable && (b = b.value()), epsilon = 1e-8, 0 == a ? Math.abs(b) < epsilon : 0 == b ? Math.abs(a) < epsilon : Math.abs(a - b) < Math.abs(a) * epsilon
            },
            hashToString: function(h) {
                var answer = "";
                return CL.Assert(h instanceof Hashtable), h.each(function(k, v) {
                    answer += k + " => ", answer += v instanceof Hashtable ? CL.hashToString(v) : v instanceof HashSet ? CL.setToString(v) : v + "\n"
                }), answer
            },
            setToString: function(s) {
                CL.Assert(s instanceof HashSet);
                var answer = s.size() + " {",
                    first = !0;
                return s.each(function(e) {
                    first ? first = !1 : answer += ", ", answer += e
                }), answer += "}\n"
            }
        }, CL.fDebugOn = !1, CL.fVerboseTraceOn = !1, CL.fTraceOn = !1, CL.fTraceAdded = !1, CL.fGC = !1, CL.GEQ = 1, CL.LEQ = 2, Object.subclass("Timer", "default category", {
            initialize: function() {
                this._timerIsRunning = !1, this._elapsedMs = 0
            },
            Start: function() {
                this._timerIsRunning = !0, this._startReading = new Date
            },
            Stop: function() {
                this._timerIsRunning = !1, this._elapsedMs += new Date - this._startReading
            },
            Reset: function() {
                this._timerIsRunning = !1, this._elapsedMs = 0
            },
            IsRunning: function() {
                return this._timerIsRunning
            },
            ElapsedTime: function() {
                return this._timerIsRunning ? (this._elapsedMs + (new Date - this._startReading)) / 1e3 : this._elapsedMs / 1e3
            }
        })
    }), module("users.timfelgentreff.babelsberg.cassowary_ext").requires("users.timfelgentreff.cassowary.DwarfCassowary").toRun(function() {
        ClSimplexSolver.addMethods({
            isConstraintObject: !0,
            constraintVariableFor: function(value) {
                if ("number" == typeof value || null === value || value instanceof Number) {
                    var v = new ClVariable(value + 0);
                    return v.solver = this, v.stay(), v
                }
                return null
            },
            get strength() {
                return ClStrength
            },
            weight: 1e3,
            always: function(opts, func) {
                var ctx = opts.ctx,
                    priority = this.strength[opts.priority];
                func.varMapping = ctx;
                var constraint = new Constraint(func, this);
                return constraint.priority = priority, constraint
            }
        }), Object.extend(ClSimplexSolver, {
            getInstance: function() {
                return this.$$instance || (this.$$instance = new ClSimplexSolver, this.$$instance.setAutosolve(!1)), this.$$instance
            },
            resetInstance: function() {
                this.$$instance = void 0
            }
        }), ClAbstractVariable.addMethods({
            isConstraintObject: !0,
            stay: function(strength) {
                strength instanceof ClStrength || (strength = this.solver.strength[strength]), this.stayConstraint && this.solver.removeConstraint(this.stayConstraint);
                var cn = new ClStayConstraint(this, strength || ClStrength.weak, 1);
                return this.solver.addConstraint(cn), this.stayConstraint = cn, cn
            },
            removeStay: function() {
                if (this.stayConstraint) try {
                    this.solver.removeConstraint(this.stayConstraint)
                } catch (_) {
                    this.stayConstraint = null
                }
            },
            suggestValue: function(value) {
                var c = this.cnEquals(value),
                    s = this.solver;
                s.addConstraint(c);
                try {
                    s.solve()
                } finally {
                    s.removeConstraint(c)
                }
            },
            setReadonly: function(bool) {
                if (bool && !this.readonlyConstraint) {
                    var cn = new ClStayConstraint(this, ClStrength.required, 1);
                    return this.solver.addConstraint(cn), this.readonlyConstraint = cn, cn
                }!bool && this.readonlyConstraint && (this.solver.removeConstraint(this.readonlyConstraint), this.readonlyConstraint = void 0)
            },
            isReadonly: function() {
                return !!this.readonlyConstraint
            },
            plus: function(value) {
                return new ClLinearExpression(this).plus(value)
            },
            minus: function(value) {
                return new ClLinearExpression(this).minus(value)
            },
            times: function(value) {
                return new ClLinearExpression(this).times(value)
            },
            divide: function(value) {
                return new ClLinearExpression(this).divide(value)
            },
            cnGeq: function(value) {
                return new ClLinearExpression(this).cnGeq(value)
            },
            cnLeq: function(value) {
                return new ClLinearExpression(this).cnLeq(value)
            },
            cnOr: function() {
                return this
            },
            cnEquals: function(value) {
                return new ClLinearExpression(this).cnEquals(value)
            },
            cnIdentical: function(value) {
                return this.cnEquals(value)
            },
            prepareEdit: function() {
                this.solver.addEditVar(this)
            },
            finishEdit: function() {}
        }), ClLinearExpression.addMethods({
            isConstraintObject: !0,
            cnGeq: function(value) {
                return "string" == typeof value && (value = parseFloat(value)), new ClLinearInequality(this.minus(value))
            },
            cnLeq: function(value) {
                return "string" == typeof value && (value = parseFloat(value)), value instanceof ClLinearExpression || (value = new ClLinearExpression(value)), !value.minus, new ClLinearInequality(value.minus(this))
            },
            cnOr: function() {
                return this
            },
            cnEquals: function(value) {
                return "string" == typeof value && (value = parseFloat(value)), new ClLinearEquation(this, value)
            },
            plus: function(expr) {
                if ("string" == typeof expr && (expr = parseFloat(expr)), expr instanceof ClLinearExpression) return this.clone().addExpression(expr, 1);
                if (expr instanceof ClVariable) return this.clone().addVariable(expr, 1);
                if ("number" == typeof expr) return this.clone().addExpression(new ClLinearExpression(expr), 1);
                throw "Not supported: plus with " + expr
            },
            times: function(x) {
                if ("string" == typeof x && (x = parseFloat(x)), "number" == typeof x) return this.clone().multiplyMe(x);
                if (this.isConstant()) return x.times(this._constant);
                if (x.isConstant()) return this.times(x._constant);
                throw new ExCLNonlinearExpression
            },
            minus: function(expr) {
                if ("string" == typeof expr && (expr = parseFloat(expr)), expr instanceof ClLinearExpression) return this.clone().addExpression(expr, -1);
                if (expr instanceof ClVariable) return this.clone().addVariable(expr, -1);
                if ("number" == typeof expr) return this.clone().addExpression(new ClLinearExpression(expr), -1);
                throw "Not supported: minus with " + expr
            },
            divide: function(x) {
                if ("string" == typeof x && (x = parseFloat(x)), "number" == typeof x) {
                    if (CL.approx(x, 0)) throw new ExCLNonlinearExpression;
                    return this.times(1 / x)
                }
                if (x instanceof ClLinearExpression) {
                    if (!x.isConstant) throw new ExCLNonlinearExpression;
                    return this.times(1 / x._constant)
                }
                throw "Not supported: divide with " + expr
            }
        }), ClConstraint.addMethods({
            isConstraintObject: !0,
            enable: function(strength) {
                strength && this.setStrength(strength), this.solver.addConstraint(this)
            },
            disable: function() {
                this.solver.removeConstraint(this)
            },
            cnOr: function() {
                return this
            },
            get solver() {
                return this._solver || ClSimplexSolver.getInstance()
            },
            set solver(value) {
                this._solver = value
            }
        })
    }), module("users.timfelgentreff.deltablue.deltablue").requires().toRun(function() {
        Object.subclass("DBOrderedCollection", {
            initialize: function() {
                this.elms = new Array
            },
            add: function(elm) {
                this.elms.push(elm)
            },
            at: function(index) {
                return this.elms[index]
            },
            size: function() {
                return this.elms.length
            },
            removeFirst: function() {
                return this.elms.pop()
            },
            remove: function(elm) {
                for (var index = 0, skipped = 0, i = 0; i < this.elms.length; i++) {
                    var value = this.elms[i];
                    value != elm ? (this.elms[index] = value, index++) : skipped++
                }
                for (var i = 0; skipped > i; i++) this.elms.pop()
            }
        }), Object.subclass("DBStrength", {
            initialize: function(strengthValue, name) {
                this.strengthValue = strengthValue, this.name = name
            },
            nextWeaker: function() {
                switch (this.strengthValue) {
                    case 0:
                        return DBStrength.WEAKEST;
                    case 1:
                        return DBStrength.WEAK_DEFAULT;
                    case 2:
                        return DBStrength.NORMAL;
                    case 3:
                        return DBStrength.STRONG_DEFAULT;
                    case 4:
                        return DBStrength.PREFERRED;
                    case 5:
                        return DBStrength.REQUIRED
                }
            }
        }), Object.extend(DBStrength, {
            stronger: function(s1, s2) {
                return s1.strengthValue < s2.strengthValue
            },
            weaker: function(s1, s2) {
                return s1.strengthValue > s2.strengthValue
            },
            weakestOf: function(s1, s2) {
                return this.weaker(s1, s2) ? s1 : s2
            },
            strongest: function(s1, s2) {
                return this.stronger(s1, s2) ? s1 : s2
            },
            REQUIRED: new DBStrength(0, "required"),
            STONG_PREFERRED: new DBStrength(1, "strongPreferred"),
            PREFERRED: new DBStrength(2, "preferred"),
            STRONG_DEFAULT: new DBStrength(3, "strongDefault"),
            NORMAL: new DBStrength(4, "normal"),
            WEAK_DEFAULT: new DBStrength(5, "weakDefault"),
            WEAKEST: new DBStrength(6, "weakest")
        }), Object.subclass("DBConstraint", {
            initialize: function(strength, planner) {
                this.planner = planner, this.strength = strength
            },
            addDBConstraint: function() {
                this.addToGraph(), this.planner.incrementalAdd(this)
            },
            satisfy: function(mark) {
                if (this.chooseMethod(mark), !this.isSatisfied()) return this.strength == DBStrength.REQUIRED, null;
                this.markInputs(mark);
                var out = this.output(),
                    overridden = out.determinedBy;
                return null != overridden && overridden.markUnsatisfied(), out.determinedBy = this, this.planner.addPropagate(this, mark) || alert("Cycle encountered"), out.mark = mark, overridden
            },
            destroyDBConstraint: function() {
                this.isSatisfied() ? this.planner.incrementalRemove(this) : this.removeFromGraph()
            },
            isInput: function() {
                return !1
            }
        }), DBConstraint.subclass("UnaryDBConstraint", {
            initialize: function($super, v, strength, planner) {
                $super(strength, planner), this.myOutput = v, this.satisfied = !1
            },
            addToGraph: function() {
                this.myOutput.addDBConstraint(this), this.satisfied = !1
            },
            chooseMethod: function(mark) {
                this.satisfied = this.myOutput.mark != mark && DBStrength.stronger(this.strength, this.myOutput.walkDBStrength)
            },
            isSatisfied: function() {
                return this.satisfied
            },
            markInputs: function() {},
            output: function() {
                return this.myOutput
            },
            recalculate: function() {
                this.myOutput.walkDBStrength = this.strength, this.myOutput.stay = !this.isInput(), this.myOutput.stay && this.execute()
            },
            markUnsatisfied: function() {
                this.satisfied = !1
            },
            inputsKnown: function() {
                return !0
            },
            removeFromGraph: function() {
                null != this.myOutput && this.myOutput.removeDBConstraint(this), this.satisfied = !1
            }
        }), UnaryDBConstraint.subclass("StayDBConstraint", {
            execute: function() {}
        }), UnaryDBConstraint.subclass("EditDBConstraint", {
            isInput: function() {
                return !0
            },
            execute: function() {}
        });
        var Direction = new Object;
        Direction.NONE = 0, Direction.FORWARD = 1, Direction.BACKWARD = -1, DBConstraint.subclass("BinaryDBConstraint", {
            initialize: function($super, var1, var2, strength, planner) {
                $super(strength, planner), this.v1 = var1, this.v2 = var2, this.direction = Direction.NONE
            },
            chooseMethod: function(mark) {
                this.v1.mark == mark && (this.direction = this.v2.mark != mark && DBStrength.stronger(this.strength, this.v2.walkDBStrength) ? Direction.FORWARD : Direction.NONE), this.v2.mark == mark && (this.direction = this.v1.mark != mark && DBStrength.stronger(this.strength, this.v1.walkDBStrength) ? Direction.BACKWARD : Direction.NONE), this.direction = DBStrength.weaker(this.v1.walkDBStrength, this.v2.walkDBStrength) ? DBStrength.stronger(this.strength, this.v1.walkDBStrength) ? Direction.BACKWARD : Direction.NONE : DBStrength.stronger(this.strength, this.v2.walkDBStrength) ? Direction.FORWARD : Direction.BACKWARD
            },
            addToGraph: function() {
                this.v1.addDBConstraint(this), this.v2.addDBConstraint(this), this.direction = Direction.NONE
            },
            isSatisfied: function() {
                return this.direction != Direction.NONE
            },
            markInputs: function(mark) {
                this.input().mark = mark
            },
            input: function() {
                return this.direction == Direction.FORWARD ? this.v1 : this.v2
            },
            output: function() {
                return this.direction == Direction.FORWARD ? this.v2 : this.v1
            },
            recalculate: function() {
                var ihn = this.input(),
                    out = this.output();
                out.walkDBStrength = DBStrength.weakestOf(this.strength, ihn.walkDBStrength), out.stay = ihn.stay, out.stay && this.execute()
            },
            markUnsatisfied: function() {
                this.direction = Direction.NONE
            },
            inputsKnown: function(mark) {
                var i = this.input();
                return i.mark == mark || i.stay || null == i.determinedBy
            },
            removeFromGraph: function() {
                null != this.v1 && this.v1.removeDBConstraint(this), null != this.v2 && this.v2.removeDBConstraint(this), this.direction = Direction.NONE
            }
        }), DBConstraint.subclass("UserDBConstraint", {
            initialize: function($super, strengthOrPredicateOrFormulas, predicateOrFormulasOrPlanner, formulasOrPlanner, planner) {
                var strength, formulas, predicate;
                planner ? (strength = strengthOrPredicateOrFormulas, predicate = predicateOrFormulasOrPlanner, formulas = formulasOrPlanner) : formulasOrPlanner ? "function" == typeof formulasOrPlanner ? (strength = strengthOrPredicateOrFormulas, predicate = predicateOrFormulasOrPlanner, formulas = formulasOrPlanner) : (planner = formulasOrPlanner, "function" == typeof strengthOrPredicateOrFormulas ? (predicate = strengthOrPredicateOrFormulas, formulas = predicateOrFormulasOrPlanner) : (strength = strengthOrPredicateOrFormulas, formulas = predicateOrFormulasOrPlanner)) : predicateOrFormulasOrPlanner ? "function" == typeof strengthOrPredicateOrFormulas ? "function" == typeof predicateOrFormulasOrPlanner ? (predicate = strengthOrPredicateOrFormulas, formulas = predicateOrFormulasOrPlanner) : (formulas = strengthOrPredicateOrFormulas, planner = predicateOrFormulasOrPlanner) : (strength = strengthOrPredicateOrFormulas, formulas = predicateOrFormulasOrPlanner) : formulas = strengthOrPredicateOrFormulas, strength = strength || DBStrength.required, $super(strength, planner), this.predicate = predicate, this.formulas = [], this.outputs = [], this.inputs = [], this.satisfied = !1, formulas(this)
            },
            formula: function(output, inputs, func) {
                if (inputs.include(output)) throw "output cannot be determined by itself";
                var idx = this.outputs.indexOf(output),
                    len = this.outputs.length;
                if (idx >= 0) throw "multiple formulas for " + output;
                this.outputs.push(output), inputs.each(function(input) {
                    this.inputs.include(input) || this.inputs.push(input)
                }.bind(this)), this.formulas[len] = {
                    inputs: inputs,
                    func: func
                }
            },
            chooseMethod: function(mark) {
                var weakest_output = null,
                    weakest_strength = this.strength;
                this.outputs.each(function(out) {
                    out.mark != mark && DBStrength.stronger(weakest_strength, out.walkDBStrength) && (weakest_strength = out.walkDBStrength, weakest_output = out)
                }.bind(this)), this.out = weakest_output, this.satisfied = !!this.out
            },
            addToGraph: function() {
                var that = this;
                this.variables.each(function(ea) {
                    ea.addDBConstraint(that)
                }), this.satisfied = !1
            },
            isSatisfied: function() {
                return this.satisfied
            },
            markInputs: function(mark) {
                var out = this.out;
                this.inputs.each(function(ea) {
                    ea !== out && (ea.mark = mark)
                })
            },
            recalculate: function() {
                var out = this.out;
                out.walkDBStrength = this.strength, this.inputs.each(function(ea) {
                    out.walkDBStrength = DBStrength.weakestOf(out.walkDBStrength, ea.walkDBStrength)
                }), out.stay = this.inputs.all(function(ea) {
                    return ea.stay
                }), out.stay && this.execute()
            },
            markUnsatisfied: function() {
                this.satisfied = !1
            },
            inputsKnown: function(mark) {
                var out = this.out;
                return this.inputs.all(function(i) {
                    return i === out || i.mark == mark || i.stay || null == i.determinedBy
                })
            },
            removeFromGraph: function() {
                var that = this;
                this.variables.each(function(ea) {
                    ea.removeDBConstraint(that)
                }), this.satisfied = !1
            },
            execute: function() {
                if (!this.predicate || !this.predicate()) {
                    var formula = this.formulas[this.outputs.indexOf(this.out)],
                        func = formula.func,
                        inputs = formula.inputs;
                    this.out.value = func.apply(null, inputs.collect(function(ea) {
                        return ea.value
                    }).concat([this.out.value]))
                }
            },
            output: function() {
                return this.out
            },
            get variables() {
                return this.outputs.concat(this.inputs).uniq()
            }
        }), BinaryDBConstraint.subclass("ScaleDBConstraint", {
            initialize: function($super, src, scale, offset, dest, strength, planner) {
                this.direction = Direction.NONE, this.scale = scale, this.offset = offset, $super(src, dest, strength, planner)
            },
            addToGraph: function($super) {
                $super(), this.scale.addDBConstraint(this), this.offset.addDBConstraint(this)
            },
            removeFromGraph: function($super) {
                $super(), null != this.scale && this.scale.removeDBConstraint(this), null != this.offset && this.offset.removeDBConstraint(this)
            },
            markInputs: function($super, mark) {
                $super(mark), this.scale.mark = this.offset.mark = mark
            },
            execute: function() {
                this.direction == Direction.FORWARD ? this.v2.value = this.v1.value * this.scale.value + this.offset.value : this.v1.value = (this.v2.value - this.offset.value) / this.scale.value
            },
            recalculate: function() {
                var ihn = this.input(),
                    out = this.output();
                out.walkDBStrength = DBStrength.weakestOf(this.strength, ihn.walkDBStrength), out.stay = ihn.stay && this.scale.stay && this.offset.stay, out.stay && this.execute()
            }
        }), BinaryDBConstraint.subclass("EqualityDBConstraint", {
            execute: function() {
                this.output().value = this.input().value
            }
        }), Object.subclass("DBVariable", {
            initialize: function(name, initialValue, planner) {
                this.planner = planner, this.value = initialValue, this.constraints = new DBOrderedCollection, this.determinedBy = null, this.mark = 0, this.walkDBStrength = DBStrength.WEAKEST, this.stay = !0, this.name = name
            },
            addDBConstraint: function(c) {
                this.constraints.add(c)
            },
            removeDBConstraint: function(c) {
                this.constraints.remove(c), this.determinedBy == c && (this.determinedBy = null)
            },
            assignValue: function(newValue) {
                var edit = new EditDBConstraint(this, DBStrength.REQUIRED, this.planner),
                    edits = new DBOrderedCollection;
                edit.addDBConstraint(), edits.add(edit);
                var plan = this.planner.extractDBPlanFromDBConstraints(edits);
                this.value = newValue;
                try {
                    plan.execute()
                } finally {
                    edit.destroyDBConstraint()
                }
            }
        }), Object.subclass("DBPlanner", {
            initialize: function() {
                this.currentMark = 0
            },
            incrementalAdd: function(c) {
                for (var mark = this.newMark(), overridden = c.satisfy(mark); null != overridden;) overridden = overridden.satisfy(mark)
            },
            incrementalRemove: function(c) {
                var out = c.output();
                c.markUnsatisfied(), c.removeFromGraph();
                var unsatisfied = this.removePropagateFrom(out),
                    strength = DBStrength.REQUIRED;
                do {
                    for (var i = 0; i < unsatisfied.size(); i++) {
                        var u = unsatisfied.at(i);
                        u.strength == strength && this.incrementalAdd(u)
                    }
                    strength = strength.nextWeaker()
                } while (strength != DBStrength.WEAKEST)
            },
            newMark: function() {
                return ++this.currentMark
            },
            makeDBPlan: function(sources) {
                for (var mark = this.newMark(), plan = new DBPlan, todo = sources; todo.size() > 0;) {
                    var c = todo.removeFirst();
                    c.output().mark != mark && c.inputsKnown(mark) && (plan.addDBConstraint(c), c.output().mark = mark, this.addDBConstraintsConsumingTo(c.output(), todo, c))
                }
                return plan
            },
            extractDBPlanFromDBConstraints: function(constraints) {
                for (var sources = new DBOrderedCollection, i = 0; i < constraints.size(); i++) {
                    var c = constraints.at(i);
                    c.isInput() && c.isSatisfied() && sources.add(c)
                }
                return this.makeDBPlan(sources)
            },
            addPropagate: function(c, mark) {
                var todo = new DBOrderedCollection;
                for (todo.add(c); todo.size() > 0;) {
                    var d = todo.removeFirst();
                    if (d.output().mark == mark) return this.incrementalRemove(c), !1;
                    d.recalculate(), this.addDBConstraintsConsumingTo(d.output(), todo)
                }
                return !0
            },
            removePropagateFrom: function(out) {
                out.determinedBy = null, out.walkDBStrength = DBStrength.WEAKEST, out.stay = !0;
                var unsatisfied = new DBOrderedCollection,
                    todo = new DBOrderedCollection;
                for (todo.add(out); todo.size() > 0;) {
                    for (var v = todo.removeFirst(), i = 0; i < v.constraints.size(); i++) {
                        var c = v.constraints.at(i);
                        c.isSatisfied() || unsatisfied.add(c)
                    }
                    for (var determining = v.determinedBy, i = 0; i < v.constraints.size(); i++) {
                        var next = v.constraints.at(i);
                        next != determining && next.isSatisfied() && (next.recalculate(), todo.add(next.output()))
                    }
                }
                return unsatisfied
            },
            addDBConstraintsConsumingTo: function(v, coll, not) {
                for (var determining = v.determinedBy, cc = v.constraints, i = 0; i < cc.size(); i++) {
                    var c = cc.at(i);
                    c != determining && c.isSatisfied() && c != not && coll.add(c)
                }
            }
        }), Object.subclass("DBPlan", {
            initialize: function() {
                this.v = new DBOrderedCollection
            },
            addDBConstraint: function(c) {
                this.v.add(c)
            },
            size: function() {
                return this.v.size()
            },
            constraintAt: function(index) {
                return this.v.at(index)
            },
            execute: function() {
                for (var i = 0; i < this.size(); i++) {
                    var c = this.constraintAt(i);
                    c.execute()
                }
            }
        })
    }), module("users.timfelgentreff.babelsberg.deltablue_ext").requires("users.timfelgentreff.deltablue.deltablue", "users.timfelgentreff.jsinterpreter.Interpreter").toRun(function() {
        DBPlanner.addMethods({
            isConstraintObject: !0,
            constraintVariableFor: function(value, ivarname) {
                return new DBVariable(ivarname, value, this)
            },
            get strength() {
                return DBStrength
            },
            always: function(opts, func) {
                Object.isString(opts.priority) && (opts.priority = this.strength[opts.priority]), func.allowUnsolvableOperations = !0;
                var planner = this,
                    ctx = opts.ctx,
                    priority = opts.priority,
                    methods = opts.methods;
                func.varMapping = ctx, methods || (methods = func, func = void 0), methods.varMapping = ctx;
                var cobj = new Constraint(methods, planner),
                    formulas = cobj.constraintvariables.collect(function(v) {
                        var v = v.externalVariables(planner);
                        return v ? v.removeFormula() : null
                    }).compact();
                if (formulas.length > 0) {
                    var constraint = new UserDBConstraint(priority, func, function(c) {
                        formulas.each(function(m) {
                            var inputs = m.inputs.select(function(input) {
                                return input instanceof DBVariable
                            });
                            dbgOn(inputs.length !== m.inputs.length), c.formula(m.output, inputs, m.func)
                        })
                    }, planner);
                    cobj.addPrimitiveConstraint(constraint)
                }
                return cobj.priority = priority, cobj
            },
            weight: 100,
            addEditVar: function(v) {
                this.currentEdits || (this.currentEdits = new DBOrderedCollection);
                var edit = new EditDBConstraint(v, DBStrength.required, this);
                return this.currentEdits.add(edit), edit
            },
            solve: function() {},
            beginEdit: function() {
                if (this.currentEditPlan) throw "Trying to run nested edits - this isn't supported";
                if (!this.currentEdits) throw "No edit variables - cannot beginEdit";
                this.currentEditPlan = this.extractDBPlanFromDBConstraints(this.currentEdits)
            },
            endEdit: function() {
                this.currentEdits && 0 !== this.currentEdits.length && this.currentEdits.elms.each(function(edit) {
                    edit.destroyDBConstraint()
                }), this.currentEditPlan = null
            },
            resolveArray: function(newValues) {
                if (!this.currentEdits) throw "resolveArray only valid in edit";
                this.currentEdits.elms.each(function(edit, idx) {
                    edit.myOutput.value = newValues[idx]
                }), this.currentEditPlan.execute()
            }
        }), Object.extend(DBPlanner, {
            getInstance: function() {
                return this.$$instance || (this.$$instance = new DBPlanner), this.$$instance
            },
            resetInstance: function() {
                this.$$instance = void 0
            }
        }), Object.extend(DBStrength, {
            required: DBStrength.REQUIRED,
            strong: DBStrength.STRONG_DEFAULT,
            medium: DBStrength.NORMAL,
            weak: DBStrength.WEAK_DEFAULT
        }), DBVariable.addMethods({
            isConstraintObject: !0,
            stay: function(strength) {
                var cn = new StayDBConstraint(this, strength || DBStrength.WEAK_DEFAULT, this.planner);
                return cn.enable(), this._stayConstraint = cn, cn
            },
            setReadonly: function(bool) {
                if (bool && !this.readonlyConstraint) {
                    var cn = new StayDBConstraint(this, DBStrength.STONG_PREFERRED, this.planner);
                    return cn.enable(), this.readonlyConstraint = cn, cn
                }!bool && this.readonlyConstraint && (this.readonlyConstraint.disable(), this.readonlyConstraint = void 0)
            },
            isReadonly: function() {
                return !!this.readonlyConstraint
            },
            formula: function(inputs, func) {
                if (console.warn("Deprecated: Using DBVariable>>formula"), !Constraint.current) throw "invalid outside constraint construction";
                if (this.__formula__) throw "two formulas for the same variable " + this;
                this.__formula__ = {
                    output: this,
                    inputs: inputs,
                    func: func
                }
            },
            removeFormula: function() {
                var f = this.__formula__;
                return this.__formula__ = void 0, f
            },
            removeStay: function() {
                if (this._stayConstraint) try {
                    this.planner.removeConstraint(this._stayConstraint)
                } catch (_) {
                    this._stayConstraint = null
                }
            },
            suggestValue: function(value) {
                this.assignValue(value)
            },
            prepareEdit: function() {
                this.editConstraint || (this.editConstraint = this.planner.addEditVar(this))
            },
            finishEdit: function() {
                this.editConstraint = null
            },
            cnIdentical: function(other) {
                if (!(other instanceof DBVariable)) {
                    other = new DBVariable("constant/" + other, other, this.planner);
                    var stay = new StayDBConstraint(other, DBStrength.required, this.planner);
                    stay.enable(DBStrength.required)
                }
                return new EqualityDBConstraint(this, other, DBStrength.required, Constraint.current.solver)
            },
            cnEquals: function(other) {
                if (!(other instanceof DBVariable)) {
                    var formulaNode = bbb.currentNode && ("==" === bbb.currentNode.name || bbb.currentNode.property && "equals" === bbb.currentNode.property.value) && (bbb.currentNode.right || bbb.currentNode.args[0]);
                    if (formulaNode) {
                        var self = this,
                            argumentString = cop.withLayers([PrintOMetaVariableAsBBBField], function() {
                                return formulaNode.asJS()
                            }),
                            varMapping = bbb.currentInterpreter.getCurrentScope(),
                            func = function() {
                                window.$$bbbVarMapping = varMapping;
                                try {
                                    return eval(argumentString)
                                } finally {
                                    delete window.$$bbbVarMapping
                                }
                            },
                            inputs = Constraint.current.constraintvariables.map(function(cvar) {
                                return cvar.externalVariable
                            }).filter(function(evar) {
                                return evar && evar !== this && "string" == typeof evar.name
                            }.bind(this)),
                            c = new UserDBConstraint(function() {}, Constraint.current.solver);
                        return c.formula(this, inputs, func), c
                    }
                    other = new DBVariable("constant/" + other, other, this.planner), Constraint.current.addPrimitiveConstraint(new StayDBConstraint(other, DBStrength.required, this.planner))
                }
                var self = this;
                return cloneFunc = function(fromObj) {
                    return fromObj.clone ? fromObj.clone() : fromObj.copy ? fromObj.copy() : fromObj
                }, new UserDBConstraint(function(c) {
                    c.formula(self, [other], cloneFunc), c.formula(other, [self], cloneFunc)
                }, Constraint.current.solver)
            },
            cnOr: function(other) {
                return this.value ? this : other
            },
            equals: function() {
                return this.cnEquals.apply(this, arguments)
            }
        }), UserDBConstraint.addMethods({
            cnAnd: function(r) {
                if (r instanceof UserDBConstraint) {
                    for (var i = 0; i < r.formulas.length; i++) {
                        var output = r.outputs[i],
                            formula = r.formulas[i],
                            inputs = formula.inputs,
                            func = formula.func;
                        this.formula(output, inputs, func)
                    }
                    return this
                }
                return Constraint.current.addPrimitiveConstraint(this), r
            }
        }), cop.create("PrintOMetaVariableAsBBBField").refineClass(users.timfelgentreff.jsinterpreter.Variable, {
            asJS: function() {
                var result = cop.proceed();
                return "(window.$$bbbVarMapping." + result + ")"
            }
        }), DBConstraint.addMethods({
            isConstraintObject: !0,
            enable: function(priority) {
                this.strength = priority || this.strength, this.addDBConstraint()
            },
            disable: function() {
                this.destroyDBConstraint()
            },
            cnOr: function() {
                return this
            }
        }), EqualityDBConstraint.addMethods({
            setExecuteFunction: function(func) {
                var orig = this.execute.$originalFunction || this.execute;
                func.$originalFunction = orig, this.execute = func
            },
            unsetExecuteFunction: function() {
                this.execute = this.execute.$originalFunction || this.execute
            }
        })
    }),
    function() {
        var n = this,
            t = n._,
            r = {},
            e = Array.prototype,
            u = Object.prototype,
            i = Function.prototype,
            a = e.push,
            o = e.slice,
            c = e.concat,
            l = u.toString,
            f = u.hasOwnProperty,
            s = e.forEach,
            p = e.map,
            h = e.reduce,
            v = e.reduceRight,
            g = e.filter,
            d = e.every,
            m = e.some,
            y = e.indexOf,
            b = e.lastIndexOf,
            x = Array.isArray,
            w = Object.keys,
            _ = i.bind,
            j = function(n) {
                return n instanceof j ? n : this instanceof j ? void(this._wrapped = n) : new j(n)
            };
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = j), exports._ = j) : n._ = j, j.VERSION = "1.6.0";
        var A = j.each = j.forEach = function(n, t, e) {
            if (null == n) return n;
            if (s && n.forEach === s) n.forEach(t, e);
            else if (n.length === +n.length) {
                for (var u = 0, i = n.length; i > u; u++)
                    if (t.call(e, n[u], u, n) === r) return
            } else
                for (var a = j.keys(n), u = 0, i = a.length; i > u; u++)
                    if (t.call(e, n[a[u]], a[u], n) === r) return; return n
        };
        j.map = j.collect = function(n, t, r) {
            var e = [];
            return null == n ? e : p && n.map === p ? n.map(t, r) : (A(n, function(n, u, i) {
                e.push(t.call(r, n, u, i))
            }), e)
        };
        var O = "Reduce of empty array with no initial value";
        j.reduce = j.foldl = j.inject = function(n, t, r, e) {
            var u = arguments.length > 2;
            if (null == n && (n = []), h && n.reduce === h) return e && (t = j.bind(t, e)), u ? n.reduce(t, r) : n.reduce(t);
            if (A(n, function(n, i, a) {
                    u ? r = t.call(e, r, n, i, a) : (r = n, u = !0)
                }), !u) throw new TypeError(O);
            return r
        }, j.reduceRight = j.foldr = function(n, t, r, e) {
            var u = arguments.length > 2;
            if (null == n && (n = []), v && n.reduceRight === v) return e && (t = j.bind(t, e)), u ? n.reduceRight(t, r) : n.reduceRight(t);
            var i = n.length;
            if (i !== +i) {
                var a = j.keys(n);
                i = a.length
            }
            if (A(n, function(o, c, l) {
                    c = a ? a[--i] : --i, u ? r = t.call(e, r, n[c], c, l) : (r = n[c], u = !0)
                }), !u) throw new TypeError(O);
            return r
        }, j.find = j.detect = function(n, t, r) {
            var e;
            return k(n, function(n, u, i) {
                return t.call(r, n, u, i) ? (e = n, !0) : void 0
            }), e
        }, j.filter = j.select = function(n, t, r) {
            var e = [];
            return null == n ? e : g && n.filter === g ? n.filter(t, r) : (A(n, function(n, u, i) {
                t.call(r, n, u, i) && e.push(n)
            }), e)
        }, j.reject = function(n, t, r) {
            return j.filter(n, function(n, e, u) {
                return !t.call(r, n, e, u)
            }, r)
        }, j.every = j.all = function(n, t, e) {
            t || (t = j.identity);
            var u = !0;
            return null == n ? u : d && n.every === d ? n.every(t, e) : (A(n, function(n, i, a) {
                return (u = u && t.call(e, n, i, a)) ? void 0 : r
            }), !!u)
        };
        var k = j.some = j.any = function(n, t, e) {
            t || (t = j.identity);
            var u = !1;
            return null == n ? u : m && n.some === m ? n.some(t, e) : (A(n, function(n, i, a) {
                return u || (u = t.call(e, n, i, a)) ? r : void 0
            }), !!u)
        };
        j.contains = j.include = function(n, t) {
            return null == n ? !1 : y && n.indexOf === y ? -1 != n.indexOf(t) : k(n, function(n) {
                return n === t
            })
        }, j.invoke = function(n, t) {
            var r = o.call(arguments, 2),
                e = j.isFunction(t);
            return j.map(n, function(n) {
                return (e ? t : n[t]).apply(n, r)
            })
        }, j.pluck = function(n, t) {
            return j.map(n, j.property(t))
        }, j.where = function(n, t) {
            return j.filter(n, j.matches(t))
        }, j.findWhere = function(n, t) {
            return j.find(n, j.matches(t))
        }, j.max = function(n, t, r) {
            if (!t && j.isArray(n) && n[0] === +n[0] && n.length < 65535) return Math.max.apply(Math, n);
            var e = -1 / 0,
                u = -1 / 0;
            return A(n, function(n, i, a) {
                var o = t ? t.call(r, n, i, a) : n;
                o > u && (e = n, u = o)
            }), e
        }, j.min = function(n, t, r) {
            if (!t && j.isArray(n) && n[0] === +n[0] && n.length < 65535) return Math.min.apply(Math, n);
            var e = 1 / 0,
                u = 1 / 0;
            return A(n, function(n, i, a) {
                var o = t ? t.call(r, n, i, a) : n;
                u > o && (e = n, u = o)
            }), e
        }, j.shuffle = function(n) {
            var t, r = 0,
                e = [];
            return A(n, function(n) {
                t = j.random(r++), e[r - 1] = e[t], e[t] = n
            }), e
        }, j.sample = function(n, t, r) {
            return null == t || r ? (n.length !== +n.length && (n = j.values(n)), n[j.random(n.length - 1)]) : j.shuffle(n).slice(0, Math.max(0, t))
        };
        var E = function(n) {
            return null == n ? j.identity : j.isFunction(n) ? n : j.property(n)
        };
        j.sortBy = function(n, t, r) {
            return t = E(t), j.pluck(j.map(n, function(n, e, u) {
                return {
                    value: n,
                    index: e,
                    criteria: t.call(r, n, e, u)
                }
            }).sort(function(n, t) {
                var r = n.criteria,
                    e = t.criteria;
                if (r !== e) {
                    if (r > e || void 0 === r) return 1;
                    if (e > r || void 0 === e) return -1
                }
                return n.index - t.index
            }), "value")
        };
        var F = function(n) {
            return function(t, r, e) {
                var u = {};
                return r = E(r), A(t, function(i, a) {
                    var o = r.call(e, i, a, t);
                    n(u, o, i)
                }), u
            }
        };
        j.groupBy = F(function(n, t, r) {
            j.has(n, t) ? n[t].push(r) : n[t] = [r]
        }), j.indexBy = F(function(n, t, r) {
            n[t] = r
        }), j.countBy = F(function(n, t) {
            j.has(n, t) ? n[t]++ : n[t] = 1
        }), j.sortedIndex = function(n, t, r, e) {
            r = E(r);
            for (var u = r.call(e, t), i = 0, a = n.length; a > i;) {
                var o = i + a >>> 1;
                r.call(e, n[o]) < u ? i = o + 1 : a = o
            }
            return i
        }, j.toArray = function(n) {
            return n ? j.isArray(n) ? o.call(n) : n.length === +n.length ? j.map(n, j.identity) : j.values(n) : []
        }, j.size = function(n) {
            return null == n ? 0 : n.length === +n.length ? n.length : j.keys(n).length
        }, j.first = j.head = j.take = function(n, t, r) {
            return null == n ? void 0 : null == t || r ? n[0] : 0 > t ? [] : o.call(n, 0, t)
        }, j.initial = function(n, t, r) {
            return o.call(n, 0, n.length - (null == t || r ? 1 : t))
        }, j.last = function(n, t, r) {
            return null == n ? void 0 : null == t || r ? n[n.length - 1] : o.call(n, Math.max(n.length - t, 0))
        }, j.rest = j.tail = j.drop = function(n, t, r) {
            return o.call(n, null == t || r ? 1 : t)
        }, j.compact = function(n) {
            return j.filter(n, j.identity)
        };
        var M = function(n, t, r) {
            return t && j.every(n, j.isArray) ? c.apply(r, n) : (A(n, function(n) {
                j.isArray(n) || j.isArguments(n) ? t ? a.apply(r, n) : M(n, t, r) : r.push(n)
            }), r)
        };
        j.flatten = function(n, t) {
            return M(n, t, [])
        }, j.without = function(n) {
            return j.difference(n, o.call(arguments, 1))
        }, j.partition = function(n, t) {
            var r = [],
                e = [];
            return A(n, function(n) {
                (t(n) ? r : e).push(n)
            }), [r, e]
        }, j.uniq = j.unique = function(n, t, r, e) {
            j.isFunction(t) && (e = r, r = t, t = !1);
            var u = r ? j.map(n, r, e) : n,
                i = [],
                a = [];
            return A(u, function(r, e) {
                (t ? e && a[a.length - 1] === r : j.contains(a, r)) || (a.push(r), i.push(n[e]))
            }), i
        }, j.union = function() {
            return j.uniq(j.flatten(arguments, !0))
        }, j.intersection = function(n) {
            var t = o.call(arguments, 1);
            return j.filter(j.uniq(n), function(n) {
                return j.every(t, function(t) {
                    return j.contains(t, n)
                })
            })
        }, j.difference = function(n) {
            var t = c.apply(e, o.call(arguments, 1));
            return j.filter(n, function(n) {
                return !j.contains(t, n)
            })
        }, j.zip = function() {
            for (var n = j.max(j.pluck(arguments, "length").concat(0)), t = new Array(n), r = 0; n > r; r++) t[r] = j.pluck(arguments, "" + r);
            return t
        }, j.object = function(n, t) {
            if (null == n) return {};
            for (var r = {}, e = 0, u = n.length; u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
            return r
        }, j.indexOf = function(n, t, r) {
            if (null == n) return -1;
            var e = 0,
                u = n.length;
            if (r) {
                if ("number" != typeof r) return e = j.sortedIndex(n, t), n[e] === t ? e : -1;
                e = 0 > r ? Math.max(0, u + r) : r
            }
            if (y && n.indexOf === y) return n.indexOf(t, r);
            for (; u > e; e++)
                if (n[e] === t) return e;
            return -1
        }, j.lastIndexOf = function(n, t, r) {
            if (null == n) return -1;
            var e = null != r;
            if (b && n.lastIndexOf === b) return e ? n.lastIndexOf(t, r) : n.lastIndexOf(t);
            for (var u = e ? r : n.length; u--;)
                if (n[u] === t) return u;
            return -1
        }, j.range = function(n, t, r) {
            arguments.length <= 1 && (t = n || 0, n = 0), r = arguments[2] || 1;
            for (var e = Math.max(Math.ceil((t - n) / r), 0), u = 0, i = new Array(e); e > u;) i[u++] = n, n += r;
            return i
        };
        var R = function() {};
        j.bind = function(n, t) {
            var r, e;
            if (_ && n.bind === _) return _.apply(n, o.call(arguments, 1));
            if (!j.isFunction(n)) throw new TypeError;
            return r = o.call(arguments, 2), e = function() {
                if (!(this instanceof e)) return n.apply(t, r.concat(o.call(arguments)));
                R.prototype = n.prototype;
                var u = new R;
                R.prototype = null;
                var i = n.apply(u, r.concat(o.call(arguments)));
                return Object(i) === i ? i : u
            }
        }, j.partial = function(n) {
            var t = o.call(arguments, 1);
            return function() {
                for (var r = 0, e = t.slice(), u = 0, i = e.length; i > u; u++) e[u] === j && (e[u] = arguments[r++]);
                for (; r < arguments.length;) e.push(arguments[r++]);
                return n.apply(this, e)
            }
        }, j.bindAll = function(n) {
            var t = o.call(arguments, 1);
            if (0 === t.length) throw new Error("bindAll must be passed function names");
            return A(t, function(t) {
                n[t] = j.bind(n[t], n)
            }), n
        }, j.memoize = function(n, t) {
            var r = {};
            return t || (t = j.identity),
                function() {
                    var e = t.apply(this, arguments);
                    return j.has(r, e) ? r[e] : r[e] = n.apply(this, arguments)
                }
        }, j.delay = function(n, t) {
            var r = o.call(arguments, 2);
            return setTimeout(function() {
                return n.apply(null, r)
            }, t)
        }, j.defer = function(n) {
            return j.delay.apply(j, [n, 1].concat(o.call(arguments, 1)))
        }, j.throttle = function(n, t, r) {
            var e, u, i, a = null,
                o = 0;
            r || (r = {});
            var c = function() {
                o = r.leading === !1 ? 0 : j.now(), a = null, i = n.apply(e, u), e = u = null
            };
            return function() {
                var l = j.now();
                o || r.leading !== !1 || (o = l);
                var f = t - (l - o);
                return e = this, u = arguments, 0 >= f ? (clearTimeout(a), a = null, o = l, i = n.apply(e, u), e = u = null) : a || r.trailing === !1 || (a = setTimeout(c, f)), i
            }
        }, j.debounce = function(n, t, r) {
            var e, u, i, a, o, c = function() {
                var l = j.now() - a;
                t > l ? e = setTimeout(c, t - l) : (e = null, r || (o = n.apply(i, u), i = u = null))
            };
            return function() {
                i = this, u = arguments, a = j.now();
                var l = r && !e;
                return e || (e = setTimeout(c, t)), l && (o = n.apply(i, u), i = u = null), o
            }
        }, j.once = function(n) {
            var t, r = !1;
            return function() {
                return r ? t : (r = !0, t = n.apply(this, arguments), n = null, t)
            }
        }, j.wrap = function(n, t) {
            return j.partial(t, n)
        }, j.compose = function() {
            var n = arguments;
            return function() {
                for (var t = arguments, r = n.length - 1; r >= 0; r--) t = [n[r].apply(this, t)];
                return t[0]
            }
        }, j.after = function(n, t) {
            return function() {
                return --n < 1 ? t.apply(this, arguments) : void 0
            }
        }, j.keys = function(n) {
            if (!j.isObject(n)) return [];
            if (w) return w(n);
            var t = [];
            for (var r in n) j.has(n, r) && t.push(r);
            return t
        }, j.values = function(n) {
            for (var t = j.keys(n), r = t.length, e = new Array(r), u = 0; r > u; u++) e[u] = n[t[u]];
            return e
        }, j.pairs = function(n) {
            for (var t = j.keys(n), r = t.length, e = new Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]];
            return e
        }, j.invert = function(n) {
            for (var t = {}, r = j.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e];
            return t
        }, j.functions = j.methods = function(n) {
            var t = [];
            for (var r in n) j.isFunction(n[r]) && t.push(r);
            return t.sort()
        }, j.extend = function(n) {
            return A(o.call(arguments, 1), function(t) {
                if (t)
                    for (var r in t) n[r] = t[r]
            }), n
        }, j.pick = function(n) {
            var t = {},
                r = c.apply(e, o.call(arguments, 1));
            return A(r, function(r) {
                r in n && (t[r] = n[r])
            }), t
        }, j.omit = function(n) {
            var t = {},
                r = c.apply(e, o.call(arguments, 1));
            for (var u in n) j.contains(r, u) || (t[u] = n[u]);
            return t
        }, j.defaults = function(n) {
            return A(o.call(arguments, 1), function(t) {
                if (t)
                    for (var r in t) void 0 === n[r] && (n[r] = t[r])
            }), n
        }, j.clone = function(n) {
            return j.isObject(n) ? j.isArray(n) ? n.slice() : j.extend({}, n) : n
        }, j.tap = function(n, t) {
            return t(n), n
        };
        var S = function(n, t, r, e) {
            if (n === t) return 0 !== n || 1 / n == 1 / t;
            if (null == n || null == t) return n === t;
            n instanceof j && (n = n._wrapped), t instanceof j && (t = t._wrapped);
            var u = l.call(n);
            if (u != l.call(t)) return !1;
            switch (u) {
                case "[object String]":
                    return n == String(t);
                case "[object Number]":
                    return n != +n ? t != +t : 0 == n ? 1 / n == 1 / t : n == +t;
                case "[object Date]":
                case "[object Boolean]":
                    return +n == +t;
                case "[object RegExp]":
                    return n.source == t.source && n.global == t.global && n.multiline == t.multiline && n.ignoreCase == t.ignoreCase
            }
            if ("object" != typeof n || "object" != typeof t) return !1;
            for (var i = r.length; i--;)
                if (r[i] == n) return e[i] == t;
            var a = n.constructor,
                o = t.constructor;
            if (a !== o && !(j.isFunction(a) && a instanceof a && j.isFunction(o) && o instanceof o) && "constructor" in n && "constructor" in t) return !1;
            r.push(n), e.push(t);
            var c = 0,
                f = !0;
            if ("[object Array]" == u) {
                if (c = n.length, f = c == t.length)
                    for (; c-- && (f = S(n[c], t[c], r, e)););
            } else {
                for (var s in n)
                    if (j.has(n, s) && (c++, !(f = j.has(t, s) && S(n[s], t[s], r, e)))) break;
                if (f) {
                    for (s in t)
                        if (j.has(t, s) && !c--) break;
                    f = !c
                }
            }
            return r.pop(), e.pop(), f
        };
        j.isEqual = function(n, t) {
            return S(n, t, [], [])
        }, j.isEmpty = function(n) {
            if (null == n) return !0;
            if (j.isArray(n) || j.isString(n)) return 0 === n.length;
            for (var t in n)
                if (j.has(n, t)) return !1;
            return !0
        }, j.isElement = function(n) {
            return !(!n || 1 !== n.nodeType)
        }, j.isArray = x || function(n) {
            return "[object Array]" == l.call(n)
        }, j.isObject = function(n) {
            return n === Object(n)
        }, A(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function(n) {
            j["is" + n] = function(t) {
                return l.call(t) == "[object " + n + "]"
            }
        }), j.isArguments(arguments) || (j.isArguments = function(n) {
            return !(!n || !j.has(n, "callee"))
        }), "function" != typeof /./ && (j.isFunction = function(n) {
            return "function" == typeof n
        }), j.isFinite = function(n) {
            return isFinite(n) && !isNaN(parseFloat(n))
        }, j.isNaN = function(n) {
            return j.isNumber(n) && n != +n
        }, j.isBoolean = function(n) {
            return n === !0 || n === !1 || "[object Boolean]" == l.call(n)
        }, j.isNull = function(n) {
            return null === n
        }, j.isUndefined = function(n) {
            return void 0 === n
        }, j.has = function(n, t) {
            return f.call(n, t)
        }, j.noConflict = function() {
            return n._ = t, this
        }, j.identity = function(n) {
            return n
        }, j.constant = function(n) {
            return function() {
                return n
            }
        }, j.property = function(n) {
            return function(t) {
                return t[n]
            }
        }, j.matches = function(n) {
            return function(t) {
                if (t === n) return !0;
                for (var r in n)
                    if (n[r] !== t[r]) return !1;
                return !0
            }
        }, j.times = function(n, t, r) {
            for (var e = Array(Math.max(0, n)), u = 0; n > u; u++) e[u] = t.call(r, u);
            return e
        }, j.random = function(n, t) {
            return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1))
        }, j.now = Date.now || function() {
            return (new Date).getTime()
        };
        var T = {
            escape: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;"
            }
        };
        T.unescape = j.invert(T.escape);
        var I = {
            escape: new RegExp("[" + j.keys(T.escape).join("") + "]", "g"),
            unescape: new RegExp("(" + j.keys(T.unescape).join("|") + ")", "g")
        };
        j.each(["escape", "unescape"], function(n) {
            j[n] = function(t) {
                return null == t ? "" : ("" + t).replace(I[n], function(t) {
                    return T[n][t]
                })
            }
        }), j.result = function(n, t) {
            if (null == n) return void 0;
            var r = n[t];
            return j.isFunction(r) ? r.call(n) : r
        }, j.mixin = function(n) {
            A(j.functions(n), function(t) {
                var r = j[t] = n[t];
                j.prototype[t] = function() {
                    var n = [this._wrapped];
                    return a.apply(n, arguments), z.call(this, r.apply(j, n))
                }
            })
        };
        var N = 0;
        j.uniqueId = function(n) {
            var t = ++N + "";
            return n ? n + t : t
        }, j.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        var q = /(.)^/,
            B = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                " ": "t",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            D = /\\|'|\r|\n|\t|\u2028|\u2029/g;
        j.template = function(n, t, r) {
            var e;
            r = j.defaults({}, r, j.templateSettings);
            var u = new RegExp([(r.escape || q).source, (r.interpolate || q).source, (r.evaluate || q).source].join("|") + "|$", "g"),
                i = 0,
                a = "__p+='";
            n.replace(u, function(t, r, e, u, o) {
                return a += n.slice(i, o).replace(D, function(n) {
                    return "\\" + B[n]
                }), r && (a += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'"), e && (a += "'+\n((__t=(" + e + "))==null?'':__t)+\n'"), u && (a += "';\n" + u + "\n__p+='"), i = o + t.length, t
            }), a += "';\n", r.variable || (a = "with(obj||{}){\n" + a + "}\n"), a = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + a + "return __p;\n";
            try {
                e = new Function(r.variable || "obj", "_", a)
            } catch (o) {
                throw o.source = a, o
            }
            if (t) return e(t, j);
            var c = function(n) {
                return e.call(this, n, j)
            };
            return c.source = "function(" + (r.variable || "obj") + "){\n" + a + "}", c
        }, j.chain = function(n) {
            return j(n).chain()
        };
        var z = function(n) {
            return this._chain ? j(n).chain() : n
        };
        j.mixin(j), A(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(n) {
            var t = e[n];
            j.prototype[n] = function() {
                var r = this._wrapped;
                return t.apply(r, arguments), "shift" != n && "splice" != n || 0 !== r.length || delete r[0], z.call(this, r)
            }
        }), A(["concat", "join", "slice"], function(n) {
            var t = e[n];
            j.prototype[n] = function() {
                return z.call(this, t.apply(this._wrapped, arguments))
            }
        }), j.extend(j.prototype, {
            chain: function() {
                return this._chain = !0, this
            },
            value: function() {
                return this._wrapped
            }
        }), "function" == typeof define && define.amd && define("underscore", [], function() {
            return j
        })
    }.call(this), module("users.timfelgentreff.csp.csp").requires().toRun(function() {
        JSLoader.loadJs(module("users.timfelgentreff.csp.underscore-min").uri());
        var Variable = function(name, domain) {
            this.name = name, this.domain = domain
        };
        Variable.prototype.toString = function() {
            return "" + this.name + " => [" + this.domain.toString() + "]"
        };
        var Constraint = function(variables, fn) {
            this.fn = fn, this.variables = variables
        };
        Constraint.prototype.toString = function() {
            return "(" + this.variables.toString() + ") => " + this.fn.toString()
        };
        var Problem = function() {
            this.solver = new RecursiveBacktrackingSolver, this.variables = {}, this.constraints = []
        };
        Problem.prototype.addVariable = function(name, domain) {
            this.variables[name] = new Variable(name, domain)
        }, Problem.prototype.removeVariable = function(vari) {
            var vars = this.variables;
            delete vars[vari]
        }, Problem.prototype.addConstraint = function(variables, fn) {
            var constraint = new Constraint(variables, fn);
            return this.constraints.push(constraint), constraint
        }, Problem.prototype.removeConstraint = function(constraint) {
            var index = this.constraints.indexOf(constraint);
            if (!(index > -1)) throw "attempt to removed a non-existing element";
            this.constraints.splice(index, 1)
        }, Problem.prototype.setSolver = function(solver) {
            this.solver = solver
        }, Problem.prototype.getSolution = function(restrictedDomains) {
            return this.solver.getSolution(this, restrictedDomains)
        }, Problem.prototype.getAssignmentFor = function(name) {
            return this.solver.getAssignmentFor(name)
        };
        var RecursiveBacktrackingSolver = function() {
            this.assignments = {}
        };
        RecursiveBacktrackingSolver.prototype.getSolution = function(csp, restrictedDomains) {
            var satisfiable = this.solve(csp.variables, csp.constraints, restrictedDomains);
            return satisfiable
        }, RecursiveBacktrackingSolver.prototype.getAssignmentFor = function(name) {
            return this.assignments[name]
        }, RecursiveBacktrackingSolver.prototype.solve = function(variables, constraints, restrictedDomains) {
            var domainByName = this.prepareSolving(variables, restrictedDomains),
                fulfilled = this.recursiveSolve(constraints, domainByName);
            return fulfilled
        }, RecursiveBacktrackingSolver.prototype.prepareSolving = function(variables, restrictedDomains) {
            var domainByName = _.defaults(restrictedDomains, variables);
            return domainByName
        }, RecursiveBacktrackingSolver.prototype.recursiveSolve = function(constraints, domainByName) {
            if (0 === _.size(domainByName)) {
                var fulfilled = this.checkAssignments(constraints);
                return fulfilled
            }
            var current = _.chain(domainByName).keys().first().value(),
                remainingDomain = _.omit(domainByName, current),
                currentDomain = domainByName[current].domain,
                fulfilled = _.some(currentDomain, function(val) {
                    this.assignments[current] = val;
                    var fulfilled = this.recursiveSolve(constraints, remainingDomain);
                    return fulfilled
                }, this);
            return fulfilled
        }, RecursiveBacktrackingSolver.prototype.checkAssignments = function(constraints) {
            var constraintsFulfilled = _.every(constraints, function(constraint) {
                return constraint.fn()
            }, this);
            return constraintsFulfilled && this.summitSolution(), constraintsFulfilled
        }, RecursiveBacktrackingSolver.prototype.summitSolution = function() {}, Object.subclass("_csp", {}), Object.extend(_csp, {
            version: "0.1",
            DiscreteProblem: Problem
        })
    }), module("users.timfelgentreff.babelsberg.csp_ext").requires("users.timfelgentreff.csp.csp").toRun(function() {
        JSLoader.loadJs(module("users.timfelgentreff.csp.underscore-min").uri()), Object.subclass("csp.Solver", {
            isConstraintObject: !0,
            initialize: function() {
                this.p = new _csp.DiscreteProblem
            },
            newDomain: function(obj, varname, domain) {
                if (0 === domain.length) throw "Empty domain not allowed";
                var temp = Constraint.current;
                Constraint.current = {
                    solver: this
                }, this._current = {
                    varname: varname,
                    domain: domain
                };
                var bbbConstraintVariable = ConstrainedVariable.newConstraintVariableFor(obj, varname);
                bbbConstraintVariable.ensureExternalVariableFor(this), Constraint.current = temp, bbbConstraintVariable.externalVariables(this), delete this._current
            },
            constraintVariableFor: function(value, ivarname, cobj) {
                if (ivarname === csp.Solver.DomainMethod) {
                    if (cobj.parentConstrainedVariable) return theParent = cobj.obj, this.__takeNext__ = !0, cParent = this.constraintVariableFor(cobj.obj, cobj.parentConstrainedVariable.ivarname, cobj.parentConstrainedVariable), cobj.parentConstrainedVariable.externalVariables(this, cParent), delete cParent.__cvar__, cParent;
                    throw "can only assign a domain to a property!"
                }
                if (this.__takeNext__) return delete this.__takeNext__, new csp.Variable(this, ivarname, value, [value]);
                if (!this._current) return null;
                var vari = new csp.Variable(this, this._current.varname, value, this._current.domain);
                return vari
            },
            weight: 1e3,
            always: function(opts, func) {
                func.varMapping = opts.ctx, func.allowTests = !0, func.allowUnsolvableOperations = !0;
                var cobj = new Constraint(func, this);
                if (cobj.allowFailing = !0, this.__domainDefinition__) delete this.__domainDefinition__;
                else {
                    var constraint = this.p.addConstraint([], func),
                        satisfiable = this.p.getSolution({});
                    if (!satisfiable) throw this.p.removeConstraint(constraint), new Error("constraint cannot be satisfied")
                }
                return cobj
            },
            solve: function() {}
        }), Object.extend(csp.Solver, {
            weight: 1e3,
            DomainMethod: "is",
            uniqueName: 42,
            getUniqueName: function() {
                return "var" + csp.Solver.uniqueName++
            }
        }), Object.subclass("csp.Variable", {
            isConstraintObject: !0,
            initialize: function(solver, varname, value, domain) {
                this.solver = solver, this.varname = varname, this.setDomain(domain, value)
            },
            setDomain: function(domain, currentValue) {
                if (this.domain) {
                    if (!this.cspname) throw "inconsistent csp.Variable";
                    currentValue = currentValue || this.value(), this.solver.p.removeVariable(this.cspname, this.domain)
                }
                this.domain = domain, this.cspname = csp.Solver.getUniqueName(), this.cspvariable = this.solver.p.addVariable(this.cspname, domain);
                var valueToAssign = this.domain.indexOf(currentValue) > -1 ? currentValue : this.domain[0];
                this.solver.p.solver.assignments[this.cspname] = valueToAssign
            },
            suggestValue: function(value) {
                var inDomain = this.domain.indexOf(value) > -1;
                if (!inDomain) throw new Error("assigned value is not contained in domain");
                var save = _.clone(this.solver.p.solver.assignments),
                    restrictedDomains = {};
                restrictedDomains[this.cspname] = {
                    domain: [value]
                };
                var satisfiable = this.solver.p.getSolution(restrictedDomains);
                if (!satisfiable) throw _.extend(this.solver.p.solver.assignments, save), new Error("assignment makes constraints not satisfiable")
            },
            value: function() {
                return this.solver.p.getAssignmentFor(this.cspname)
            },
            setReadonly: function() {},
            isReadonly: function() {
                return !1
            },
            cnIn: function(domain) {
                return this.setDomain(domain), this.solver.__domainDefinition__ = !0, !0
            }
        }), Number.prototype.__defineGetter__(csp.Solver.DomainMethod, function() {
            return this
        }), String.prototype.__defineGetter__(csp.Solver.DomainMethod, function() {
            return this
        })
    });